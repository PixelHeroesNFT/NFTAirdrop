{"version":3,"file":"js.cjs.production.min.js","sources":["../src/api/numeric.ts","../node_modules/regenerator-runtime/runtime.js","../src/api/serialize.ts","../src/rpc/types.ts","../src/cryptography/conversions.ts","../src/cryptography/publicKey.ts","../src/cryptography/signature.ts","../src/cryptography/privateKey.ts","../src/cryptography/key.ts","../src/cryptography/jsSignatureProvider.ts","../src/api/transactionAbi.ts","../src/api/index.ts","../src/rpc/chain.ts","../src/rpc/history.ts","../src/rpc/db.ts","../src/rpc/proton/parsers.ts","../src/rpc/proton/countryOptions.ts","../src/rpc/proton/kyc.ts","../src/rpc/proton/metal.ts","../src/rpc/proton/otc.ts","../src/rpc/proton/wrap.ts","../src/rpc/tables.ts","../src/rpc/utils.ts","../src/rpc/pushTransaction.ts","../src/rpc/abiCode.ts","../src/rpc/error.ts","../src/rpc/index.ts","../src/index.ts"],"sourcesContent":["/**\n * @module Numeric\n */\nimport { sha256 } from 'hash.js';\nimport RIPEMD160 from 'ripemd-ts'\nimport * as bs58 from 'bs58'\n\nconst ripemd160 = RIPEMD160.hash as (a: Uint8Array) => ArrayBuffer;\nconst base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nconst base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nconst create_base58_map = () => {\n    const base58M = Array(256).fill(-1) as number[];\n    for (let i = 0; i < base58Chars.length; ++i) {\n        base58M[base58Chars.charCodeAt(i)] = i;\n    }\n    return base58M;\n};\n\nconst base58Map = create_base58_map();\n\nconst create_base64_map = () => {\n    const base64M = Array(256).fill(-1) as number[];\n    for (let i = 0; i < base64Chars.length; ++i) {\n        base64M[base64Chars.charCodeAt(i)] = i;\n    }\n    base64M['='.charCodeAt(0)] = 0;\n    return base64M;\n};\n\nconst base64Map = create_base64_map();\n\n/** Is `bignum` a negative number? */\nexport const isNegative = (bignum: Uint8Array) => {\n    return (bignum[bignum.length - 1] & 0x80) !== 0;\n};\n\n/** Negate `bignum` */\nexport const negate = (bignum: Uint8Array) => {\n    let carry = 1;\n    for (let i = 0; i < bignum.length; ++i) {\n        const x = (~bignum[i] & 0xff) + carry;\n        bignum[i] = x;\n        carry = x >> 8;\n    }\n};\n\n/**\n * Convert an unsigned decimal number in `s` to a bignum\n *\n * @param size bignum size (bytes)\n */\nexport const decimalToBinary = (size: number, s: string) => {\n    const result = new Uint8Array(size);\n    for (let i = 0; i < s.length; ++i) {\n        const srcDigit = s.charCodeAt(i);\n        if (srcDigit < '0'.charCodeAt(0) || srcDigit > '9'.charCodeAt(0)) {\n            throw new Error('invalid number');\n        }\n        let carry = srcDigit - '0'.charCodeAt(0);\n        for (let j = 0; j < size; ++j) {\n            const x = result[j] * 10 + carry;\n            result[j] = x;\n            carry = x >> 8;\n        }\n        if (carry) {\n            throw new Error('number is out of range');\n        }\n    }\n    return result;\n};\n\n/**\n * Convert a signed decimal number in `s` to a bignum\n *\n * @param size bignum size (bytes)\n */\nexport const signedDecimalToBinary = (size: number, s: string) => {\n    const negative = s[0] === '-';\n    if (negative) {\n        s = s.substr(1);\n    }\n    const result = decimalToBinary(size, s);\n    if (negative) {\n        negate(result);\n        if (!isNegative(result)) {\n            throw new Error('number is out of range');\n        }\n    } else if (isNegative(result)) {\n        throw new Error('number is out of range');\n    }\n    return result;\n};\n\n/**\n * Convert `bignum` to an unsigned decimal number\n *\n * @param minDigits 0-pad result to this many digits\n */\nexport const binaryToDecimal = (bignum: Uint8Array, minDigits = 1) => {\n    const result = Array(minDigits).fill('0'.charCodeAt(0)) as number[];\n    for (let i = bignum.length - 1; i >= 0; --i) {\n        let carry = bignum[i];\n        for (let j = 0; j < result.length; ++j) {\n            const x = ((result[j] - '0'.charCodeAt(0)) << 8) + carry;\n            result[j] = '0'.charCodeAt(0) + x % 10;\n            carry = (x / 10) | 0;\n        }\n        while (carry) {\n            result.push('0'.charCodeAt(0) + carry % 10);\n            carry = (carry / 10) | 0;\n        }\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n};\n\n/**\n * Convert `bignum` to a signed decimal number\n *\n * @param minDigits 0-pad result to this many digits\n */\nexport const signedBinaryToDecimal = (bignum: Uint8Array, minDigits = 1) => {\n    if (isNegative(bignum)) {\n        const x = bignum.slice();\n        negate(x);\n        return '-' + binaryToDecimal(x, minDigits);\n    }\n    return binaryToDecimal(bignum, minDigits);\n};\n\nconst base58ToBinaryVarSize = (s: string) => {\n    const result = [] as number[];\n    for (let i = 0; i < s.length; ++i) {\n        let carry = base58Map[s.charCodeAt(i)];\n        if (carry < 0) {\n            throw new Error('invalid base-58 value');\n        }\n        for (let j = 0; j < result.length; ++j) {\n            const x = result[j] * 58 + carry;\n            result[j] = x & 0xff;\n            carry = x >> 8;\n        }\n        if (carry) {\n            result.push(carry);\n        }\n    }\n    for (const ch of s) {\n        if (ch === '1') {\n            result.push(0);\n        } else {\n            break;\n        }\n    }\n    result.reverse();\n    return new Uint8Array(result);\n};\n\n/**\n * Convert an unsigned base-58 number in `s` to a bignum\n *\n * @param size bignum size (bytes)\n */\nexport const base58ToBinary = (size: number, s: string) => {\n    if (!size) {\n        return base58ToBinaryVarSize(s);\n    }\n    const result = new Uint8Array(size);\n    for (let i = 0; i < s.length; ++i) {\n        let carry = base58Map[s.charCodeAt(i)];\n        if (carry < 0) {\n            throw new Error('invalid base-58 value');\n        }\n        for (let j = 0; j < size; ++j) {\n            const x = result[j] * 58 + carry;\n            result[j] = x;\n            carry = x >> 8;\n        }\n        if (carry) {\n            throw new Error('base-58 value is out of range');\n        }\n    }\n    result.reverse();\n    return result;\n};\n\n/**\n * Convert `bignum` to a base-58 number\n *\n * @param minDigits 0-pad result to this many digits\n */\nexport const binaryToBase58 = (bignum: Uint8Array) => {\n    const result = [] as number[];\n    for (const byte of bignum) {\n        let carry = byte;\n        for (let j = 0; j < result.length; ++j) {\n            const x = (base58Map[result[j]] << 8) + carry;\n            result[j] = base58Chars.charCodeAt(x % 58);\n            carry = (x / 58) | 0;\n        }\n        while (carry) {\n            result.push(base58Chars.charCodeAt(carry % 58));\n            carry = (carry / 58) | 0;\n        }\n    }\n    for (const byte of bignum) {\n        if (byte) {\n            break;\n        } else {\n            result.push('1'.charCodeAt(0));\n        }\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n};\n\n/** Convert an unsigned base-64 number in `s` to a bignum */\nexport const base64ToBinary = (s: string) => {\n    let len = s.length;\n    if ((len & 3) === 1 && s[len - 1] === '=') {\n        len -= 1;\n    } // fc appends an extra '='\n    if ((len & 3) !== 0) {\n        throw new Error('base-64 value is not padded correctly');\n    }\n    const groups = len >> 2;\n    let bytes = groups * 3;\n    if (len > 0 && s[len - 1] === '=') {\n        if (s[len - 2] === '=') {\n            bytes -= 2;\n        } else {\n            bytes -= 1;\n        }\n    }\n    const result = new Uint8Array(bytes);\n\n    for (let group = 0; group < groups; ++group) {\n        const digit0 = base64Map[s.charCodeAt(group * 4 + 0)];\n        const digit1 = base64Map[s.charCodeAt(group * 4 + 1)];\n        const digit2 = base64Map[s.charCodeAt(group * 4 + 2)];\n        const digit3 = base64Map[s.charCodeAt(group * 4 + 3)];\n        result[group * 3 + 0] = (digit0 << 2) | (digit1 >> 4);\n        if (group * 3 + 1 < bytes) {\n            result[group * 3 + 1] = ((digit1 & 15) << 4) | (digit2 >> 2);\n        }\n        if (group * 3 + 2 < bytes) {\n            result[group * 3 + 2] = ((digit2 & 3) << 6) | digit3;\n        }\n    }\n    return result;\n};\n\n/** Key types this library supports */\nexport enum KeyType {\n    k1 = 0,\n    r1 = 1,\n    wa = 2,\n}\n\n/** Public key data size, excluding type field */\nexport const publicKeyDataSize = 33;\n\n/** Private key data size, excluding type field */\nexport const privateKeyDataSize = 32;\n\n/** Signature data size, excluding type field */\nexport const signatureDataSize = 65;\n\n/** Public key, private key, or signature in binary form */\nexport interface Key {\n    type: KeyType;\n    data: Uint8Array;\n}\n\nconst digestSuffixRipemd160 = (data: Uint8Array, suffix: string) => {\n    const d = new Uint8Array(data.length + suffix.length);\n    for (let i = 0; i < data.length; ++i) {\n        d[i] = data[i];\n    }\n    for (let i = 0; i < suffix.length; ++i) {\n        d[data.length + i] = suffix.charCodeAt(i);\n    }\n    return ripemd160(d);\n};\n\nconst stringToKey = (s: string, type: KeyType, size: number, suffix: string): Key => {\n    const whole = base58ToBinary(size ? size + 4 : 0, s);\n    const result = { type, data: new Uint8Array(whole.buffer, 0, whole.length - 4) };\n    const digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));\n    if (digest[0] !== whole[whole.length - 4] || digest[1] !== whole[whole.length - 3]\n        || digest[2] !== whole[whole.length - 2] || digest[3] !== whole[whole.length - 1]) {\n        throw new Error('checksum doesn\\'t match');\n    }\n    return result;\n};\n\nconst keyToString = (key: Key, suffix: string, prefix: string) => {\n    const digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));\n    const whole = new Uint8Array(key.data.length + 4);\n    for (let i = 0; i < key.data.length; ++i) {\n        whole[i] = key.data[i];\n    }\n    for (let i = 0; i < 4; ++i) {\n        whole[i + key.data.length] = digest[i];\n    }\n    return prefix + binaryToBase58(whole);\n};\n\n/** Convert key in `s` to binary form */\nexport const stringToPublicKey = (s: string, prefix = 'EOS'): Key => {\n    if (typeof s !== 'string') {\n        throw new Error('expected string containing public key');\n    }\n    if (s.substr(0, 3) === prefix) {\n        const whole = base58ToBinary(publicKeyDataSize + 4, s.substr(3));\n        const key = { type: KeyType.k1, data: new Uint8Array(publicKeyDataSize) };\n        for (let i = 0; i < publicKeyDataSize; ++i) {\n            key.data[i] = whole[i];\n        }\n        const digest = new Uint8Array(ripemd160(key.data));\n        if (digest[0] !== whole[publicKeyDataSize] || digest[1] !== whole[34]\n            || digest[2] !== whole[35] || digest[3] !== whole[36]) {\n            throw new Error('checksum doesn\\'t match');\n        }\n        return key;\n    } else if (s.substr(0, 7) === 'PUB_K1_') {\n        return stringToKey(s.substr(7), KeyType.k1, publicKeyDataSize, 'K1');\n    } else if (s.substr(0, 7) === 'PUB_R1_') {\n        return stringToKey(s.substr(7), KeyType.r1, publicKeyDataSize, 'R1');\n    } else if (s.substr(0, 7) === 'PUB_WA_') {\n        return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');\n    } else {\n        throw new Error('unrecognized public key format');\n    }\n};\n\n/** Convert public `key` to legacy string (base-58) form */\nexport const publicKeyToLegacyString = (key: Key, prefix: string = 'EOS') => {\n    if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {\n        return keyToString(key, '', prefix);\n    } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {\n        throw new Error('Key format not supported in legacy conversion');\n    } else {\n        throw new Error('unrecognized public key format');\n    }\n};\n\n/** Convert `key` to string (base-58) form */\nexport const publicKeyToString = (key: Key) => {\n    if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {\n        return keyToString(key, 'K1', 'PUB_K1_');\n    } else if (key.type === KeyType.r1 && key.data.length === publicKeyDataSize) {\n        return keyToString(key, 'R1', 'PUB_R1_');\n    } else if (key.type === KeyType.wa) {\n        return keyToString(key, 'WA', 'PUB_WA_');\n    } else {\n        throw new Error('unrecognized public key format');\n    }\n};\n\n/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).\n * Leaves other formats untouched\n */\nexport const convertLegacyPublicKey = (s: string, prefix = 'EOS') => {\n    if (s.substr(0, 3) === prefix) {\n        return publicKeyToString(stringToPublicKey(s, prefix));\n    }\n    return s;\n};\n\n\nexport const convertK1ToLegacyPublicKey = (publicKey: string, prefix = 'EOS') => {\n    const K1_PREFIX = 'PUB_K1_'\n\n    if (publicKey.substr(0, K1_PREFIX.length) !== K1_PREFIX) {\n      return publicKey\n    }\n\n    const nonPrefixPublicKey = publicKey.substr(K1_PREFIX.length)\n    const bytesWithChecksum = bs58.decode(nonPrefixPublicKey)\n    const bytes = bytesWithChecksum.slice(0, bytesWithChecksum.length - 4)\n    const suffixBytes = Buffer.from(ripemd160(bytes)).slice(0, 4)\n    const binaryPublicKey = Buffer.from([...bytes, ...suffixBytes])\n    return `${prefix}${bs58.encode(binaryPublicKey)}`\n};\n\n/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).\n * Leaves other formats untouched\n */\nexport const convertLegacyPublicKeys = (keys: string[], prefix = 'EOS') => {\n    return keys.map((key: string) => convertLegacyPublicKey(key, prefix));\n};\n\n/** Convert key in `s` to binary form */\nexport const stringToPrivateKey = (s: string): Key => {\n    if (typeof s !== 'string') {\n        throw new Error('expected string containing private key');\n    }\n    if (s.substr(0, 7) === 'PVT_R1_') {\n        return stringToKey(s.substr(7), KeyType.r1, privateKeyDataSize, 'R1');\n    } else if (s.substr(0, 7) === 'PVT_K1_') {\n        return stringToKey(s.substr(7), KeyType.k1, privateKeyDataSize, 'K1');\n    } else {\n        // todo: Verify checksum: sha256(sha256(key.data)).\n        //       Not critical since a bad key will fail to produce a\n        //       valid signature anyway.\n        const whole = base58ToBinary(privateKeyDataSize + 5, s);\n        const key = { type: KeyType.k1, data: new Uint8Array(privateKeyDataSize) };\n        if (whole[0] !== 0x80) {\n            throw new Error('unrecognized private key type');\n        }\n        for (let i = 0; i < privateKeyDataSize; ++i) {\n            key.data[i] = whole[i + 1];\n        }\n        return key;\n    }\n};\n\n/** Convert private `key` to legacy string (base-58) form */\nexport const privateKeyToLegacyString = (key: Key) => {\n    if (key.type === KeyType.k1 && key.data.length === privateKeyDataSize) {\n        const whole = [] as number[];\n        whole.push(128);\n        key.data.forEach((byte) => whole.push(byte));\n        const digest = new Uint8Array(\n            sha256().update(\n                sha256().update(whole).digest()\n            ).digest()\n        );\n\n        const result = new Uint8Array(privateKeyDataSize + 5);\n        for (let i = 0; i < whole.length; i++) {\n            result[i] = whole[i];\n        }\n        for (let i = 0; i < 4; i++) {\n            result[i + whole.length] = digest[i];\n        }\n        return binaryToBase58(result);\n    } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {\n        throw new Error('Key format not supported in legacy conversion');\n    } else {\n        throw new Error('unrecognized public key format');\n    }\n};\n\n/** Convert `key` to string (base-58) form */\nexport const privateKeyToString = (key: Key) => {\n    if (key.type === KeyType.r1) {\n        return keyToString(key, 'R1', 'PVT_R1_');\n    } else if (key.type === KeyType.k1) {\n        return keyToString(key, 'K1', 'PVT_K1_');\n    } else {\n        throw new Error('unrecognized private key format');\n    }\n};\n\n/** Convert key in `s` to binary form */\nexport const stringToSignature = (s: string): Key => {\n    if (typeof s !== 'string') {\n        throw new Error('expected string containing signature');\n    }\n    if (s.substr(0, 7) === 'SIG_K1_') {\n        return stringToKey(s.substr(7), KeyType.k1, signatureDataSize, 'K1');\n    } else if (s.substr(0, 7) === 'SIG_R1_') {\n        return stringToKey(s.substr(7), KeyType.r1, signatureDataSize, 'R1');\n    } else if (s.substr(0, 7) === 'SIG_WA_') {\n        return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');\n    } else {\n        throw new Error('unrecognized signature format');\n    }\n};\n\n/** Convert `signature` to string (base-58) form */\nexport const signatureToString = (signature: Key) => {\n    if (signature.type === KeyType.k1) {\n        return keyToString(signature, 'K1', 'SIG_K1_');\n    } else if (signature.type === KeyType.r1) {\n        return keyToString(signature, 'R1', 'SIG_R1_');\n    } else if (signature.type === KeyType.wa) {\n        return keyToString(signature, 'WA', 'SIG_WA_');\n    } else {\n        throw new Error('unrecognized signature format');\n    }\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/**\n * @module Serialize\n */\n/* eslint-disable max-classes-per-file */\n/* eslint-disable jsdoc/check-indentation */\n\nimport * as numeric from './numeric';\nimport { Abi, BlockTaposInfo } from '../rpc/types';\nimport { Query } from './types';\nimport 'fast-text-encoding';\n\n/** A field in an abi */\nexport interface Field {\n    /** Field name */\n    name: string;\n\n    /** Type name in string form */\n    typeName: string;\n\n    /** Type of the field */\n    type?: Type;\n}\n\n/** Options for serialize() and deserialize() */\nexport interface SerializerOptions {\n    bytesAsUint8Array?: boolean;\n}\n\n/** State for serialize() and deserialize() */\nexport class SerializerState {\n    public options: SerializerOptions;\n\n    /** Have any binary extensions been skipped? */\n    public skippedBinaryExtension = false;\n\n    constructor(options: SerializerOptions = {}) {\n        this.options = options;\n    }\n}\n\n\n/**\n * An Anyvar (non-short form) may be any of the following:\n *  * null\n *  * string\n *  * number\n *    * Caution: assumes number is int32. Use {type, value} form for other numeric types\n *  * an array of anyvar\n *  * {type, value}\n *      * type is a string matching one of the predefined types in anyvarDefs\n *      * value:\n *          * If type === 'any_object', then value is an object. The values within the object are anyvar.\n *          * If type === 'any_array', then value is an array of anyvar.\n *          * Else, value must be eosjs-compatible with the specified type (e.g. uint64 should be a string\n *            containing the value in decimal).\n *  * Other object. The values within the object are anyvar.\n *\n * The short form is more convenient, but it can't be converted back to binary (serialized).\n * Wherever the anyvar would have {type, value}, it has just the value instead.\n */\nexport type Anyvar = null | string | number | Anyvar[] | { type: string, value: any } | {};\n\ninterface AnyvarDef {\n    index: number;\n    useShortForm: boolean;\n    type: {\n        name: string,\n        serialize(buffer: SerialBuffer, value: any): void,\n        deserialize(buffer: SerialBuffer, state?: SerializerState): any,\n    };\n}\n\n/** A type in an abi */\nexport interface Type {\n    /** Type name */\n    name: string;\n\n    /** Type name this is an alias of, if any */\n    aliasOfName: string;\n\n    /** Type this is an array of, if any */\n    arrayOf?: Type;\n\n    /** Type this is an optional of, if any */\n    optionalOf?: Type;\n\n    /** Marks binary extension fields */\n    extensionOf?: Type;\n\n    /** Base name of this type, if this is a struct */\n    baseName: string;\n\n    /** Base of this type, if this is a struct */\n    base?: Type;\n\n    /** Contained fields, if this is a struct */\n    fields: Field[];\n\n    /** Convert `data` to binary form and store in `buffer` */\n    serialize: (buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean) => void;\n\n    /** Convert data in `buffer` from binary form */\n    deserialize: (buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) => any;\n}\n\n/** Structural representation of a symbol */\nexport interface Symbol {\n    /** Name of the symbol, not including precision */\n    name: string;\n\n    /** Number of digits after the decimal point */\n    precision: number;\n}\n\nexport interface Contract {\n    actions: Map<string, Type>;\n    types: Map<string, Type>;\n}\n\nexport interface Authorization {\n    actor: string;\n    permission: string;\n}\n\n/** Action with data in structured form */\nexport interface Action {\n    account: string;\n    name: string;\n    authorization: Authorization[];\n    data: any;\n    hex_data?: string;\n}\n\n/** Action with data in serialized hex form */\nexport interface SerializedAction {\n    account: string;\n    name: string;\n    authorization: Authorization[];\n    data: string;\n}\n\n/** Serialize and deserialize data */\nexport class SerialBuffer {\n    /** Amount of valid data in `array` */\n    public length: number;\n\n    /** Data in serialized (binary) form */\n    public array: Uint8Array;\n\n    /** Current position while reading (deserializing) */\n    public readPos = 0;\n\n    public textEncoder: TextEncoder;\n    public textDecoder: TextDecoder;\n\n    /**\n     * @param __namedParameters\n     * `array`: `null` if serializing, or binary data to deserialize\n     * `textEncoder`: `TextEncoder` instance to use. Pass in `null` if running in a browser\n     * `textDecoder`: `TextDecider` instance to use. Pass in `null` if running in a browser\n     */\n    constructor({ array, textEncoder, textDecoder } = {} as { array?: Uint8Array, textEncoder?: TextEncoder, textDecoder?: TextDecoder }) {\n        this.array = array || new Uint8Array(1024);\n        this.length = array ? array.length : 0;\n        this.textEncoder = textEncoder || new TextEncoder()\n        this.textDecoder = textDecoder || new TextDecoder('utf-8')\n    }\n\n    /** Resize `array` if needed to have at least `size` bytes free */\n    public reserve(size: number) {\n        if (this.length + size <= this.array.length) {\n            return;\n        }\n        let l = this.array.length;\n        while (this.length + size > l) {\n            l = Math.ceil(l * 1.5);\n        }\n        const newArray = new Uint8Array(l);\n        newArray.set(this.array);\n        this.array = newArray;\n    }\n\n    /** Is there data available to read? */\n    public haveReadData() {\n        return this.readPos < this.length;\n    }\n\n    /** Restart reading from the beginning */\n    public restartRead() {\n        this.readPos = 0;\n    }\n\n    /** Return data with excess storage trimmed away */\n    public asUint8Array() {\n        return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);\n    }\n\n    /** Append bytes */\n    public pushArray(v: number[] | Uint8Array) {\n        this.reserve(v.length);\n        this.array.set(v, this.length);\n        this.length += v.length;\n    }\n\n    /** Append bytes */\n    public push(...v: number[]) {\n        this.pushArray(v);\n    }\n\n    /** Get a single byte */\n    public get() {\n        if (this.readPos < this.length) {\n            return this.array[this.readPos++];\n        }\n        throw new Error('Read past end of buffer');\n    }\n\n    /** Append bytes in `v`. Throws if `len` doesn't match `v.length` */\n    public pushUint8ArrayChecked(v: Uint8Array, len: number) {\n        if (v.length !== len) {\n            throw new Error('Binary data has incorrect size');\n        }\n        this.pushArray(v);\n    }\n\n    /** Get `len` bytes */\n    public getUint8Array(len: number) {\n        if (this.readPos + len > this.length) {\n            throw new Error('Read past end of buffer');\n        }\n        const result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);\n        this.readPos += len;\n        return result;\n    }\n\n    /** Skip `len` bytes */\n    public skip(len: number) {\n        if (this.readPos + len > this.length) {\n            throw new Error('Read past end of buffer');\n        }\n        this.readPos += len;\n    }\n\n    /** Append a `uint16` */\n    public pushUint16(v: number) {\n        this.push((v >> 0) & 0xff, (v >> 8) & 0xff);\n    }\n\n    /** Get a `uint16` */\n    public getUint16() {\n        let v = 0;\n        v |= this.get() << 0;\n        v |= this.get() << 8;\n        return v;\n    }\n\n    /** Append a `uint32` */\n    public pushUint32(v: number) {\n        this.push((v >> 0) & 0xff, (v >> 8) & 0xff, (v >> 16) & 0xff, (v >> 24) & 0xff);\n    }\n\n    /** Get a `uint32` */\n    public getUint32() {\n        let v = 0;\n        v |= this.get() << 0;\n        v |= this.get() << 8;\n        v |= this.get() << 16;\n        v |= this.get() << 24;\n        return v >>> 0;\n    }\n\n    /** Append a `uint64`. *Caution*: `number` only has 53 bits of precision */\n    public pushNumberAsUint64(v: number) {\n        this.pushUint32(v >>> 0);\n        this.pushUint32(Math.floor(v / 0x10000_0000) >>> 0);\n    }\n\n    /**\n     * Get a `uint64` as a `number`. *Caution*: `number` only has 53 bits of precision; some values will change.\n     * `numeric.binaryToDecimal(serialBuffer.getUint8Array(8))` recommended instead\n     */\n    public getUint64AsNumber() {\n        const low = this.getUint32();\n        const high = this.getUint32();\n        return (high >>> 0) * 0x10000_0000 + (low >>> 0);\n    }\n\n    /** Append a `varuint32` */\n    public pushVaruint32(v: number) {\n        while (true) {\n            if (v >>> 7) {\n                this.push(0x80 | (v & 0x7f));\n                v = v >>> 7;\n            } else {\n                this.push(v);\n                break;\n            }\n        }\n    }\n\n    /** Get a `varuint32` */\n    public getVaruint32() {\n        let v = 0;\n        let bit = 0;\n        while (true) {\n            const b = this.get();\n            v |= (b & 0x7f) << bit;\n            bit += 7;\n            if (!(b & 0x80)) {\n                break;\n            }\n        }\n        return v >>> 0;\n    }\n\n    /** Append a `varint32` */\n    public pushVarint32(v: number) {\n        this.pushVaruint32((v << 1) ^ (v >> 31));\n    }\n\n    /** Get a `varint32` */\n    public getVarint32() {\n        const v = this.getVaruint32();\n        if (v & 1) {\n            return ((~v) >> 1) | 0x8000_0000;\n        } else {\n            return v >>> 1;\n        }\n    }\n\n    /** Append a `float32` */\n    public pushFloat32(v: number) {\n        this.pushArray(new Uint8Array((new Float32Array([v])).buffer));\n    }\n\n    /** Get a `float32` */\n    public getFloat32() {\n        return new Float32Array(this.getUint8Array(4).slice().buffer)[0];\n    }\n\n    /** Append a `float64` */\n    public pushFloat64(v: number) {\n        this.pushArray(new Uint8Array((new Float64Array([v])).buffer));\n    }\n\n    /** Get a `float64` */\n    public getFloat64() {\n        return new Float64Array(this.getUint8Array(8).slice().buffer)[0];\n    }\n\n    /** Append a `name` */\n    public pushName(s: string) {\n        if (typeof s !== 'string') {\n            throw new Error('Expected string containing name');\n        }\n        const regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);\n        if (!regex.test(s)) {\n            throw new Error('Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz'); // eslint-disable-line\n        }\n        const charToSymbol = (c: number) => {\n            if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {\n                return (c - 'a'.charCodeAt(0)) + 6;\n            }\n            if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {\n                return (c - '1'.charCodeAt(0)) + 1;\n            }\n            return 0;\n        };\n        const a = new Uint8Array(8);\n        let bit = 63;\n        for (let i = 0; i < s.length; ++i) {\n            let c = charToSymbol(s.charCodeAt(i));\n            if (bit < 5) {\n                c = c << 1;\n            }\n            for (let j = 4; j >= 0; --j) {\n                if (bit >= 0) {\n                    a[Math.floor(bit / 8)] |= ((c >> j) & 1) << (bit % 8);\n                    --bit;\n                }\n            }\n        }\n        this.pushArray(a);\n    }\n\n    /** Get a `name` */\n    public getName() {\n        const a = this.getUint8Array(8);\n        let result = '';\n        for (let bit = 63; bit >= 0;) {\n            let c = 0;\n            for (let i = 0; i < 5; ++i) {\n                if (bit >= 0) {\n                    c = (c << 1) | ((a[Math.floor(bit / 8)] >> (bit % 8)) & 1);\n                    --bit;\n                }\n            }\n            if (c >= 6) {\n                result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);\n            } else if (c >= 1) {\n                result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);\n            } else {\n                result += '.';\n            }\n        }\n        while (result.endsWith('.')) {\n            result = result.substr(0, result.length - 1);\n        }\n        return result;\n    }\n\n    /** Append length-prefixed binary data */\n    public pushBytes(v: number[] | Uint8Array) {\n        this.pushVaruint32(v.length);\n        this.pushArray(v);\n    }\n\n    /** Get length-prefixed binary data */\n    public getBytes() {\n        return this.getUint8Array(this.getVaruint32());\n    }\n\n    /** Append a string */\n    public pushString(v: string) {\n        this.pushBytes(this.textEncoder.encode(v));\n    }\n\n    /** Get a string */\n    public getString() {\n        return this.textDecoder.decode(this.getBytes());\n    }\n\n    /** Append a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */\n    public pushSymbolCode(name: string) {\n        if (typeof name !== 'string') {\n            throw new Error('Expected string containing symbol_code');\n        }\n        const a = [];\n        a.push(...this.textEncoder.encode(name));\n        while (a.length < 8) {\n            a.push(0);\n        }\n        this.pushArray(a.slice(0, 8));\n    }\n\n    /** Get a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */\n    public getSymbolCode() {\n        const a = this.getUint8Array(8);\n        let len;\n        for (len = 0; len < a.length; ++len) {\n            if (!a[len]) {\n                break;\n            }\n        }\n        const name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));\n        return name;\n    }\n\n    /** Append a `symbol` */\n    public pushSymbol({ name, precision }: { name: string, precision: number }) {\n        if (!/^[A-Z]{1,7}$/.test(name)) {\n            throw new Error('Expected symbol to be A-Z and between one and seven characters');\n        }\n        const a = [precision & 0xff];\n        a.push(...this.textEncoder.encode(name));\n        while (a.length < 8) {\n            a.push(0);\n        }\n        this.pushArray(a.slice(0, 8));\n    }\n\n    /** Get a `symbol` */\n    public getSymbol(): { name: string, precision: number } {\n        const precision = this.get();\n        const a = this.getUint8Array(7);\n        let len;\n        for (len = 0; len < a.length; ++len) {\n            if (!a[len]) {\n                break;\n            }\n        }\n        const name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));\n        return { name, precision };\n    }\n\n    /** Append an asset */\n    public pushAsset(s: string) {\n        if (typeof s !== 'string') {\n            throw new Error('Expected string containing asset');\n        }\n        s = s.trim();\n        let pos = 0;\n        let amount = '';\n        let precision = 0;\n        if (s[pos] === '-') {\n            amount += '-';\n            ++pos;\n        }\n        let foundDigit = false;\n        while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {\n            foundDigit = true;\n            amount += s[pos];\n            ++pos;\n        }\n        if (!foundDigit) {\n            throw new Error('Asset must begin with a number');\n        }\n        if (s[pos] === '.') {\n            ++pos;\n            while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {\n                amount += s[pos];\n                ++precision;\n                ++pos;\n            }\n        }\n        const name = s.substr(pos).trim();\n        this.pushArray(numeric.signedDecimalToBinary(8, amount));\n        this.pushSymbol({ name, precision });\n    }\n\n    /** Get an asset */\n    public getAsset() {\n        const amount = this.getUint8Array(8);\n        const { name, precision } = this.getSymbol();\n        let s = numeric.signedBinaryToDecimal(amount, precision + 1);\n        if (precision) {\n            s = s.substr(0, s.length - precision) + '.' + s.substr(s.length - precision);\n        }\n        return s + ' ' + name;\n    }\n\n    /** Append a public key */\n    public pushPublicKey(s: string) {\n        const key = numeric.stringToPublicKey(s);\n        this.push(key.type);\n        this.pushArray(key.data);\n    }\n\n    /** Get a public key */\n    public getPublicKey() {\n        const type = this.get();\n        let data: Uint8Array;\n        if (type === numeric.KeyType.wa) {\n            const begin = this.readPos;\n            this.skip(34);\n            this.skip(this.getVaruint32());\n            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);\n        } else {\n            data = this.getUint8Array(numeric.publicKeyDataSize);\n        }\n        return numeric.publicKeyToString({ type, data });\n    }\n\n    /** Append a private key */\n    public pushPrivateKey(s: string) {\n        const key = numeric.stringToPrivateKey(s);\n        this.push(key.type);\n        this.pushArray(key.data);\n    }\n\n    /** Get a private key */\n    public getPrivateKey() {\n        const type = this.get();\n        const data = this.getUint8Array(numeric.privateKeyDataSize);\n        return numeric.privateKeyToString({ type, data });\n    }\n\n    /** Append a signature */\n    public pushSignature(s: string) {\n        const key = numeric.stringToSignature(s);\n        this.push(key.type);\n        this.pushArray(key.data);\n    }\n\n    /** Get a signature */\n    public getSignature() {\n        const type = this.get();\n        let data: Uint8Array;\n        if (type === numeric.KeyType.wa) {\n            const begin = this.readPos;\n            this.skip(65);\n            this.skip(this.getVaruint32());\n            this.skip(this.getVaruint32());\n            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);\n        } else {\n            data = this.getUint8Array(numeric.signatureDataSize);\n        }\n        return numeric.signatureToString({ type, data });\n    }\n} // SerialBuffer\n\n/** Is this a supported ABI version? */\nexport const supportedAbiVersion = (version: string) => {\n    return version.startsWith('eosio::abi/1.');\n};\n\nconst checkDateParse = (date: string) => {\n    const result = Date.parse(date);\n    if (Number.isNaN(result)) {\n        throw new Error('Invalid time format');\n    }\n    return result;\n};\n\n/** Convert date in ISO format to `time_point` (miliseconds since epoch) */\nexport const dateToTimePoint = (date: string) => {\n    return Math.round(checkDateParse(date + 'Z') * 1000);\n};\n\n/** Convert `time_point` (miliseconds since epoch) to date in ISO format */\nexport const timePointToDate = (us: number) => {\n    const s = (new Date(us / 1000)).toISOString();\n    return s.substr(0, s.length - 1);\n};\n\n/** Convert date in ISO format to `time_point_sec` (seconds since epoch) */\nexport const dateToTimePointSec = (date: string) => {\n    return Math.round(checkDateParse(date + 'Z') / 1000);\n};\n\n/** Convert `time_point_sec` (seconds since epoch) to to date in ISO format */\nexport const timePointSecToDate = (sec: number) => {\n    const s = (new Date(sec * 1000)).toISOString();\n    return s.substr(0, s.length - 1);\n};\n\n/** Convert date in ISO format to `block_timestamp_type` (half-seconds since a different epoch) */\nexport const dateToBlockTimestamp = (date: string) => {\n    return Math.round((checkDateParse(date + 'Z') - 946684800000) / 500);\n};\n\n/** Convert `block_timestamp_type` (half-seconds since a different epoch) to to date in ISO format */\nexport const blockTimestampToDate = (slot: number) => {\n    const s = (new Date(slot * 500 + 946684800000)).toISOString();\n    return s.substr(0, s.length - 1);\n};\n\n/** Convert `string` to `Symbol`. format: `precision,NAME`. */\nexport const stringToSymbol = (s: string): { name: string, precision: number } => {\n    if (typeof s !== 'string') {\n        throw new Error('Expected string containing symbol');\n    }\n    const m = s.match(/^([0-9]+),([A-Z]+)$/);\n    if (!m) {\n        throw new Error('Invalid symbol');\n    }\n    return { name: m[2], precision: +m[1] };\n};\n\n/** Convert `Symbol` to `string`. format: `precision,NAME`. */\nexport const symbolToString = ({ name, precision }: { name: string, precision: number }) => {\n    return precision + ',' + name;\n};\n\n/** Convert binary data to hex */\nexport const arrayToHex = (data: Uint8Array) => {\n    let result = '';\n    for (const x of data) {\n        result += ('00' + x.toString(16)).slice(-2);\n    }\n    return result.toUpperCase();\n};\n\n/** Convert hex to binary data */\nexport const hexToUint8Array = (hex: string) => {\n    if (typeof hex !== 'string') {\n        throw new Error('Expected string containing hex digits');\n    }\n    if (hex.length % 2) {\n        throw new Error('Odd number of hex digits');\n    }\n    const l = hex.length / 2;\n    const result = new Uint8Array(l);\n    for (let i = 0; i < l; ++i) {\n        const x = parseInt(hex.substr(i * 2, 2), 16);\n        if (Number.isNaN(x)) {\n            throw new Error('Expected hex string');\n        }\n        result[i] = x;\n    }\n    return result;\n};\n\nfunction serializeUnknown (this: Type, _: SerialBuffer, __: any): SerialBuffer {\n    throw new Error('Don\\'t know how to serialize ' + this.name);\n}\n\nfunction deserializeUnknown (this: Type, _: SerialBuffer): SerialBuffer {\n    throw new Error('Don\\'t know how to deserialize ' + this.name);\n}\n\nfunction serializeStruct(\n    this: Type, buffer: SerialBuffer, data: any, state = new SerializerState(), allowExtensions = true\n) {\n    if (typeof data !== 'object') {\n        throw new Error('expected object containing data: ' + JSON.stringify(data));\n    }\n    if (this.base) {\n        this.base.serialize(buffer, data, state, allowExtensions);\n    }\n    for (const field of this.fields) {\n        if (field.name in data) {\n            if (state.skippedBinaryExtension) {\n                throw new Error('unexpected ' + this.name + '.' + field.name);\n            }\n            field.type!.serialize(\n                buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);\n        } else {\n            if (allowExtensions && field.type!.extensionOf) {\n                state.skippedBinaryExtension = true;\n            } else {\n                throw new Error('missing ' + this.name + '.' + field.name + ' (type=' + field.type!.name + ')');\n            }\n        }\n    }\n}\n\nfunction deserializeStruct(this: Type, buffer: SerialBuffer, state = new SerializerState(), allowExtensions = true) {\n    let result;\n    if (this.base) {\n        result = this.base.deserialize(buffer, state, allowExtensions);\n    } else {\n        result = {};\n    }\n    for (const field of this.fields) {\n        if (allowExtensions && field.type!.extensionOf && !buffer.haveReadData()) {\n            state.skippedBinaryExtension = true;\n        } else {\n            result[field.name] = field.type!.deserialize(buffer, state, allowExtensions);\n        }\n    }\n    return result;\n}\n\nfunction serializeVariant(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n) {\n    if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== 'string') {\n        throw new Error('expected variant: [\"type\", value]');\n    }\n    const i = this.fields.findIndex((field: Field) => field.name === data[0]);\n    if (i < 0) {\n        throw new Error(`type \"${data[0]}\" is not valid for variant`);\n    }\n    buffer.pushVaruint32(i);\n    this.fields[i].type!.serialize(buffer, data[1], state, allowExtensions);\n}\n\nfunction deserializeVariant(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) {\n    const i = buffer.getVaruint32();\n    if (i >= this.fields.length) {\n        throw new Error(`type index ${i} is not valid for variant`);\n    }\n    const field = this.fields[i];\n    return [field.name, field.type!.deserialize(buffer, state, allowExtensions)];\n}\n\nfunction serializeArray(\n    this: Type, buffer: SerialBuffer, data: any[], state?: SerializerState /*, allowExtensions?: boolean */\n) {\n    buffer.pushVaruint32(data.length);\n    for (const item of data) {\n        this.arrayOf!.serialize(buffer, item, state, false);\n    }\n}\n\nfunction deserializeArray(this: Type, buffer: SerialBuffer, state?: SerializerState /*, allowExtensions?: boolean */) {\n    const len = buffer.getVaruint32();\n    const result = [];\n    for (let i = 0; i < len; ++i) {\n        result.push(this.arrayOf!.deserialize(buffer, state, false));\n    }\n    return result;\n}\n\nfunction serializeOptional(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n) {\n    if (data === null || data === undefined) {\n        buffer.push(0);\n    } else {\n        buffer.push(1);\n        this.optionalOf!.serialize(buffer, data, state, allowExtensions);\n    }\n}\n\nfunction deserializeOptional(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) {\n    if (buffer.get()) {\n        return this.optionalOf!.deserialize(buffer, state, allowExtensions);\n    } else {\n        return null;\n    }\n}\n\nfunction serializeExtension(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n) {\n    this.extensionOf!.serialize(buffer, data, state, allowExtensions);\n}\n\nfunction deserializeExtension(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) {\n    return this.extensionOf!.deserialize(buffer, state, allowExtensions);\n}\n\nfunction serializeObject(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n) {\n    const entries = Object.entries(data);\n    buffer.pushVaruint32(entries.length);\n    for (const [key, value] of entries) {\n        const keyType = this.fields[0].type;\n        const dataType = this.fields[1].type;\n        keyType!.serialize(buffer, key, state, allowExtensions);\n        dataType!.serialize(buffer, value, state, allowExtensions);\n    }\n}\n\nfunction deserializeObject(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) {\n    const len = buffer.getVaruint32();\n    const result = {} as any;\n    for (let i = 0; i < len; ++i) {\n        const keyType = this.fields[0].type;\n        const dataType = this.fields[1].type;\n        const key = keyType!.deserialize(buffer, state, allowExtensions);\n        (result as any)[key] = dataType!.deserialize(buffer, state, allowExtensions);\n    }\n    return result;\n}\n\ninterface CreateTypeArgs {\n    name?: string;\n    aliasOfName?: string;\n    arrayOf?: Type;\n    optionalOf?: Type;\n    extensionOf?: Type;\n    baseName?: string;\n    base?: Type;\n    fields?: Field[];\n    serialize?: (buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean) => void;\n    deserialize?: (buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) => any;\n}\n\nconst createType = (attrs: CreateTypeArgs): Type => {\n    return {\n        name: '<missing name>',\n        aliasOfName: '',\n        arrayOf: undefined,\n        optionalOf: undefined,\n        extensionOf: undefined,\n        baseName: '',\n        base: undefined,\n        fields: [],\n        serialize: serializeUnknown,\n        deserialize: deserializeUnknown,\n        ...attrs,\n    };\n};\n\nconst checkRange = (orig: number, converted: number) => {\n    if (Number.isNaN(+orig) || Number.isNaN(+converted) || (typeof orig !== 'number' && typeof orig !== 'string')) {\n        throw new Error('Expected number');\n    }\n    if (+orig !== +converted) {\n        throw new Error('Number is out of range');\n    }\n    return +orig;\n};\n\n/** Create the set of types built-in to the abi format */\nexport const createInitialTypes = (): Map<string, Type> => {\n    const result: Map<string, Type> = new Map(Object.entries({\n        bool: createType({\n            name: 'bool',\n            serialize: (buffer: SerialBuffer, data: boolean) => {\n                if ( !(typeof data === 'boolean' || typeof data === 'number' && ( data === 1 || data === 0))) {\n                    throw new Error('Expected boolean or number equal to 1 or 0');\n                }\n                buffer.push(data ? 1 : 0);\n            },\n            deserialize: (buffer: SerialBuffer) => { return !!buffer.get(); },\n        }),\n        uint8: createType({\n            name: 'uint8',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.push(checkRange(data, data & 0xff)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.get(); },\n        }),\n        int8: createType({\n            name: 'int8',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.push(checkRange(data, data << 24 >> 24)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.get() << 24 >> 24; },\n        }),\n        uint16: createType({\n            name: 'uint16',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint16(checkRange(data, data & 0xffff)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint16(); },\n        }),\n        int16: createType({\n            name: 'int16',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint16(checkRange(data, data << 16 >> 16)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint16() << 16 >> 16; },\n        }),\n        uint32: createType({\n            name: 'uint32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint32(checkRange(data, data >>> 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint32(); },\n        }),\n        uint64: createType({\n            name: 'uint64',\n            serialize: (buffer: SerialBuffer, data: string | number) => {\n                buffer.pushArray(numeric.decimalToBinary(8, '' + data));\n            },\n            deserialize: (buffer: SerialBuffer) => { return numeric.binaryToDecimal(buffer.getUint8Array(8)); },\n        }),\n        int64: createType({\n            name: 'int64',\n            serialize: (buffer: SerialBuffer, data: string | number) => {\n                buffer.pushArray(numeric.signedDecimalToBinary(8, '' + data));\n            },\n            deserialize: (buffer: SerialBuffer) => { return numeric.signedBinaryToDecimal(buffer.getUint8Array(8)); },\n        }),\n        int32: createType({\n            name: 'int32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint32(checkRange(data, data | 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint32() | 0; },\n        }),\n        varuint32: createType({\n            name: 'varuint32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushVaruint32(checkRange(data, data >>> 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getVaruint32(); },\n        }),\n        varint32: createType({\n            name: 'varint32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushVarint32(checkRange(data, data | 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getVarint32(); },\n        }),\n        uint128: createType({\n            name: 'uint128',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushArray(numeric.decimalToBinary(16, '' + data)); },\n            deserialize: (buffer: SerialBuffer) => { return numeric.binaryToDecimal(buffer.getUint8Array(16)); },\n        }),\n        int128: createType({\n            name: 'int128',\n            serialize: (buffer: SerialBuffer, data: string) => {\n                buffer.pushArray(numeric.signedDecimalToBinary(16, '' + data));\n            },\n            deserialize: (buffer: SerialBuffer) => { return numeric.signedBinaryToDecimal(buffer.getUint8Array(16)); },\n        }),\n        float32: createType({\n            name: 'float32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushFloat32(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getFloat32(); },\n        }),\n        float64: createType({\n            name: 'float64',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushFloat64(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getFloat64(); },\n        }),\n        float128: createType({\n            name: 'float128',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(16)); },\n        }),\n\n        bytes: createType({\n            name: 'bytes',\n            serialize: (buffer: SerialBuffer, data: string | Uint8Array | number[]) => {\n                if (data instanceof Uint8Array || Array.isArray(data)) {\n                    buffer.pushBytes(data);\n                } else {\n                    buffer.pushBytes(hexToUint8Array(data));\n                }\n            },\n            deserialize: (buffer: SerialBuffer, state?: SerializerState) => {\n                if (state && state.options.bytesAsUint8Array) {\n                    return buffer.getBytes();\n                } else {\n                    return arrayToHex(buffer.getBytes());\n                }\n            },\n        }),\n        string: createType({\n            name: 'string',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushString(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getString(); },\n        }),\n        name: createType({\n            name: 'name',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushName(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getName(); },\n        }),\n        time_point: createType({\n            name: 'time_point',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushNumberAsUint64(dateToTimePoint(data)); },\n            deserialize: (buffer: SerialBuffer) => { return timePointToDate(buffer.getUint64AsNumber()); },\n        }),\n        time_point_sec: createType({\n            name: 'time_point_sec',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint32(dateToTimePointSec(data)); },\n            deserialize: (buffer: SerialBuffer) => { return timePointSecToDate(buffer.getUint32()); },\n        }),\n        block_timestamp_type: createType({\n            name: 'block_timestamp_type',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint32(dateToBlockTimestamp(data)); },\n            deserialize: (buffer: SerialBuffer) => { return blockTimestampToDate(buffer.getUint32()); },\n        }),\n        symbol_code: createType({\n            name: 'symbol_code',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushSymbolCode(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getSymbolCode(); },\n        }),\n        symbol: createType({\n            name: 'symbol',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushSymbol(stringToSymbol(data)); },\n            deserialize: (buffer: SerialBuffer) => { return symbolToString(buffer.getSymbol()); },\n        }),\n        asset: createType({\n            name: 'asset',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushAsset(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getAsset(); },\n        }),\n        checksum160: createType({\n            name: 'checksum160',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(20)); },\n        }),\n        checksum256: createType({\n            name: 'checksum256',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(32)); },\n        }),\n        checksum512: createType({\n            name: 'checksum512',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(64)); },\n        }),\n        public_key: createType({\n            name: 'public_key',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushPublicKey(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getPublicKey(); },\n        }),\n        private_key: createType({\n            name: 'private_key',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushPrivateKey(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getPrivateKey(); },\n        }),\n        signature: createType({\n            name: 'signature',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushSignature(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getSignature(); },\n        }),\n    }));\n\n    result.set('extended_asset', createType({\n        name: 'extended_asset',\n        baseName: '',\n        fields: [\n            { name: 'quantity', typeName: 'asset', type: result.get('asset') },\n            { name: 'contract', typeName: 'name', type: result.get('name') },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n\n    return result;\n}; // createInitialTypes()\n\nexport const createAbiTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('extensions_entry', createType({\n        name: 'extensions_entry',\n        baseName: '',\n        fields: [\n            { name: 'tag', typeName: 'uint16', type: undefined },\n            { name: 'value', typeName: 'bytes', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('type_def', createType({\n        name: 'type_def',\n        baseName: '',\n        fields: [\n            { name: 'new_type_name', typeName: 'string', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('field_def', createType({\n        name: 'field_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'string', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('struct_def', createType({\n        name: 'struct_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'string', type: undefined },\n            { name: 'base', typeName: 'string', type: undefined },\n            { name: 'fields', typeName: 'field_def[]', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('action_def', createType({\n        name: 'action_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined },\n            { name: 'ricardian_contract', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('table_def', createType({\n        name: 'table_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'index_type', typeName: 'string', type: undefined },\n            { name: 'key_names', typeName: 'string[]', type: undefined },\n            { name: 'key_types', typeName: 'string[]', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('clause_pair', createType({\n        name: 'clause_pair',\n        baseName: '',\n        fields: [\n            { name: 'id', typeName: 'string', type: undefined },\n            { name: 'body', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('error_message', createType({\n        name: 'error_message',\n        baseName: '',\n        fields: [\n            { name: 'error_code', typeName: 'uint64', type: undefined },\n            { name: 'error_msg', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('variant_def', createType({\n        name: 'variant_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'string', type: undefined },\n            { name: 'types', typeName: 'string[]', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('action_result', createType({\n        name: 'action_result',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'result_type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('primary_key_index_def', createType({\n        name: 'primary_key_index_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('secondary_index_def', createType({\n        name: 'secondary_index_def',\n        baseName: '',\n        fields: [\n            { name: 'type', typeName: 'string', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('secondary_indices', createType({\n        name: 'secondary_indices',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'secondary_index_def', typeName: 'secondary_index_def', type: undefined }\n        ],\n        serialize: serializeObject,\n        deserialize: deserializeObject,\n    }));\n    initialTypes.set('kv_table_entry_def', createType({\n        name: 'kv_table_entry_def',\n        baseName: '',\n        fields: [\n            { name: 'type', typeName: 'string', type: undefined },\n            { name: 'primary_index', typeName: 'primary_key_index_def', type: undefined },\n            { name: 'secondary_indices', typeName: 'secondary_indices', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('kv_table', createType({\n        name: 'kv_table',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'kv_table_entry_def', typeName: 'kv_table_entry_def', type: undefined }\n        ],\n        serialize: serializeObject,\n        deserialize: deserializeObject\n    }));\n    initialTypes.set('abi_def', createType({\n        name: 'abi_def',\n        baseName: '',\n        fields: [\n            { name: 'version', typeName: 'string', type: undefined },\n            { name: 'types', typeName: 'type_def[]', type: undefined },\n            { name: 'structs', typeName: 'struct_def[]', type: undefined },\n            { name: 'actions', typeName: 'action_def[]', type: undefined },\n            { name: 'tables', typeName: 'table_def[]', type: undefined },\n            { name: 'ricardian_clauses', typeName: 'clause_pair[]', type: undefined },\n            { name: 'error_messages', typeName: 'error_message[]', type: undefined },\n            { name: 'abi_extensions', typeName: 'extensions_entry[]', type: undefined },\n            { name: 'variants', typeName: 'variant_def[]$', type: undefined },\n            { name: 'action_results', typeName: 'action_result[]$', type: undefined },\n            { name: 'kv_tables', typeName: 'kv_table$', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    return initialTypes;\n};\n\n/** Get type from `types` */\nexport const getType = (types: Map<string, Type>, name: string): Type => {\n    const type = types.get(name);\n    if (type && type.aliasOfName) {\n        return getType(types, type.aliasOfName);\n    }\n    if (type) {\n        return type;\n    }\n    if (name.endsWith('[]')) {\n        return createType({\n            name,\n            arrayOf: getType(types, name.substr(0, name.length - 2)),\n            serialize: serializeArray,\n            deserialize: deserializeArray,\n        });\n    }\n    if (name.endsWith('?')) {\n        return createType({\n            name,\n            optionalOf: getType(types, name.substr(0, name.length - 1)),\n            serialize: serializeOptional,\n            deserialize: deserializeOptional,\n        });\n    }\n    if (name.endsWith('$')) {\n        return createType({\n            name,\n            extensionOf: getType(types, name.substr(0, name.length - 1)),\n            serialize: serializeExtension,\n            deserialize: deserializeExtension,\n        });\n    }\n    throw new Error('Unknown type: ' + name);\n};\n\n/**\n * Get types from abi\n *\n * @param initialTypes Set of types to build on.\n * In most cases, it's best to fill this from a fresh call to `getTypesFromAbi()`.\n */\nexport const getTypesFromAbi = (initialTypes: Map<string, Type>, abi?: Abi) => {\n    const types = new Map(initialTypes);\n    if (abi && abi.types) {\n        for (const { new_type_name, type } of abi.types) {\n            types.set(new_type_name,\n                createType({ name: new_type_name, aliasOfName: type }));\n        }\n    }\n    if (abi && abi.structs) {\n        for (const { name, base, fields } of abi.structs) {\n            types.set(name, createType({\n                name,\n                baseName: base,\n                fields: fields.map(({ name: n, type }) => ({ name: n, typeName: type, type: undefined })),\n                serialize: serializeStruct,\n                deserialize: deserializeStruct,\n            }));\n        }\n    }\n    if (abi && abi.variants) {\n        for (const { name, types: t } of abi.variants) {\n            types.set(name, createType({\n                name,\n                fields: t.map((s) => ({ name: s, typeName: s, type: undefined })),\n                serialize: serializeVariant,\n                deserialize: deserializeVariant,\n            }));\n        }\n    }\n    for (const [/*name*/ _, type] of types) {\n        if (type.baseName) {\n            type.base = getType(types, type.baseName);\n        }\n        for (const field of type.fields) {\n            field.type = getType(types, field.typeName);\n        }\n    }\n    return types;\n}; // getTypesFromAbi\n\nconst reverseHex = (h: string) => {\n    return h.substr(6, 2) + h.substr(4, 2) + h.substr(2, 2) + h.substr(0, 2);\n};\n\n/** TAPoS: Return transaction fields which reference `refBlock` and expire `expireSeconds` after `timestamp` */\nexport const transactionHeader = (refBlock: BlockTaposInfo, expireSeconds: number) => {\n    const timestamp = refBlock.header ? refBlock.header.timestamp : refBlock.timestamp;\n    const prefix = parseInt(reverseHex(refBlock.id.substr(16, 8)), 16);\n\n    return {\n        expiration: timePointSecToDate(dateToTimePointSec(timestamp as string) + expireSeconds),\n        ref_block_num: refBlock.block_num & 0xffff,\n        ref_block_prefix: prefix,\n    };\n};\n\n/** Convert action data to serialized form (hex) */\nexport const serializeActionData = (\n    contract: Contract, account: string, name: string, data: any\n): string => {\n    const action = contract.actions.get(name);\n    if (!action) {\n        throw new Error(`Unknown action ${name} in contract ${account}`);\n    }\n    const buffer = new SerialBuffer();\n    action.serialize(buffer, data);\n    return arrayToHex(buffer.asUint8Array());\n};\n\n/** Return action in serialized form */\nexport const serializeAction = (\n    contract: Contract, account: string, name: string, authorization: Authorization[],\n    data: any\n): SerializedAction => {\n    return {\n        account,\n        name,\n        authorization,\n        data: serializeActionData(contract, account, name, data),\n    };\n};\n\n/** Deserialize action data. If `data` is a `string`, then it's assumed to be in hex. */\nexport const deserializeActionData = (\n    contract: Contract, account: string, name: string, data: string | Uint8Array | number[]\n): any => {\n    const action = contract.actions.get(name);\n    if (typeof data === 'string') {\n        data = hexToUint8Array(data);\n    }\n    if (!action) {\n        throw new Error(`Unknown action ${name} in contract ${account}`);\n    }\n    const buffer = new SerialBuffer();\n    buffer.pushArray(data);\n    return action.deserialize(buffer);\n};\n\n/** Deserialize action. If `data` is a `string`, then it's assumed to be in hex. */\nexport const deserializeAction = (\n    contract: Contract, account: string, name: string, authorization: Authorization[],\n    data: string | Uint8Array | number[]\n): Action => {\n    return {\n        account,\n        name,\n        authorization,\n        data: deserializeActionData(contract, account, name, data),\n    };\n};\n\nexport const serializeAnyvar = (buffer: SerialBuffer, anyvar: Anyvar) => {\n    let def: AnyvarDef;\n    let value: any;\n    if (anyvar === null) {\n        [def, value] = [anyvarDefs.null_t, anyvar] as any;\n    } else if (typeof anyvar === 'string') {\n        [def, value] = [anyvarDefs.string, anyvar] as any;\n    } else if (typeof anyvar === 'number') {\n        [def, value] = [anyvarDefs.int32, anyvar] as any;\n    } else if (anyvar instanceof Uint8Array) {\n        [def, value] = [anyvarDefs.bytes, anyvar] as any;\n    } else if (Array.isArray(anyvar)) {\n        [def, value] = [anyvarDefs.any_array, anyvar] as any;\n    } else if (Object.keys(anyvar).length === 2 && anyvar.hasOwnProperty('type') && anyvar.hasOwnProperty('value')) {\n        [def, value] = [(anyvarDefs as any)[(anyvar as any).type] as AnyvarDef, (anyvar as any).value] as any;\n    } else {\n        [def, value] = [anyvarDefs.any_object, anyvar] as any;\n    }\n    buffer.pushVaruint32(def.index);\n    def.type.serialize(buffer, value);\n};\n\nexport const deserializeAnyvar = (buffer: SerialBuffer, state?: SerializerState) => {\n    const defIndex = buffer.getVaruint32();\n    if (defIndex >= anyvarDefsByIndex.length) {\n        throw new Error('Tried to deserialize unknown anyvar type');\n    }\n    const def = anyvarDefsByIndex[defIndex];\n    const value = def.type!.deserialize(buffer, state);\n    if (state && (state.options as any).useShortForm || def.useShortForm) {\n        return value;\n    } else {\n        return { type: def.type!.name, value };\n    }\n};\n\nexport const deserializeAnyvarShort = (buffer: SerialBuffer) => {\n    return deserializeAnyvar(buffer, new SerializerState({ useShortForm: true } as any));\n};\n\nexport const serializeAnyObject = (buffer: SerialBuffer, obj: any) => {\n    const entries = Object.entries(obj);\n    buffer.pushVaruint32(entries.length);\n    for (const [key, value] of entries) {\n        buffer.pushString(key);\n        serializeAnyvar(buffer, value as Anyvar);\n    }\n};\n\nexport const deserializeAnyObject = (buffer: SerialBuffer, state?: SerializerState) => {\n    const len = buffer.getVaruint32();\n    const result = {};\n    for (let i = 0; i < len; ++i) {\n        let key = buffer.getString();\n        if (key in result) {\n            let j = 1;\n            while (key + '_' + j in result) {\n                ++j;\n            }\n            key = key + '_' + j;\n        }\n        (result as any)[key] = deserializeAnyvar(buffer, state);\n    }\n    return result;\n};\n\nexport const serializeAnyArray = (buffer: SerialBuffer, arr: Anyvar[]) => {\n    buffer.pushVaruint32(arr.length);\n    for (const x of arr) {\n        serializeAnyvar(buffer, x);\n    }\n};\n\nexport const deserializeAnyArray = (buffer: SerialBuffer, state?: SerializerState) => {\n    const len = buffer.getVaruint32();\n    const result = [];\n    for (let i = 0; i < len; ++i) {\n        result.push(deserializeAnyvar(buffer, state));\n    }\n    return result;\n};\n\nconst addAdditionalTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('null_t', createType({\n        name: 'null_t',\n        serialize: (_: SerialBuffer, __: Anyvar) => {},\n        deserialize: (_: SerialBuffer, __?: SerializerState) => {}\n    }));\n    initialTypes.set('any_object', createType({\n        name: 'any_object',\n        serialize: serializeAnyObject,\n        deserialize: deserializeAnyObject\n    }));\n    initialTypes.set('any_array', createType({\n        name: 'any_array',\n        serialize: serializeAnyArray,\n        deserialize: deserializeAnyArray\n    }));\n    return initialTypes;\n};\n\nconst additionalTypes = addAdditionalTypes();\n\nconst anyvarDefs = {\n    null_t: { index: 0, useShortForm: true, type: additionalTypes.get('null_t') },\n    int64: { index: 1, useShortForm: false, type: additionalTypes.get('int64') },\n    uint64: { index: 2, useShortForm: false, type: additionalTypes.get('uint64') },\n    int32: { index: 3, useShortForm: true, type: additionalTypes.get('int32') },\n    uint32: { index: 4, useShortForm: false, type: additionalTypes.get('uint32') },\n    int16: { index: 5, useShortForm: false, type: additionalTypes.get('int16') },\n    uint16: { index: 6, useShortForm: false, type: additionalTypes.get('uint16') },\n    int8: { index: 7, useShortForm: false, type: additionalTypes.get('int8') },\n    uint8: { index: 8, useShortForm: false, type: additionalTypes.get('uint8') },\n    time_point: { index: 9, useShortForm: false, type: additionalTypes.get('time_point') },\n    checksum256: { index: 10, useShortForm: false, type: additionalTypes.get('checksum256') },\n    float64: { index: 11, useShortForm: false, type: additionalTypes.get('float64') },\n    string: { index: 12, useShortForm: true, type: additionalTypes.get('string') },\n    any_object: { index: 13, useShortForm: true, type: additionalTypes.get('any_object') },\n    any_array: { index: 14, useShortForm: true, type: additionalTypes.get('any_array') },\n    bytes: { index: 15, useShortForm: false, type: additionalTypes.get('bytes') },\n    symbol: { index: 16, useShortForm: false, type: additionalTypes.get('symbol') },\n    symbol_code: { index: 17, useShortForm: false, type: additionalTypes.get('symbol_code') },\n    asset: { index: 18, useShortForm: false, type: additionalTypes.get('asset') },\n};\n\nconst anyvarDefsByIndex = [\n    anyvarDefs.null_t,\n    anyvarDefs.int64,\n    anyvarDefs.uint64,\n    anyvarDefs.int32,\n    anyvarDefs.uint32,\n    anyvarDefs.int16,\n    anyvarDefs.uint16,\n    anyvarDefs.int8,\n    anyvarDefs.uint8,\n    anyvarDefs.time_point,\n    anyvarDefs.checksum256,\n    anyvarDefs.float64,\n    anyvarDefs.string,\n    anyvarDefs.any_object,\n    anyvarDefs.any_array,\n    anyvarDefs.bytes,\n    anyvarDefs.symbol,\n    anyvarDefs.symbol_code,\n    anyvarDefs.asset,\n];\n\nexport const serializeQuery = (buffer: SerialBuffer, query: Query) => {\n    let method: string;\n    let arg: Anyvar;\n    let filter: Query[];\n    if (typeof query === 'string') {\n        method = query;\n    } else if (Array.isArray(query) && query.length === 2) {\n        [method, filter] = query;\n    } else if (Array.isArray(query) && query.length === 3) {\n        [method, arg, filter] = query;\n    } else {\n        [method, arg, filter] = [query.method, query.arg, query.filter] as any;\n    }\n    buffer.pushString(method);\n\n    // @ts-ignore\n    if (arg === undefined) {\n        buffer.push(0);\n    } else {\n        buffer.push(1);\n        serializeAnyvar(buffer, arg);\n    }\n\n    // @ts-ignore\n    if (filter === undefined) {\n        buffer.push(0);\n    } else {\n        buffer.pushVaruint32(filter.length);\n        for (const q of filter) {\n            serializeQuery(buffer, q);\n        }\n    }\n};\n","/**\n * @module RPC-API-Methods\n * copyright defined in eosjs/LICENSE.txt\n */\n\n/** Structured format for abis */\nexport interface Abi {\n    version: string;\n    types: { new_type_name: string, type: string }[];\n    structs: { name: string, base: string, fields: { name: string, type: string }[] }[];\n    actions: { name: string, type: string, ricardian_contract: string }[];\n    tables: { name: string, type: string, index_type: string, key_names: string[], key_types: string[] }[];\n    ricardian_clauses: { id: string, body: string }[];\n    error_messages: { error_code: string, error_msg: string }[];\n    abi_extensions: { tag: number, value: string }[];\n    variants?: { name: string, types: string[] }[];\n}\n\nexport interface BlockHeader {\n    timestamp: string;\n    producer: string;\n    confirmed: number;\n    previous: string;\n    transaction_mroot: string;\n    action_mroot: string;\n    schedule_version: number;\n    new_producers: any;\n    header_extensions: any;\n}\n\nexport interface SignedBlockHeader extends BlockHeader {\n    producer_signature: string;\n}\n\n/** Return value of `/v1/chain/get_abi` */\nexport interface GetAbiResult {\n    account_name: string;\n    abi: Abi;\n}\n\n/** Return value of `/v1/chain/get_block_info` */\nexport interface GetBlockInfoResult {\n    timestamp: string;\n    producer: string;\n    confirmed: number;\n    previous: string;\n    transaction_mroot: string;\n    action_mroot: string;\n    schedule_version: number;\n    producer_signature: string;\n    id: string;\n    block_num: number;\n    ref_block_prefix: number;\n}\n\n/** Return value of `/v1/chain/get_block` */\nexport interface GetBlockResult {\n    timestamp: string;\n    producer: string;\n    confirmed: number;\n    previous: string;\n    transaction_mroot: string;\n    action_mroot: string;\n    schedule_version: number;\n    producer_signature: string;\n    id: string;\n    block_num: number;\n    ref_block_prefix: number;\n}\n\n/** Used to calculate TAPoS fields in transactions */\nexport interface BlockTaposInfo {\n    block_num: number;\n    id: string;\n    timestamp?: string;\n    header?: BlockHeader;\n}\n\n/** Return value of `v1/chain/get_block_header_state */\nexport interface GetBlockHeaderStateResult {\n    id: string;\n    header: SignedBlockHeader;\n    pending_schedule: any;\n    activated_protocol_features: any;\n    block_num: number;\n    dpos_proposed_irreversible_blocknum: number;\n    dpos_irreversible_blocknum: number;\n    active_schedule: any;\n    blockroot_merkle: any;\n    producer_to_last_produced: any;\n    producer_to_last_implied_irb: any;\n    block_signing_key: string;\n    confirm_count: any;\n}\n\n/** Subset of `GetBlockHeaderStateResult` used to calculate TAPoS fields in transactions */\nexport interface BlockHeaderStateTaposInfo {\n    block_num: number;\n    id: string;\n    header: SignedBlockHeader;\n}\n\n/** Return value of `/v1/chain/get_code` */\nexport interface GetCodeResult {\n    account_name: string;\n    code_hash: string;\n    wast: string;\n    wasm: string;\n    abi: Abi;\n}\n\n/** Return value of `/v1/chain/get_info` */\nexport interface GetInfoResult {\n    server_version: string;\n    chain_id: string;\n    head_block_num: number;\n    last_irreversible_block_num: number;\n    last_irreversible_block_id: string;\n    last_irreversible_block_time: string;\n    head_block_id: string;\n    head_block_time: string;\n    head_block_producer: string;\n    virtual_block_cpu_limit: number;\n    virtual_block_net_limit: number;\n    block_cpu_limit: number;\n    block_net_limit: number;\n}\n\n/** Return value of `/v1/chain/get_raw_code_and_abi` */\nexport interface GetRawCodeAndAbiResult {\n    account_name: string;\n    wasm: string;\n    abi: string;\n}\n\n/** Return value of `/v1/chain/get_raw_abi` */\nexport interface GetRawAbiResult {\n    account_name: string;\n    code_hash: string;\n    abi_hash: string;\n    abi: string;\n}\n\n/** Arguments for `push_transaction` */\nexport interface PushTransactionArgs {\n    signatures: string[];\n    compression?: number;\n    serializedTransaction: Uint8Array;\n    serializedContextFreeData?: Uint8Array;\n}\n\n\n/** Return value of `/v1/chain/get_activated_protocol_features` */\nexport interface Specification {\n    name:  string;\n    value: string;\n}\n\nexport interface GetActivatedProtocolFeaturesResult {\n    feature_digest:        string;\n    activation_ordinal:    number;\n    activation_block_num:  number;\n    description_digest:    string;\n    dependencies:          any[];\n    protocol_feature_type: string;\n    specification:         Specification[];\n}\n\n/** Return value of `/v1/chain/get_account`  */\nexport type KycInfo = {\n    kyc_provider: string;\n    kyc_level: string;\n    kyc_date: number;\n}\n\n/** Return value of get_table_rows on kycproviders */\nexport type KycProvider = {\n    blisted: number;\n    desc: string;\n    iconurl: string;\n    kyc_provider: string;\n    name: string;\n    url: string;\n}\n\nexport type UserInfo = {\n    acc: string;\n    avatar: string;\n    date: number;\n    aacts: any[]; \n    ac: any[];\n    isLightKYCVerified?: boolean;\n    kyc: KycInfo[];\n    name: string;\n    raccs: any[];\n    verified: number;\n    verifiedon: number;\n    verifier: string;\n}\n\nexport interface Country {\n    id: string;\n    name: string;\n    region: string;\n    active: boolean;\n    localCurrency: string;\n}\n\nexport interface CountryOption {\n    key: string;\n    value: string;\n    flag: string;\n    text: string;\n}\n\nexport interface ApplyForKycParams {\n    chain: string;\n    actor: string;\n    permission: string;\n    transaction: any;\n    signatures: string[];\n    chainId: string;\n}\n  \nexport interface KycApplyResponse {\n    id:           string;\n    chainAccount: string;\n    status:       string;\n    tier:         number;\n    created:      Date;\n    updated:      Date;\n}\n  \nexport interface KycIpInfo {\n    ip:             string;\n    type:           string;\n    continent_code: string;\n    continent_name: string;\n    country_code:   string;\n    country_name:   string;\n    region_code:    string;\n    region_name:    string;\n    city:           string;\n    zip:            string;\n    latitude:       number;\n    longitude:      number;\n    location: {\n      geoname_id: number;\n      capital: string;\n      languages: {\n        code:   string;\n        name:   string;\n        native: string;\n      } [];\n      country_flag:               string;\n      country_flag_emoji:         string;\n      country_flag_emoji_unicode: string;\n      calling_code:               string;\n      is_eu:                      boolean;\n    };\n    time_zone: {\n      id:                 string;\n      current_time:       Date;\n      gmt_offset:         number;\n      code:               string;\n      is_daylight_saving: boolean;\n    };\n    currency: {\n      code:          string;\n      name:          string;\n      plural:        string;\n      symbol:        string;\n      symbol_native: string;\n    };\n    connection: {\n      asn: number;\n      isp: string;\n    };\n}\n\nexport enum KycStatus {\n    FAILED = \"FAILED\",\n    UNSUBMITTED = \"UNSUBMITTED\",\n    PENDING = \"PENDING\",\n    PASSED = \"PASSED\"\n}\n\nexport type KycStatusResponse = {\n    tier: string;\n    status: KycStatus;\n}[]\n","import {ec as EC} from 'elliptic';\nimport * as hash from 'hash.js';\nimport {KeyType} from '../api/numeric';\n\n/** Construct the elliptic curve object based on key type */\nexport const constructElliptic = (type: KeyType): EC => {\n    if (type === KeyType.k1) {\n        return new EC('secp256k1');\n    }\n    return new EC('p256');\n};\n\nexport const sha256 = (data: string|Buffer): string => {\n    return hash.sha256().update(data).digest('hex');\n};\n","import { ec as EC } from 'elliptic';\nimport {\n    Key,\n    KeyType,\n    publicKeyToLegacyString,\n    publicKeyToString,\n    stringToPublicKey,\n} from '../api/numeric';\nimport { constructElliptic } from './conversions';\n\n/** Represents/stores a public key and provides easy conversion for use with `elliptic` lib */\nexport class PublicKey {\n    constructor(private key: Key, private ec: EC) {}\n\n    /** Instantiate public key from an EOSIO-format public key */\n    public static fromString(publicKeyStr: string, ec?: EC): PublicKey {\n        const key = stringToPublicKey(publicKeyStr);\n        if (!ec) {\n            ec = constructElliptic(key.type);\n        }\n        return new PublicKey(key, ec);\n    }\n\n    /** Instantiate public key from an `elliptic`-format public key */\n    public static fromElliptic(publicKey: EC.KeyPair, keyType: KeyType, ec?: EC): PublicKey {\n        const x = publicKey.getPublic().getX().toArray('be', 32);\n        const y = publicKey.getPublic().getY().toArray('be', 32);\n        if (!ec) {\n            ec = constructElliptic(keyType);\n        }\n        return new PublicKey({\n            type: keyType,\n            data: new Uint8Array([(y[31] & 1) ? 3 : 2].concat(x)),\n        }, ec);\n    }\n\n    /** Export public key as EOSIO-format public key */\n    public toString(): string {\n        return publicKeyToString(this.key);\n    }\n\n    /** Export public key as Legacy EOSIO-format public key */\n    public toLegacyString(prefix?: string): string {\n        return publicKeyToLegacyString(this.key, prefix);\n    }\n\n    /** Export public key as `elliptic`-format public key */\n    public toElliptic(): EC.KeyPair {\n        return this.ec.keyPair({\n            pub: Buffer.from(this.key.data),\n        });\n    }\n\n    /** Get key type from key */\n    public getType(): KeyType {\n        return this.key.type;\n    }\n\n    /** Validate a public key */\n    public isValid(): boolean {\n        try {\n            const ellipticPublicKey = this.toElliptic();\n            const validationObj = ellipticPublicKey.validate();\n            return validationObj.result;\n        } catch {\n            return false;\n        }\n    }\n}\n","import { BNInput, ec as EC } from 'elliptic';\nconst BN = require('bn.js');\n\nimport {\n    Key,\n    KeyType,\n    signatureToString,\n    stringToSignature,\n} from '../api/numeric';\nimport { constructElliptic } from './conversions';\nimport { PublicKey } from './publicKey'\n\n/** Represents/stores a Signature and provides easy conversion for use with `elliptic` lib */\nexport class Signature {\n    constructor(private signature: Key, private ec: EC) {}\n\n    /** Instantiate Signature from an EOSIO-format Signature */\n    public static fromString(sig: string, ec?: EC): Signature {\n        const signature = stringToSignature(sig);\n        if (!ec) {\n            ec = constructElliptic(signature.type);\n        }\n        return new Signature(signature, ec);\n    }\n\n    /** Instantiate Signature from an `elliptic`-format Signature */\n    public static fromElliptic(ellipticSig: EC.Signature, keyType: KeyType, ec?: EC): Signature {\n        if (!ellipticSig.recoveryParam) {\n            ellipticSig.recoveryParam = 0\n        }\n\n        const r = ellipticSig.r.toArray('be', 32);\n        const s = ellipticSig.s.toArray('be', 32);\n        let eosioRecoveryParam;\n        if (keyType === KeyType.k1 || keyType === KeyType.r1) {\n            eosioRecoveryParam = ellipticSig.recoveryParam + 27;\n            if (ellipticSig.recoveryParam <= 3) {\n                eosioRecoveryParam += 4;\n            }\n        } else if (keyType === KeyType.wa) {\n            eosioRecoveryParam = ellipticSig.recoveryParam;\n        }\n        const sigData = new Uint8Array([eosioRecoveryParam].concat(r, s) as any);\n        if (!ec) {\n            ec = constructElliptic(keyType);\n        }\n        return new Signature({\n            type: keyType,\n            data: sigData,\n        }, ec);\n    }\n\n    /** Export Signature as `elliptic`-format Signature\n     * NOTE: This isn't an actual elliptic-format Signature, as ec.Signature is not exported by the library.\n     * That's also why the return type is `any`.  We're *actually* returning an object with the 3 params\n     * not an ec.Signature.\n     * Further NOTE: @types/elliptic shows ec.Signature as exported; it is *not*.  Hence the `any`.\n     */\n    public toElliptic(): any {\n        const lengthOfR = 32;\n        const lengthOfS = 32;\n        const r = new BN(this.signature.data.slice(1, lengthOfR + 1));\n        const s = new BN(this.signature.data.slice(lengthOfR + 1, lengthOfR + lengthOfS + 1));\n\n        let ellipticRecoveryBitField;\n        if (this.signature.type === KeyType.k1 || this.signature.type === KeyType.r1) {\n            ellipticRecoveryBitField = this.signature.data[0] - 27;\n            if (ellipticRecoveryBitField > 3) {\n                ellipticRecoveryBitField -= 4;\n            }\n        } else if (this.signature.type === KeyType.wa) {\n            ellipticRecoveryBitField = this.signature.data[0];\n        } else {\n            ellipticRecoveryBitField = 0\n        }\n        const recoveryParam = ellipticRecoveryBitField & 3;\n        return { r, s, recoveryParam };\n    }\n\n    /** Export Signature as EOSIO-format Signature */\n    public toString(): string {\n        return signatureToString(this.signature);\n    }\n\n    /** Export Signature in binary format */\n    public toBinary(): Uint8Array {\n        return this.signature.data;\n    }\n\n    /** Get key type from signature */\n    public getType(): KeyType {\n        return this.signature.type;\n    }\n\n    /** Verify a signature with a message or hashed message digest and public key */\n    public verify(data: BNInput, publicKey: PublicKey, shouldHash: boolean = true, encoding: BufferEncoding = 'utf8'): boolean {\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        const ellipticSignature = this.toElliptic();\n        const ellipticPublicKey = publicKey.toElliptic();\n        return this.ec.verify(data, ellipticSignature, ellipticPublicKey, encoding);\n    }\n\n    /** Recover a public key from a message or hashed message digest and signature */\n    public recover(data: BNInput, shouldHash: boolean = true, encoding: BufferEncoding = 'utf8'): PublicKey {\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        const ellipticSignature = this.toElliptic();\n        const recoveredPublicKey = this.ec.recoverPubKey(\n            data,\n            ellipticSignature,\n            ellipticSignature.recoveryParam,\n            encoding\n        );\n        const ellipticKPub = this.ec.keyFromPublic(recoveredPublicKey);\n        return PublicKey.fromElliptic(ellipticKPub, this.getType(), this.ec);\n    }\n}\n","import { BNInput, ec as EC } from 'elliptic';\nimport {\n    Key,\n    KeyType,\n    privateKeyToLegacyString,\n    privateKeyToString,\n    stringToPrivateKey,\n} from '../api/numeric';\nimport { constructElliptic } from './conversions';\nimport { PublicKey } from './publicKey'\nimport { Signature } from './signature'\n\n/** Represents/stores a private key and provides easy conversion for use with `elliptic` lib */\nexport class PrivateKey {\n    constructor(private key: Key, private ec: EC) {}\n\n    /** Instantiate private key from an `elliptic`-format private key */\n    public static fromElliptic(privKey: EC.KeyPair, keyType: KeyType, ec?: EC): PrivateKey {\n        if (!ec) {\n            ec = constructElliptic(keyType);\n        }\n        return new PrivateKey({\n            type: keyType,\n            data: privKey.getPrivate().toArrayLike(Buffer, 'be', 32),\n        }, ec);\n    }\n\n    /** Instantiate private key from an EOSIO-format private key */\n    public static fromString(keyString: string, ec?: EC): PrivateKey {\n        const privateKey = stringToPrivateKey(keyString);\n        if (!ec) {\n            ec = constructElliptic(privateKey.type);\n        }\n        return new PrivateKey(privateKey, ec);\n    }\n\n    /** Export private key as `elliptic`-format private key */\n    public toElliptic() {\n        return this.ec.keyFromPrivate(this.key.data);\n    }\n\n    public toLegacyString(): string {\n        return privateKeyToLegacyString(this.key);\n    }\n\n    /** Export private key as EOSIO-format private key */\n    public toString(): string {\n        return privateKeyToString(this.key);\n    }\n\n    /** Get key type from key */\n    public getType(): KeyType {\n        return this.key.type;\n    }\n\n    /** Retrieve the public key from a private key */\n    public getPublicKey(): PublicKey {\n        const ellipticPrivateKey = this.toElliptic();\n        return PublicKey.fromElliptic(ellipticPrivateKey, this.getType(), this.ec);\n    }\n\n    /** Sign a message or hashed message digest with private key */\n    public sign(data: BNInput, shouldHash: boolean = true, encoding: BufferEncoding = 'utf8'): Signature {\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        let tries = 0;\n        let signature: Signature;\n        const isCanonical = (sigData: Uint8Array) =>\n            !(sigData[1] & 0x80) && !(sigData[1] === 0 && !(sigData[2] & 0x80))\n            && !(sigData[33] & 0x80) && !(sigData[33] === 0 && !(sigData[34] & 0x80));\n        const constructSignature = (options: EC.SignOptions) => {\n            const ellipticPrivateKey = this.toElliptic();\n            const ellipticSignature = ellipticPrivateKey.sign(data, options);\n            return Signature.fromElliptic(ellipticSignature, this.getType(), this.ec);\n        };\n\n        if (this.key.type === KeyType.k1) {\n            do {\n                signature = constructSignature({canonical: true, pers: [++tries]});\n            } while (!isCanonical(signature.toBinary()));\n        } else {\n            signature = constructSignature({canonical: true});\n        }\n        return signature;\n    }\n\n    /** Validate a private key */\n    public isValid(): boolean {\n        try {\n            const ellipticPrivateKey = this.toElliptic();\n            const validationObj = ellipticPrivateKey.validate();\n            return validationObj.result;\n        } catch {\n            return false;\n        }\n    }\n}\n","import { PrivateKey } from './privateKey';\nimport { PublicKey } from './publicKey';\nimport { ec as EC } from 'elliptic';\nimport {KeyType} from '../api/numeric';\n\nexport { PrivateKey } from './privateKey';\nexport { PublicKey } from './publicKey';\nexport { Signature } from './signature';\nexport { constructElliptic } from './conversions';\n\nexport const generateKeyPair = (\n    type: KeyType, options: { secureEnv?: boolean, ecOptions?: EC.GenKeyPairOptions } = {}\n): { publicKey: PublicKey, privateKey: PrivateKey } => {\n    if (!options.secureEnv) {\n        throw new Error('Key generation is completely INSECURE in production environments in the browser. ' +\n            'If you are absolutely certain this does NOT describe your environment, set `secureEnv` in your ' +\n            'options to `true`.  If this does describe your environment and you set `secureEnv` to `true`, ' +\n            'YOU DO SO AT YOUR OWN RISK AND THE RISK OF YOUR USERS.');\n    }\n    let ec;\n    if (type === KeyType.k1) {\n        ec = new EC('secp256k1') as any;\n    } else {\n        ec = new EC('p256') as any;\n    }\n    const ellipticKeyPair = ec.genKeyPair(options.ecOptions);\n    const publicKey = PublicKey.fromElliptic(ellipticKeyPair, type, ec);\n    const privateKey = PrivateKey.fromElliptic(ellipticKeyPair, type, ec);\n    return {publicKey, privateKey};\n};","/**\n * @module JS-Sig\n */\n// copyright defined in eosjs/LICENSE.txt\n\nimport { ec } from 'elliptic';\n\nimport { SignatureProvider, SignatureProviderArgs } from '../api/types';\nimport {\n    PrivateKey,\n    PublicKey,\n    Signature,\n} from './key';\nimport { convertLegacyPublicKey } from '../api/numeric';\n\n/** expensive to construct; so we do it once and reuse it */\nconst defaultEc = new ec('secp256k1');\n\n/** Construct the digest from transaction details */\nconst digestFromSerializedData = (\n    chainId: string,\n    serializedTransaction: Uint8Array,\n    serializedContextFreeData?: Uint8Array,\n    e = defaultEc) => {\n    const signBuf = Buffer.concat([\n        Buffer.from(chainId, 'hex'),\n        Buffer.from(serializedTransaction),\n        Buffer.from(\n            serializedContextFreeData ?\n                new Uint8Array(e.hash().update(serializedContextFreeData).digest()) :\n                new Uint8Array(32)\n        ),\n    ]);\n    return e.hash().update(signBuf).digest();\n};\n\n/** Signs transactions using in-process private keys */\nclass JsSignatureProvider implements SignatureProvider {\n    /** map public to private keys */\n    public keys = new Map<string, ec.KeyPair>();\n\n    /** public keys */\n    public availableKeys = [] as string[];\n\n    /** @param privateKeys private keys to sign with */\n    constructor(privateKeys: string[]) {\n        for (const k of privateKeys) {\n            const priv = PrivateKey.fromString(k);\n            const privElliptic = priv.toElliptic();\n            const pubStr = priv.getPublicKey().toString();\n            this.keys.set(pubStr, privElliptic);\n            this.availableKeys.push(pubStr);\n        }\n    }\n\n    /** Public keys associated with the private keys that the `SignatureProvider` holds */\n    public async getAvailableKeys() {\n        return this.availableKeys;\n    }\n\n    /** Sign a transaction */\n    public async sign(\n        { chainId, requiredKeys, serializedTransaction, serializedContextFreeData }: SignatureProviderArgs,\n    ) {\n        const digest = digestFromSerializedData( chainId, serializedTransaction, serializedContextFreeData, defaultEc);\n\n        const signatures = [] as string[];\n        for (const key of requiredKeys) {\n            const publicKey = PublicKey.fromString(key);\n            const ellipticPrivateKey = this.keys.get(convertLegacyPublicKey(key));\n            if (ellipticPrivateKey) {\n                const privateKey = PrivateKey.fromElliptic(ellipticPrivateKey, publicKey.getType());\n                const signature = privateKey.sign(digest, false);\n                signatures.push(signature.toString());\n            }\n        }\n\n        return { signatures, serializedTransaction, serializedContextFreeData };\n    }\n}\n\nexport {\n    PrivateKey,\n    PublicKey,\n    Signature,\n    digestFromSerializedData,\n    JsSignatureProvider,\n};\n","import { Abi } from \"../rpc/types\"\n\nconst abi: Abi = {\n    \"version\": \"eosio::abi/1.0\",\n    \"types\": [\n        {\n            \"new_type_name\": \"account_name\",\n            \"type\": \"name\"\n        },\n        {\n            \"new_type_name\": \"action_name\",\n            \"type\": \"name\"\n        },\n        {\n            \"new_type_name\": \"permission_name\",\n            \"type\": \"name\"\n        }\n    ],\n    \"structs\": [\n        {\n            \"name\": \"permission_level\",\n            \"base\": \"\",\n            \"fields\": [\n                {\n                    \"name\": \"actor\",\n                    \"type\": \"account_name\"\n                },\n                {\n                    \"name\": \"permission\",\n                    \"type\": \"permission_name\"\n                }\n            ]\n        },\n        {\n            \"name\": \"action\",\n            \"base\": \"\",\n            \"fields\": [\n                {\n                    \"name\": \"account\",\n                    \"type\": \"account_name\"\n                },\n                {\n                    \"name\": \"name\",\n                    \"type\": \"action_name\"\n                },\n                {\n                    \"name\": \"authorization\",\n                    \"type\": \"permission_level[]\"\n                },\n                {\n                    \"name\": \"data\",\n                    \"type\": \"bytes\"\n                }\n            ]\n        },\n        {\n            \"name\": \"extension\",\n            \"base\": \"\",\n            \"fields\": [\n                {\n                    \"name\": \"type\",\n                    \"type\": \"uint16\"\n                },\n                {\n                    \"name\": \"data\",\n                    \"type\": \"bytes\"\n                }\n            ]\n        },\n        {\n            \"name\": \"transaction_header\",\n            \"base\": \"\",\n            \"fields\": [\n                {\n                    \"name\": \"expiration\",\n                    \"type\": \"time_point_sec\"\n                },\n                {\n                    \"name\": \"ref_block_num\",\n                    \"type\": \"uint16\"\n                },\n                {\n                    \"name\": \"ref_block_prefix\",\n                    \"type\": \"uint32\"\n                },\n                {\n                    \"name\": \"max_net_usage_words\",\n                    \"type\": \"varuint32\"\n                },\n                {\n                    \"name\": \"max_cpu_usage_ms\",\n                    \"type\": \"uint8\"\n                },\n                {\n                    \"name\": \"delay_sec\",\n                    \"type\": \"varuint32\"\n                }\n            ]\n        },\n        {\n            \"name\": \"transaction\",\n            \"base\": \"transaction_header\",\n            \"fields\": [\n                {\n                    \"name\": \"context_free_actions\",\n                    \"type\": \"action[]\"\n                },\n                {\n                    \"name\": \"actions\",\n                    \"type\": \"action[]\"\n                },\n                {\n                    \"name\": \"transaction_extensions\",\n                    \"type\": \"extension[]\"\n                }\n            ]\n        }\n    ],\n    actions: [],\n    tables: [],\n    ricardian_clauses: [],\n    error_messages: [],\n    abi_extensions: [],\n}\n\nexport default abi","/* eslint-disable max-classes-per-file */\n\nimport { inflate, deflate } from 'pako';\n\nimport {\n    AbiProvider,\n    ActionSerializerType,\n    AuthorityProvider,\n    BinaryAbi,\n    CachedAbi,\n    ContextFreeGroupCallback,\n    Query,\n    QueryConfig,\n    SignatureProvider,\n    TransactConfig,\n    Transaction,\n    TransactResult,\n} from './types';\nimport { JsonRpc } from '../rpc';\nimport {\n    Abi,\n    BlockTaposInfo,\n    GetInfoResult,\n    PushTransactionArgs,\n    GetBlockHeaderStateResult,\n    GetBlockInfoResult,\n    GetBlockResult\n} from '../rpc/types';\nimport * as ser from './serialize';\nimport { digestFromSerializedData } from '../cryptography/jsSignatureProvider'\nimport { PublicKey, Signature } from '../cryptography/key' \nimport transactionAbi from './transactionAbi'\n\nexport class Api {\n    /** Issues RPC calls */\n    public rpc: JsonRpc;\n\n    /** Get subset of `availableKeys` needed to meet authorities in a `transaction` */\n    public authorityProvider: AuthorityProvider;\n\n    /** Supplies ABIs in raw form (binary) */\n    public abiProvider: AbiProvider;\n\n    /** Signs transactions */\n    public signatureProvider?: SignatureProvider;\n\n    /** Converts abi files between binary and structured form (`abi.abi.json`) */\n    public abiTypes: Map<string, ser.Type>;\n\n    /** Converts transactions between binary and structured form (`transaction.abi.json`) */\n    public transactionTypes: Map<string, ser.Type>;\n\n    /** Holds information needed to serialize contract actions */\n    public contracts = new Map<string, ser.Contract>();\n\n    /** Fetched abis */\n    public cachedAbis = new Map<string, CachedAbi>();\n\n    /**\n     * @param args\n     *    * `rpc`: Issues RPC calls\n     *    * `authorityProvider`: Get public keys needed to meet authorities in a transaction\n     *    * `abiProvider`: Supplies ABIs in raw form (binary)\n     *    * `signatureProvider`: Signs transactions\n     */\n    constructor(args: {\n        rpc: JsonRpc,\n        authorityProvider?: AuthorityProvider,\n        abiProvider?: AbiProvider,\n        signatureProvider?: SignatureProvider\n    }) {\n        this.rpc = args.rpc;\n        this.authorityProvider = args.authorityProvider || args.rpc;\n        this.abiProvider = args.abiProvider || args.rpc;\n        if (args.signatureProvider) {\n            this.signatureProvider = args.signatureProvider;\n        }\n\n        this.abiTypes = ser.getTypesFromAbi(ser.createAbiTypes());\n        this.transactionTypes = ser.getTypesFromAbi(ser.createInitialTypes(), transactionAbi);\n    }\n\n    /** Decodes an abi as Uint8Array into json. */\n    public rawAbiToJson(rawAbi: Uint8Array): Abi {\n        const buffer = new ser.SerialBuffer({\n            array: rawAbi\n        });\n        if (!ser.supportedAbiVersion(buffer.getString())) {\n            throw new Error('Unsupported abi version');\n        }\n        buffer.restartRead();\n        return this.abiTypes.get('abi_def')!.deserialize(buffer);\n    }\n\n    /** Encodes a json abi as Uint8Array. */\n    public jsonToRawAbi(jsonAbi: Abi): Uint8Array {\n        const buffer = new ser.SerialBuffer();\n        this.abiTypes.get('abi_def')!.serialize(buffer, jsonAbi);\n        if (!ser.supportedAbiVersion(buffer.getString())) {\n            throw new Error('Unsupported abi version');\n        }\n        return buffer.asUint8Array();\n    }\n\n    /** Get abi in both binary and structured forms. Fetch when needed. */\n    public async getCachedAbi(accountName: string, reload = false): Promise<CachedAbi> {\n        if (!reload && this.cachedAbis.get(accountName)) {\n            return this.cachedAbis.get(accountName) as CachedAbi;\n        }\n        let cachedAbi: CachedAbi;\n        try {\n            const rawAbi = (await this.abiProvider.getRawAbi(accountName)).abi\n            const abi = this.rawAbiToJson(rawAbi);\n            cachedAbi = { rawAbi, abi };\n        } catch (e) {\n            e.message = `fetching abi for ${accountName}: ${e.message}`;\n            throw e;\n        }\n        if (!cachedAbi) {\n            throw new Error(`Missing abi for ${accountName}`);\n        }\n        this.cachedAbis.set(accountName, cachedAbi);\n        return cachedAbi;\n    }\n\n    /** Get abi in structured form. Fetch when needed. */\n    public async getAbi(accountName: string, reload = false): Promise<Abi> {\n        return (await this.getCachedAbi(accountName, reload)).abi;\n    }\n\n    /** Get abis needed by a transaction */\n    public async getTransactionAbis(transaction: any, reload = false): Promise<BinaryAbi[]> {\n        const actions = (transaction.context_free_actions || []).concat(transaction.actions);\n        const accounts: string[] = actions.map((action: ser.Action): string => action.account);\n        const uniqueAccounts: Set<string> = new Set(accounts);\n        const actionPromises: Promise<BinaryAbi>[] = Array.from(uniqueAccounts).map(\n            async (account: string): Promise<BinaryAbi> => {\n                const { rawAbi } = await this.getCachedAbi(account, reload)\n                return {\n                    accountName: account,\n                    abi: rawAbi\n                }\n            }\n        );\n        return Promise.all(actionPromises);\n    }\n\n    /** Get data needed to serialize actions in a contract */\n    public async getContract(accountName: string, reload = false): Promise<ser.Contract> {\n        if (!reload && this.contracts.get(accountName)) {\n            return this.contracts.get(accountName) as ser.Contract;\n        }\n        const abi = await this.getAbi(accountName, reload);\n        const types = ser.getTypesFromAbi(ser.createInitialTypes(), abi);\n        const actions = new Map<string, ser.Type>();\n        for (const { name, type } of abi.actions) {\n            actions.set(name, ser.getType(types, type));\n        }\n        const result = { types, actions };\n        this.contracts.set(accountName, result);\n        return result;\n    }\n\n    /** Convert `value` to binary form. `type` must be a built-in abi type or in `transaction.abi.json`. */\n    public serialize(buffer: ser.SerialBuffer, type: string, value: any): void {\n        this.transactionTypes.get(type)!.serialize(buffer, value);\n    }\n\n    /** Convert data in `buffer` to structured form. `type` must be a built-in abi type or in `transaction.abi.json`. */\n    public deserialize(buffer: ser.SerialBuffer, type: string): any {\n        return this.transactionTypes.get(type)!.deserialize(buffer);\n    }\n\n    /** Convert a transaction to binary */\n    public serializeTransaction(transaction: any): Uint8Array {\n        const buffer = new ser.SerialBuffer();\n        this.serialize(buffer, 'transaction', {\n            max_net_usage_words: 0,\n            max_cpu_usage_ms: 0,\n            delay_sec: 0,\n            context_free_actions: [],\n            actions: [],\n            transaction_extensions: [],\n            ...transaction,\n        });\n        return buffer.asUint8Array();\n    }\n\n    /** Serialize context-free data */\n    public serializeContextFreeData(contextFreeData: Uint8Array[]): Uint8Array | undefined {\n        if (!contextFreeData || !contextFreeData.length) {\n            return undefined;\n        }\n        const buffer = new ser.SerialBuffer();\n        buffer.pushVaruint32(contextFreeData.length);\n        for (const data of contextFreeData) {\n            buffer.pushBytes(data);\n        }\n        return buffer.asUint8Array();\n    }\n\n    /** Convert a transaction from binary. Leaves actions in hex. */\n    public deserializeTransaction(transaction: Uint8Array): any {\n        const buffer = new ser.SerialBuffer();\n        buffer.pushArray(transaction);\n        return this.deserialize(buffer, 'transaction');\n    }\n\n    /** Convert actions to hex */\n    public async serializeActions(actions: ser.Action[]): Promise<ser.SerializedAction[]> {\n        return await Promise.all(actions.map(async (action) => {\n            const { account, name, authorization, data } = action;\n            const contract = await this.getContract(account);\n            if (typeof data !== 'object') {\n                return action;\n            }\n            return ser.serializeAction(\n                contract, account, name, authorization, data);\n        }));\n    }\n\n    /** Convert actions from hex */\n    public async deserializeActions(actions: ser.Action[]): Promise<ser.Action[]> {\n        return await Promise.all(actions.map(async ({ account, name, authorization, data }) => {\n            const contract = await this.getContract(account);\n            return ser.deserializeAction(\n                contract, account, name, authorization, data);\n        }));\n    }\n\n    public async deserializeActionsSync(actions: ser.Action[]): Promise<ser.Action[]> {\n        let deserializedActions = []\n        for (const { account, name, authorization, data } of actions) {\n            const contract = await this.getContract(account);\n            deserializedActions.push(\n                ser.deserializeAction(\n                    contract, account, name, authorization, data\n                )\n            )\n        }\n        return deserializedActions\n    }\n\n    /** Convert a transaction from binary. Also deserializes actions. */\n    public async deserializeTransactionWithActions(transaction: Uint8Array | string): Promise<any> {\n        if (typeof transaction === 'string') {\n            transaction = ser.hexToUint8Array(transaction);\n        }\n        const deserializedTransaction = this.deserializeTransaction(transaction);\n        const deserializedCFActions = await this.deserializeActionsSync(deserializedTransaction.context_free_actions);\n        const deserializedActions = await this.deserializeActionsSync(deserializedTransaction.actions);\n        return {\n            ...deserializedTransaction, context_free_actions: deserializedCFActions, actions: deserializedActions\n        };\n    }\n\n    /** Deflate a serialized object */\n    public deflateSerializedArray(serializedArray: Uint8Array): Uint8Array {\n        return deflate(serializedArray, { level: 9 });\n    }\n\n    /** Inflate a compressed serialized object */\n    public inflateSerializedArray(compressedSerializedArray: Uint8Array): Uint8Array {\n        return inflate(compressedSerializedArray);\n    }\n\n    /**\n     * Create and optionally broadcast a transaction.\n     *\n     * Named Parameters:\n     *    * `broadcast`: broadcast this transaction?\n     *    * `sign`: sign this transaction?\n     *    * `compression`: compress this transaction?\n     *    * If both `blocksBehind` and `expireSeconds` are present,\n     *      then fetch the block which is `blocksBehind` behind head block,\n     *      use it as a reference for TAPoS, and expire the transaction\n     *      `expireSeconds` after that block's time.\n     *    * If both `useLastIrreversible` and `expireSeconds` are present,\n     *      then fetch the last irreversible block, use it as a reference for TAPoS,\n     *      and expire the transaction `expireSeconds` after that block's time.\n     *\n     * @returns node response if `broadcast`, `{signatures, serializedTransaction}` if `!broadcast`\n     */\n    public async transact(transaction: any, {\n        broadcast = true,\n        sign = true,\n        compression,\n        blocksBehind,\n        useLastIrreversible,\n        expireSeconds,\n        requiredKeys, // When you will sign later\n        transactionHeader\n    }: TransactConfig = {}): Promise<any> {\n        const info: GetInfoResult = await this.rpc.get_info();;\n\n        // Calculate header if not provided\n        if (!transactionHeader) {\n            if (typeof blocksBehind === 'number' && useLastIrreversible) {\n                throw new Error('Use either blocksBehind or useLastIrreversible');\n            } else if (typeof blocksBehind !== 'number' && !useLastIrreversible) {\n                throw new Error('Must provide one blocksBehind or useLastIrreversible');\n            } else if (!expireSeconds) {\n                throw new Error('Must provide expireSeconds');\n            } else {\n                transactionHeader = await this.generateTapos(info, transaction, blocksBehind, useLastIrreversible, expireSeconds);;\n            }\n\n            if (!this.hasRequiredTaposFields(transactionHeader)) {\n                throw new Error('Required configuration or TAPOS fields are not present');\n            }\n        }\n\n        const abis: BinaryAbi[] = await this.getTransactionAbis(transaction);\n        transaction = {\n            ...transactionHeader,\n            context_free_actions: await this.serializeActions(transaction.context_free_actions || []),\n            actions: await this.serializeActions(transaction.actions)\n        };\n        const serializedTransaction = this.serializeTransaction(transaction);\n        const serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);\n        let pushTransactionArgs: PushTransactionArgs = {\n            serializedTransaction, serializedContextFreeData, signatures: []\n        };\n\n        if (sign) {\n            if (!this.signatureProvider) {\n                throw new Error('No signature provider available')\n            }\n            \n            if (!requiredKeys) {\n                const availableKeys = await this.signatureProvider.getAvailableKeys();\n                requiredKeys = await this.authorityProvider.getRequiredKeys({ transaction, availableKeys });\n            }\n\n            pushTransactionArgs = await this.signatureProvider.sign({\n                chainId: info.chain_id,\n                requiredKeys,\n                serializedTransaction,\n                serializedContextFreeData,\n                abis,\n            });\n        }\n        if (broadcast) {\n            if (compression) {\n                return this.pushCompressedSignedTransaction(pushTransactionArgs) as Promise<TransactResult>;\n            }\n            return this.pushSignedTransaction(pushTransactionArgs) as Promise<TransactResult>;\n        }\n        return {\n            ...pushTransactionArgs,\n            transactionHeader //\n        };\n    }\n\n    public async transactWithDelay(transaction: any, params: TransactConfig = {}, delay: number): Promise<any> {\n        async function wait (ms: number) {\n            return new Promise(resolve => {\n              setTimeout(resolve, ms);\n            });\n        }\n\n        const success = await this.transact(transaction, params)\n        await wait(delay)\n        return success\n    }\n\n    public async query(\n        account: string, short: boolean, query: Query,\n        { sign, requiredKeys, authorization = [] }: QueryConfig\n    ): Promise<any> {\n        const info = await this.rpc.get_info();\n        const refBlock = await this.tryRefBlockFromGetInfo(info);\n        const queryBuffer = new ser.SerialBuffer();\n        ser.serializeQuery(queryBuffer, query);\n\n        const transaction = {\n            ...ser.transactionHeader(refBlock, 60 * 30),\n            context_free_actions: [] as ser.Action[],\n            actions: [{\n                account,\n                name: 'queryit',\n                authorization,\n                data: ser.arrayToHex(queryBuffer.asUint8Array()),\n            }],\n        };\n\n        const serializedTransaction = this.serializeTransaction(transaction);\n        let signatures: string[] = [];\n        if (sign) {\n            if (!this.signatureProvider) {\n                throw new Error('No signature provider available')\n            }\n    \n            const abis: BinaryAbi[] = await this.getTransactionAbis(transaction);\n            if (!requiredKeys) {\n                const availableKeys = await this.signatureProvider.getAvailableKeys();\n                requiredKeys = await this.authorityProvider.getRequiredKeys({ transaction, availableKeys });\n            }\n\n            const signResponse = await this.signatureProvider.sign({\n                chainId: info.chain_id,\n                requiredKeys,\n                serializedTransaction,\n                serializedContextFreeData: undefined,\n                abis,\n            });\n\n            signatures = signResponse.signatures;\n        }\n\n        const response = await this.rpc.send_transaction({\n            signatures,\n            compression: 0,\n            serializedTransaction\n        });\n\n        const returnBuffer = new ser.SerialBuffer({\n            array: ser.hexToUint8Array(response.processed.action_traces[0][1].return_value)\n        });\n        if (short) {\n            return ser.deserializeAnyvarShort(returnBuffer);\n        } else {\n            return ser.deserializeAnyvar(returnBuffer);\n        }\n    }\n\n    /** Broadcast a signed transaction */\n    public async pushSignedTransaction(\n        { signatures, serializedTransaction, serializedContextFreeData }: PushTransactionArgs\n    ): Promise<TransactResult> {\n        return this.rpc.push_transaction({\n            signatures,\n            serializedTransaction,\n            serializedContextFreeData\n        });\n    }\n\n    public async pushCompressedSignedTransaction(\n        { signatures, serializedTransaction, serializedContextFreeData }: PushTransactionArgs\n    ): Promise<TransactResult> {\n        const compressedSerializedTransaction = this.deflateSerializedArray(serializedTransaction);\n        const compressedSerializedContextFreeData =\n            this.deflateSerializedArray(serializedContextFreeData || new Uint8Array(0));\n\n        return this.rpc.push_transaction({\n            signatures,\n            compression: 1,\n            serializedTransaction: compressedSerializedTransaction,\n            serializedContextFreeData: compressedSerializedContextFreeData\n        });\n    }\n\n    private async generateTapos(\n        info: GetInfoResult | undefined,\n        transaction: Transaction,\n        blocksBehind: number = 3,\n        useLastIrreversible: boolean | undefined,\n        expireSeconds: number\n    ) {\n        if (!info) {\n            info = await this.rpc.get_info();\n        }\n        if (useLastIrreversible) {\n            const block = await this.tryRefBlockFromGetInfo(info);\n            return { ...ser.transactionHeader(block, expireSeconds), ...transaction };\n        }\n\n        const taposBlockNumber: number = info.head_block_num - blocksBehind;\n\n        const refBlock: GetBlockHeaderStateResult | GetBlockResult = // await this.tryGetBlockInfo(taposBlockNumber)\n            taposBlockNumber <= info.last_irreversible_block_num\n                ? await this.tryGetBlockInfo(taposBlockNumber)\n                : await this.tryGetBlockHeaderState(taposBlockNumber);\n\n        return { ...ser.transactionHeader(refBlock, expireSeconds), ...transaction };\n    }\n\n    // eventually break out into TransactionValidator class\n    private hasRequiredTaposFields({ expiration, ref_block_num, ref_block_prefix }: any): boolean {\n        return !!(expiration && typeof(ref_block_num) === 'number' && typeof(ref_block_prefix) === 'number');\n    }\n\n    private async tryGetBlockHeaderState(taposBlockNumber: number): Promise<GetBlockHeaderStateResult | GetBlockResult>\n    {\n        try {\n            return await this.rpc.get_block_header_state(taposBlockNumber);\n        } catch (error) {\n            return await this.tryGetBlockInfo(taposBlockNumber);\n        }\n    }\n\n    private async tryGetBlockInfo(blockNumber: number): Promise<GetBlockInfoResult | GetBlockResult> {\n        try {\n            return await this.rpc.get_block_info(blockNumber);\n        } catch (error) {\n            return await this.rpc.get_block(blockNumber);\n        }\n    }\n\n    private async tryRefBlockFromGetInfo(info: GetInfoResult): Promise<BlockTaposInfo | GetBlockInfoResult | GetBlockResult> {\n        if (\n            info.hasOwnProperty('last_irreversible_block_id') &&\n            info.hasOwnProperty('last_irreversible_block_num') &&\n            info.hasOwnProperty('last_irreversible_block_time')\n        ) {\n            return {\n                block_num: info.last_irreversible_block_num,\n                id: info.last_irreversible_block_id,\n                timestamp: info.last_irreversible_block_time,\n            };\n        } else {\n            const block = await this.tryGetBlockInfo(info.last_irreversible_block_num);\n            return {\n                block_num: block.block_num,\n                id: block.id,\n                timestamp: block.timestamp,\n            };\n        }\n    }\n\n    public with(accountName: string): ActionBuilder {\n        return new ActionBuilder(this, accountName);\n    }\n\n    public buildTransaction(cb?: (tx: TransactionBuilder) => void) {\n        const tx = new TransactionBuilder(this);\n        if (cb) {\n            return cb(tx);\n        }\n        return tx as TransactionBuilder;\n    }\n\n    public async getAccountKeys (actor: string, permission: string) {\n        try {\n            const { permissions } = await this.rpc.get_account(actor)\n            const relevantPermission = permissions.find(({ perm_name }: any) => perm_name === permission)\n            if (relevantPermission) {\n                return relevantPermission.required_auth.keys.map(({ key }: any) => PublicKey.fromString(key).toString())\n            }\n        } catch (e) {\n            console.log(e)\n        }\n\n        return []\n    }\n\n    public async checkIfKeysMatchTransaction ({\n        actor,\n        permission,\n        transaction,\n        signatures,\n        chainId\n    }: {\n        actor: string,\n        permission: string,\n        transaction: any,\n        signatures: string[],\n        chainId?: string\n    }) {\n        if (!chainId) {\n            const info = await this.rpc.get_info()\n            chainId = info.chain_id\n        }\n        \n        const keys = await this.getAccountKeys(actor, permission)\n        transaction.context_free_actions = await this.serializeActions(transaction.context_free_actions || []),\n        transaction.actions = await this.serializeActions(transaction.actions)\n\n        const serializedTransaction = this.serializeTransaction(transaction);\n        const serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);\n\n        const digest = digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData)\n        const verified = keys.some((key: string) => {\n            return Signature.fromString(signatures[0]).verify(digest, PublicKey.fromString(key), false)\n        })\n        return verified\n    }\n} // Api\n\nexport class TransactionBuilder {\n    private api: Api;\n    private actions: ActionBuilder[] = [];\n    private contextFreeGroups: any[] = [];\n    constructor(api: Api) {\n        this.api = api;\n    }\n\n    public with(accountName: string): ActionBuilder {\n        const actionBuilder = new ActionBuilder(this.api, accountName);\n        this.actions.push(actionBuilder);\n        return actionBuilder;\n    }\n\n    public associateContextFree(contextFreeGroup: ContextFreeGroupCallback) {\n        this.contextFreeGroups.push(contextFreeGroup);\n        return this;\n    }\n\n    public async send(config?: TransactConfig): Promise<PushTransactionArgs|TransactResult> {\n        const contextFreeDataSet: Uint8Array[] = [];\n        const contextFreeActions: ser.SerializedAction[] = [];\n        const actions: ser.SerializedAction[] = this.actions.map((actionBuilder) => actionBuilder.serializedData as ser.SerializedAction);\n        await Promise.all(this.contextFreeGroups.map(\n            async (contextFreeCallback: ContextFreeGroupCallback) => {\n                const { action, contextFreeAction, contextFreeData } = contextFreeCallback({\n                    cfd: contextFreeDataSet.length,\n                    cfa: contextFreeActions.length\n                });\n                if (action) {\n                    actions.push(action);\n                }\n                if (contextFreeAction) {\n                    contextFreeActions.push(contextFreeAction);\n                }\n                if (contextFreeData) {\n                    contextFreeDataSet.push(contextFreeData);\n                }\n            }\n        ));\n        this.contextFreeGroups = [];\n        this.actions = [];\n        return await this.api.transact({\n            context_free_data: contextFreeDataSet,\n            context_free_actions: contextFreeActions,\n            actions\n        }, config);\n    }\n}\n\nexport class ActionBuilder {\n    private api: Api;\n    private readonly accountName: string;\n    public serializedData: ser.SerializedAction | undefined;\n\n    constructor(api: Api, accountName: string) {\n        this.api = api;\n        this.accountName = accountName;\n    }\n\n    public as(actorName: string | ser.Authorization[] = []) {\n        let authorization: ser.Authorization[] = [];\n        if (actorName && typeof actorName === 'string') {\n            authorization = [{ actor: actorName, permission: 'active'}];\n        } else {\n            authorization = actorName as ser.Authorization[];\n        }\n\n        return new ActionSerializer(this, this.api, this.accountName, authorization) as ActionSerializerType;\n    }\n}\n\nclass ActionSerializer implements ActionSerializerType {\n    constructor(\n        parent: ActionBuilder,\n        api: Api,\n        accountName: string,\n        authorization: ser.Authorization[],\n    ) {\n        const jsonAbi = api.cachedAbis.get(accountName);\n        if (!jsonAbi) {\n            throw new Error('ABI must be cached before using ActionBuilder, run api.getAbi()');\n        }\n        const types = ser.getTypesFromAbi(ser.createInitialTypes(), jsonAbi.abi);\n        const actions = new Map<string, ser.Type>();\n        for (const { name, type } of jsonAbi.abi.actions) {\n            actions.set(name, ser.getType(types, type));\n        }\n        actions.forEach((type, name) => {\n            Object.assign(this, {\n                [name]: (...args: any[]) => {\n                    const data: { [key: string]: any } = {};\n                    args.forEach((arg, index) => {\n                        const field = type.fields[index];\n                        data[field.name] = arg;\n                    });\n                    const serializedData = ser.serializeAction(\n                        { types, actions },\n                        accountName,\n                        name,\n                        authorization,\n                        data\n                    );\n                    parent.serializedData = serializedData;\n                    return serializedData;\n                }\n            });\n        });\n    }\n}\n","import { JsonRpc } from './index'\nimport { AuthorityProviderArgs } from '../api/types';\nimport { convertLegacyPublicKeys } from '../api/numeric';\nimport {\n    GetBlockInfoResult,\n    GetBlockResult,\n    GetInfoResult,\n    GetBlockHeaderStateResult,\n    GetActivatedProtocolFeaturesResult\n} from './types';\n\n/** Raw call to `/v1/chain/get_account` */\nexport async function get_account(this: JsonRpc, accountName: string): Promise<any> {\n    return await this.post('/v1/chain/get_account', { account_name: accountName });\n}\n\n/** Raw call to `/v1/chain/get_block_header_state` */\nexport async function get_block_header_state(this: JsonRpc, blockNumOrId: number | string): Promise<GetBlockHeaderStateResult> {\n    return await this.post('/v1/chain/get_block_header_state', { block_num_or_id: blockNumOrId });\n}\n\nexport async function get_block_info(this: JsonRpc, blockNum: number): Promise<GetBlockInfoResult> {\n    return await this.post('/v1/chain/get_block_info', { block_num: blockNum });\n}\n\n/** Raw call to `/v1/chain/get_block` */\nexport async function get_block(this: JsonRpc, blockNumOrId: number | string): Promise<GetBlockResult> {\n    return await this.post('/v1/chain/get_block', { block_num_or_id: blockNumOrId });\n}\n\n/** Raw call to `/v1/chain/get_currency_balance` */\nexport async function get_currency_balance(this: JsonRpc, code: string, account: string, symbol: string | null = null): Promise<any> {\n    return await this.post('/v1/chain/get_currency_balance', { code, account, symbol });\n}\n\n/** Raw call to `/v1/chain/get_currency_stats` */\nexport async function get_currency_stats(this: JsonRpc, code: string, symbol: string): Promise<any> {\n    return await this.post('/v1/chain/get_currency_stats', { code, symbol });\n}\n\n/** Raw call to `/v1/chain/get_info` */\nexport async function get_info(this: JsonRpc): Promise<GetInfoResult> {\n    return await this.post('/v1/chain/get_info', {});\n}\n\n/** Raw call to `/v1/chain/get_producer_schedule` */\nexport async function get_producer_schedule(this: JsonRpc): Promise<any> {\n    return await this.post('/v1/chain/get_producer_schedule', {});\n}\n\n/** Raw call to `/v1/chain/get_producers` */\nexport async function get_producers(this: JsonRpc, json = true, lowerBound = '', limit = 50): Promise<any> {\n    return await this.post('/v1/chain/get_producers', { json, lower_bound: lowerBound, limit });\n}\n\n/** Raw call to `/v1/chain/get_scheduled_transactions` */\nexport async function get_scheduled_transactions(this: JsonRpc, json = true, lowerBound = '', limit = 50): Promise<any> {\n    return await this.post('/v1/chain/get_scheduled_transactions', { json, lower_bound: lowerBound, limit });\n}\n\n/** Raw call to `/v1/chain/get_activated_protocol_features` */\nexport async function get_activated_protocol_features(this: JsonRpc, limit = 100): Promise<GetActivatedProtocolFeaturesResult> {\n    return await this.post('/v1/chain/get_activated_protocol_features', { limit });\n}\n\n/** Get subset of `availableKeys` needed to meet authorities in `transaction`. Implements `AuthorityProvider` */\nexport async function getRequiredKeys(this: JsonRpc, args: AuthorityProviderArgs): Promise<string[]> {\n    const requiredKeys = await this.post('/v1/chain/get_required_keys', {\n        transaction: args.transaction,\n        available_keys: args.availableKeys,\n    })\n    return convertLegacyPublicKeys(requiredKeys.required_keys);\n}","import { JsonRpc } from './index'\n\n/** Raw call to `/v1/history/get_actions` */\nexport async function history_get_actions(this: JsonRpc, accountName: string, pos: number | null = null, offset: number | null = null) {\n    return await this.post('/v1/history/get_actions', { account_name: accountName, pos, offset });\n}\n\n/** Raw call to `/v1/history/get_transaction` */\nexport async function history_get_transaction(this: JsonRpc, id: string, blockNumHint: number | null = null) {\n    return await this.post('/v1/history/get_transaction', { id, block_num_hint: blockNumHint });\n}\n\n/** Raw call to `/v1/history/get_key_accounts` */\nexport async function history_get_key_accounts(this: JsonRpc, publicKey: string) {\n    return await this.post('/v1/history/get_key_accounts', { public_key: publicKey });\n}\n\n/** Raw call to `/v1/history/get_controlled_accounts` */\nexport async function history_get_controlled_accounts(this: JsonRpc, controllingAccount: string) {\n    return await this.post('/v1/history/get_controlled_accounts', { controlling_account: controllingAccount });\n}","import { JsonRpc } from './index'\n\n/** Raw call to `/v1/db_size/get` */\nexport async function db_size_get(this: JsonRpc) {\n    return await this.post('/v1/db_size/get', {});\n}","import * as z from 'zod'\nimport { constants } from '@bloks/constants'\n\nexport enum Status {\n    PENDING = 'pending',\n    SUCCESS = 'success',\n    FAIL = 'fail',\n    PROCESSING = 'processing'\n}\n\nexport const accountParser = z.string().regex(/^[.1-5a-z]{0,12}[.1-5a-j]?$/)\n\nexport const authorizationParser = z.object({\n    actor: accountParser,\n    permission: z.string()\n})\nexport type Authorization = z.infer<typeof authorizationParser>\n\nexport const rawTransactionParser = z.object({\n    expiration: z.string(),\n    ref_block_num: z.number(),\n    ref_block_prefix: z.number(),\n    max_net_usage_words: z.number(),\n    max_cpu_usage_ms: z.number(),\n    delay_sec: z.number(),\n    context_free_actions: z.array(z.any()),\n    transaction_extensions: z.array(z.any())\n})\n\nexport const generateAuthParser = z.object({\n    signer: authorizationParser,\n    signatures: z.array(z.string()),\n    transaction: rawTransactionParser.merge(z.object({\n        actions: z.array(z.object({\n            account: accountParser,\n            name: z.string(),\n            data: z.object({\n              time: z.string(),\n              protonAccount: z.string()\n            }),\n            authorization: z.array(authorizationParser).min(1)\n        }))\n    }))\n})\nexport type GenerateAuth = z.infer<typeof generateAuthParser>\n\nexport const generateAddressBodyParser = z.object({\n    coin: z.string(),\n    wallet: z.string(),\n}).merge(generateAuthParser)\nexport type GenerateAddressBody = z.infer<typeof generateAddressBodyParser>\n\nexport const generateAddressResponse = z.object({\n    id:      z.string(), // \"2448834505708930950\",\n    address: z.string(), // \"0x617C03C1E2Bf81C062A4CEfbE312c070E1d86d18\",\n    coin:    z.string(), // \"ETH\",\n    wallet:  z.string(), // \"ETH\",\n    memo:    z.string().optional()\n})\nexport type GenerateAddressResponse = z.infer<typeof generateAddressResponse>\n\nexport const depositBodyParser = z.object({\n    id:     z.string(), // \"0x000010203121388fac991\"\n    externalId: z.string().optional(), // \"2510473254188091220\"\n    type:   z.string(), // \"transfer\"\n    hash:   z.string(), // \"0x000010203121388fac991\"\n    coin:   z.string(), // \"ETH\" or \"XPR\"\n    wallet: z.string(), // \"ETH-ROPSTEN\" or \"XPR-MAINNET\"\n})\nexport type DepositBody = z.infer<typeof depositBodyParser>\n\nexport const withdrawBodyParser = z.object({\n    signer: authorizationParser,\n    signatures: z.array(z.string()).min(1),\n    transaction: rawTransactionParser.merge(z.object({\n        actions: z.array(z.object({\n            account: accountParser,\n            name: z.literal('transfer'),\n            data: z.object({\n                from: z.string().refine((val) => val !== constants.WRAP_CONTRACT, {\n                    message: `${constants.WRAP_CONTRACT} must be receiver`,\n                }),\n                to: z.literal(constants.WRAP_CONTRACT),\n                quantity: z.string(),\n                memo: z.string()\n            }),\n            authorization: z.array(authorizationParser).min(1)\n        })).min(1)\n    })),\n    quoteId: z.string()\n})\nexport type WithdrawBody = z.infer<typeof withdrawBodyParser>\n\nexport const withdrawMetalResponseParser = z.object({\n    success: z.boolean(),\n    id: z.string(),\n})\nexport type WithdrawMetalResponse = z.infer<typeof withdrawMetalResponseParser>\n\nexport const withdrawHistoryMetalSwapParser = z.object({\n    id: z.string(),\n    status: z.string(),\n    amount: z.string(),\n    currency: z.string(),\n    network: z.string(),\n    created: z.string(),\n    withdrawalAddress: z.string(),\n    withdrawalHash: z.string().optional()\n})\nexport type WithdrawHistoryMetalSwap = z.infer<typeof withdrawHistoryMetalSwapParser>\n\nexport const withdrawHistoryMetalResponseParser = z.object({\n    swaps: z.array(withdrawHistoryMetalSwapParser),\n    page: z.number(),\n    pageSize: z.number(),\n    numberOfElements: z.number(),\n    totalPages: z.number(),\n    totalElements: z.number()\n})\nexport type WithdrawHistoryMetalResponse = z.infer<typeof withdrawHistoryMetalResponseParser>\n\nconst ExtendedAssetParser = z.object({\n    quantity: z.string(),\n    contract: accountParser\n})\nexport type ExtendedAsset = z.infer<typeof ExtendedAssetParser>\n\nexport const wrapStartParser = z.object({\n    balance:         ExtendedAssetParser,\n    txid:            z.string(),\n    coin:            z.string(),\n    wallet:          z.string(),\n    deposit_address: z.string(),\n    confirmations:   z.number()\n})\nexport type WrapStart = z.infer<typeof wrapStartParser>\n\nexport const wrapSetConfParser = z.object({\n    wrap_hash:       z.string(),\n    confirmations:   z.number()\n})\nexport type WrapSetConf = z.infer<typeof wrapSetConfParser>\n\nexport const wrapParser = z.object({\n    index:           z.number(),\n    proton_account:  z.string(),\n    balance:         ExtendedAssetParser,\n    txid:            z.string(),\n    coin:            z.string(),\n    wallet:          z.string(),\n    deposit_address: z.string(),\n    status:          z.nativeEnum(Status),\n    finish_txid:     z.string(),\n    wrap_hash:       z.string(),\n    confirmations:   z.number(),\n})\nexport type Wrap = z.infer<typeof wrapParser>\n\nexport const transactionParser = z.object({\n    coin:          z.string(), // \"BTC\"\n    wallet:        z.string(), // \"BTC\"\n    blockhash:     z.string().optional().nullable(), // \"000000000000000000089b270eb99f75107d6a9cde37ec944cb80a2998df7b43\"\n    txid:          z.string(), // \"b4781422be95fee8fbbf720e3e0fa9705ae834474ef25f5724cdd0f5d23211ed\"\n    type:          z.string(), // \"receive\" or \"send\"\n    height:        z.number().optional().nullable(), // 643159\n    confirmations: z.number(), // 18369\n    state:         z.string(), // \"confirmed\"\n    entries: z.array(z.object({\n        address:     z.string(), // \"1CgGHR9bUakXhLz1eBapvP4PDDtta5pHx1\"\n        wallet:      z.string(), // \"BTC\"\n        value:       z.number(), // 84456\n        valueString: z.string(), // \"84456\"\n        isChange:    z.boolean(), // false\n    })),\n    outputs: z.array(z.object({\n        address:     z.string(), // \"1CgGHR9bUakXhLz1eBapvP4PDDtta5pHx1\"\n        wallet:      z.string(), // \"BTC\"\n        fromWallet:  z.string(), // \"BTC\"\n        value:       z.number(), // 84456\n        valueString: z.string(), // \"84456\"\n        coinbase:    z.boolean(), // false\n    })),\n    value:       z.number(), // 84456\n    valueString: z.string(), // \"84456\"\n    pending:     z.boolean(), // false\n    instant:     z.boolean(), // false\n})\nexport type Transaction = z.infer<typeof transactionParser>\n\nexport const addressParser = z.object({\n    index:        z.number(),\n    account:      accountParser,\n    coin:         z.string(),\n    address:      z.string(),\n    wallet:       z.string(),\n    address_hash: z.string(),\n})\nexport type Address = z.infer<typeof addressParser>\n\nexport const otcOrderResponseParser = z.object({\n    success: z.boolean(),\n    transaction_id: z.string(),\n    errormsg: z.string().optional()\n})\nexport type OtcOrderResponse = z.infer<typeof otcOrderResponseParser>\n\nexport const otcQuoteBodyParser = z.object({\n    baseAmount: z.number(),\n    baseSymbol: z.string(),\n    quoteSymbol: z.string()\n})\nexport type OtcQuoteBody = z.infer<typeof otcQuoteBodyParser>\n\nexport const otcQuoteResponseParser = z.object({\n    success: z.boolean(),\n    token: z.string(),\n    qty: z.number(),\n    errormsg: z.string().optional()\n})\nexport type OtcQuoteResponse = z.infer<typeof otcQuoteResponseParser>\n\nexport const rateParser = z.object({\n    counterCurrency: z.string(),\n    price: z.number(),\n    priceChangePercent: z.number(),\n    marketCap: z.number(),\n    volume: z.number(),\n    timestamp: z.number()\n})\nexport type Rate = z.infer<typeof rateParser>\n\nexport const exchangeRateParser = z.object({\n    contract: z.string(),\n    symbol: z.string(),\n    rank: z.number(),\n    rates: z.array(rateParser)\n})\nexport type ExchangeRate = z.infer<typeof exchangeRateParser>\n\nexport const exchangeRatesParser = z.array(exchangeRateParser)\nexport type ExchangeRates = z.infer<typeof exchangeRatesParser>\n\nexport const withdrawalFeeQuoteParser = z.object({\n    quoteId: z.string(),\n    estimatedFee: z.string(),\n    currency: z.string(),\n    network: z.string(),\n})\nexport type WithdrawalFeeQuote = z.infer<typeof withdrawalFeeQuoteParser>","export default [\n  { key: 'AF', value: 'AF', flag: 'af', text: 'Afghanistan' },\n  { key: 'AX', value: 'AX', flag: 'ax', text: 'Aland Islands' },\n  { key: 'AL', value: 'AL', flag: 'al', text: 'Albania' },\n  { key: 'DZ', value: 'DZ', flag: 'dz', text: 'Algeria' },\n  { key: 'AS', value: 'AS', flag: 'as', text: 'American Samoa' },\n  { key: 'AD', value: 'AD', flag: 'ad', text: 'Andorra' },\n  { key: 'AO', value: 'AO', flag: 'ao', text: 'Angola' },\n  { key: 'AI', value: 'AI', flag: 'ai', text: 'Anguilla' },\n  { key: 'AG', value: 'AG', flag: 'ag', text: 'Antigua' },\n  { key: 'AR', value: 'AR', flag: 'ar', text: 'Argentina' },\n  { key: 'AM', value: 'AM', flag: 'am', text: 'Armenia' },\n  { key: 'AW', value: 'AW', flag: 'aw', text: 'Aruba' },\n  { key: 'AU', value: 'AU', flag: 'au', text: 'Australia' },\n  { key: 'AT', value: 'AT', flag: 'at', text: 'Austria' },\n  { key: 'AZ', value: 'AZ', flag: 'az', text: 'Azerbaijan' },\n  { key: 'BS', value: 'BS', flag: 'bs', text: 'Bahamas' },\n  { key: 'BH', value: 'BH', flag: 'bh', text: 'Bahrain' },\n  { key: 'BD', value: 'BD', flag: 'bd', text: 'Bangladesh' },\n  { key: 'BB', value: 'BB', flag: 'bb', text: 'Barbados' },\n  { key: 'BY', value: 'BY', flag: 'by', text: 'Belarus' },\n  { key: 'BE', value: 'BE', flag: 'be', text: 'Belgium' },\n  { key: 'BZ', value: 'BZ', flag: 'bz', text: 'Belize' },\n  { key: 'BJ', value: 'BJ', flag: 'bj', text: 'Benin' },\n  { key: 'BM', value: 'BM', flag: 'bm', text: 'Bermuda' },\n  { key: 'BT', value: 'BT', flag: 'bt', text: 'Bhutan' },\n  { key: 'BO', value: 'BO', flag: 'bo', text: 'Bolivia' },\n  { key: 'BA', value: 'BA', flag: 'ba', text: 'Bosnia' },\n  { key: 'BW', value: 'BW', flag: 'bw', text: 'Botswana' },\n  { key: 'BV', value: 'BV', flag: 'bv', text: 'Bouvet Island' },\n  { key: 'BR', value: 'BR', flag: 'br', text: 'Brazil' },\n  { key: 'VG', value: 'VG', flag: 'vg', text: 'British Virgin Islands' },\n  { key: 'BN', value: 'BN', flag: 'bn', text: 'Brunei' },\n  { key: 'BG', value: 'BG', flag: 'bg', text: 'Bulgaria' },\n  { key: 'BF', value: 'BF', flag: 'bf', text: 'Burkina Faso' },\n  { key: 'BI', value: 'BI', flag: 'bi', text: 'Burundi' },\n  { key: 'TC', value: 'TC', flag: 'tc', text: 'Caicos Islands' },\n  { key: 'KH', value: 'KH', flag: 'kh', text: 'Cambodia' },\n  { key: 'CM', value: 'CM', flag: 'cm', text: 'Cameroon' },\n  { key: 'CA', value: 'CA', flag: 'ca', text: 'Canada' },\n  { key: 'CV', value: 'CV', flag: 'cv', text: 'Cape Verde' },\n  { key: 'KY', value: 'KY', flag: 'ky', text: 'Cayman Islands' },\n  { key: 'CF', value: 'CF', flag: 'cf', text: 'Central African Republic' },\n  { key: 'TD', value: 'TD', flag: 'td', text: 'Chad' },\n  { key: 'CL', value: 'CL', flag: 'cl', text: 'Chile' },\n  { key: 'CN', value: 'CN', flag: 'cn', text: 'China' },\n  { key: 'CX', value: 'CX', flag: 'cx', text: 'Christmas Island' },\n  { key: 'CC', value: 'CC', flag: 'cc', text: 'Cocos Islands' },\n  { key: 'CO', value: 'CO', flag: 'co', text: 'Colombia' },\n  { key: 'KM', value: 'KM', flag: 'km', text: 'Comoros' },\n  { key: 'CG', value: 'CG', flag: 'cg', text: 'Congo Brazzaville' },\n  { key: 'CD', value: 'CD', flag: 'cd', text: 'Congo' },\n  { key: 'CK', value: 'CK', flag: 'ck', text: 'Cook Islands' },\n  { key: 'CR', value: 'CR', flag: 'cr', text: 'Costa Rica' },\n  { key: 'CI', value: 'CI', flag: 'ci', text: 'Cote Divoire' },\n  { key: 'HR', value: 'HR', flag: 'hr', text: 'Croatia' },\n  { key: 'CU', value: 'CU', flag: 'cu', text: 'Cuba' },\n  { key: 'CY', value: 'CY', flag: 'cy', text: 'Cyprus' },\n  { key: 'CZ', value: 'CZ', flag: 'cz', text: 'Czech Republic' },\n  { key: 'DK', value: 'DK', flag: 'dk', text: 'Denmark' },\n  { key: 'DJ', value: 'DJ', flag: 'dj', text: 'Djibouti' },\n  { key: 'DM', value: 'DM', flag: 'dm', text: 'Dominica' },\n  { key: 'DO', value: 'DO', flag: 'do', text: 'Dominican Republic' },\n  { key: 'EC', value: 'EC', flag: 'ec', text: 'Ecuador' },\n  { key: 'EG', value: 'EG', flag: 'eg', text: 'Egypt' },\n  { key: 'SV', value: 'SV', flag: 'sv', text: 'El Salvador' },\n  { key: 'GB', value: 'GB', flag: 'gb', text: 'England' },\n  { key: 'GQ', value: 'GQ', flag: 'gq', text: 'Equatorial Guinea' },\n  { key: 'ER', value: 'ER', flag: 'er', text: 'Eritrea' },\n  { key: 'EE', value: 'EE', flag: 'ee', text: 'Estonia' },\n  { key: 'ET', value: 'ET', flag: 'et', text: 'Ethiopia' },\n  { key: 'EU', value: 'EU', flag: 'eu', text: 'European Union' },\n  { key: 'FK', value: 'FK', flag: 'fk', text: 'Falkland Islands' },\n  { key: 'FO', value: 'FO', flag: 'fo', text: 'Faroe Islands' },\n  { key: 'FJ', value: 'FJ', flag: 'fj', text: 'Fiji' },\n  { key: 'FI', value: 'FI', flag: 'fi', text: 'Finland' },\n  { key: 'FR', value: 'FR', flag: 'fr', text: 'France' },\n  { key: 'GF', value: 'GF', flag: 'gf', text: 'French Guiana' },\n  { key: 'PF', value: 'PF', flag: 'pf', text: 'French Polynesia' },\n  { key: 'TF', value: 'TF', flag: 'tf', text: 'French Territories' },\n  { key: 'GA', value: 'GA', flag: 'ga', text: 'Gabon' },\n  { key: 'GM', value: 'GM', flag: 'gm', text: 'Gambia' },\n  { key: 'GE', value: 'GE', flag: 'ge', text: 'Georgia' },\n  { key: 'DE', value: 'DE', flag: 'de', text: 'Germany' },\n  { key: 'GH', value: 'GH', flag: 'gh', text: 'Ghana' },\n  { key: 'GI', value: 'GI', flag: 'gi', text: 'Gibraltar' },\n  { key: 'GR', value: 'GR', flag: 'gr', text: 'Greece' },\n  { key: 'GL', value: 'GL', flag: 'gl', text: 'Greenland' },\n  { key: 'GD', value: 'GD', flag: 'gd', text: 'Grenada' },\n  { key: 'GP', value: 'GP', flag: 'gp', text: 'Guadeloupe' },\n  { key: 'GU', value: 'GU', flag: 'gu', text: 'Guam' },\n  { key: 'GT', value: 'GT', flag: 'gt', text: 'Guatemala' },\n  { key: 'GW', value: 'GW', flag: 'gw', text: 'Guinea-Bissau' },\n  { key: 'GN', value: 'GN', flag: 'gn', text: 'Guinea' },\n  { key: 'GY', value: 'GY', flag: 'gy', text: 'Guyana' },\n  { key: 'HT', value: 'HT', flag: 'ht', text: 'Haiti' },\n  { key: 'HM', value: 'HM', flag: 'hm', text: 'Heard Island' },\n  { key: 'HN', value: 'HN', flag: 'hn', text: 'Honduras' },\n  { key: 'HK', value: 'HK', flag: 'hk', text: 'Hong Kong' },\n  { key: 'HU', value: 'HU', flag: 'hu', text: 'Hungary' },\n  { key: 'IS', value: 'IS', flag: 'is', text: 'Iceland' },\n  { key: 'IN', value: 'IN', flag: 'in', text: 'India' },\n  { key: 'IO', value: 'IO', flag: 'io', text: 'Indian Ocean Territory' },\n  { key: 'ID', value: 'ID', flag: 'id', text: 'Indonesia' },\n  { key: 'IR', value: 'IR', flag: 'ir', text: 'Iran' },\n  { key: 'IQ', value: 'IQ', flag: 'iq', text: 'Iraq' },\n  { key: 'IE', value: 'IE', flag: 'ie', text: 'Ireland' },\n  { key: 'IL', value: 'IL', flag: 'il', text: 'Israel' },\n  { key: 'IT', value: 'IT', flag: 'it', text: 'Italy' },\n  { key: 'JM', value: 'JM', flag: 'jm', text: 'Jamaica' },\n  { key: 'JP', value: 'JP', flag: 'jp', text: 'Japan' },\n  { key: 'JO', value: 'JO', flag: 'jo', text: 'Jordan' },\n  { key: 'KZ', value: 'KZ', flag: 'kz', text: 'Kazakhstan' },\n  { key: 'KE', value: 'KE', flag: 'ke', text: 'Kenya' },\n  { key: 'KI', value: 'KI', flag: 'ki', text: 'Kiribati' },\n  { key: 'KW', value: 'KW', flag: 'kw', text: 'Kuwait' },\n  { key: 'KG', value: 'KG', flag: 'kg', text: 'Kyrgyzstan' },\n  { key: 'LA', value: 'LA', flag: 'la', text: 'Laos' },\n  { key: 'LV', value: 'LV', flag: 'lv', text: 'Latvia' },\n  { key: 'LB', value: 'LB', flag: 'lb', text: 'Lebanon' },\n  { key: 'LS', value: 'LS', flag: 'ls', text: 'Lesotho' },\n  { key: 'LR', value: 'LR', flag: 'lr', text: 'Liberia' },\n  { key: 'LY', value: 'LY', flag: 'ly', text: 'Libya' },\n  { key: 'LI', value: 'LI', flag: 'li', text: 'Liechtenstein' },\n  { key: 'LT', value: 'LT', flag: 'lt', text: 'Lithuania' },\n  { key: 'LU', value: 'LU', flag: 'lu', text: 'Luxembourg' },\n  { key: 'MO', value: 'MO', flag: 'mo', text: 'Macau' },\n  { key: 'MK', value: 'MK', flag: 'mk', text: 'Macedonia' },\n  { key: 'MG', value: 'MG', flag: 'mg', text: 'Madagascar' },\n  { key: 'MW', value: 'MW', flag: 'mw', text: 'Malawi' },\n  { key: 'MY', value: 'MY', flag: 'my', text: 'Malaysia' },\n  { key: 'MV', value: 'MV', flag: 'mv', text: 'Maldives' },\n  { key: 'ML', value: 'ML', flag: 'ml', text: 'Mali' },\n  { key: 'MT', value: 'MT', flag: 'mt', text: 'Malta' },\n  { key: 'MH', value: 'MH', flag: 'mh', text: 'Marshall Islands' },\n  { key: 'MQ', value: 'MQ', flag: 'mq', text: 'Martinique' },\n  { key: 'MR', value: 'MR', flag: 'mr', text: 'Mauritania' },\n  { key: 'MU', value: 'MU', flag: 'mu', text: 'Mauritius' },\n  { key: 'YT', value: 'YT', flag: 'yt', text: 'Mayotte' },\n  { key: 'MX', value: 'MX', flag: 'mx', text: 'Mexico' },\n  { key: 'FM', value: 'FM', flag: 'fm', text: 'Micronesia' },\n  { key: 'MD', value: 'MD', flag: 'md', text: 'Moldova' },\n  { key: 'MC', value: 'MC', flag: 'mc', text: 'Monaco' },\n  { key: 'MN', value: 'MN', flag: 'mn', text: 'Mongolia' },\n  { key: 'ME', value: 'ME', flag: 'me', text: 'Montenegro' },\n  { key: 'MS', value: 'MS', flag: 'ms', text: 'Montserrat' },\n  { key: 'MA', value: 'MA', flag: 'ma', text: 'Morocco' },\n  { key: 'MZ', value: 'MZ', flag: 'mz', text: 'Mozambique' },\n  { key: 'NA', value: 'NA', flag: 'na', text: 'Namibia' },\n  { key: 'NR', value: 'NR', flag: 'nr', text: 'Nauru' },\n  { key: 'NP', value: 'NP', flag: 'np', text: 'Nepal' },\n  { key: 'AN', value: 'AN', flag: 'an', text: 'Netherlands Antilles' },\n  { key: 'NL', value: 'NL', flag: 'nl', text: 'Netherlands' },\n  { key: 'NC', value: 'NC', flag: 'nc', text: 'New Caledonia' },\n  { key: 'PG', value: 'PG', flag: 'pg', text: 'New Guinea' },\n  { key: 'NZ', value: 'NZ', flag: 'nz', text: 'New Zealand' },\n  { key: 'NI', value: 'NI', flag: 'ni', text: 'Nicaragua' },\n  { key: 'NE', value: 'NE', flag: 'ne', text: 'Niger' },\n  { key: 'NG', value: 'NG', flag: 'ng', text: 'Nigeria' },\n  { key: 'NU', value: 'NU', flag: 'nu', text: 'Niue' },\n  { key: 'NF', value: 'NF', flag: 'nf', text: 'Norfolk Island' },\n  { key: 'KP', value: 'KP', flag: 'kp', text: 'North Korea' },\n  { key: 'MP', value: 'MP', flag: 'mp', text: 'Northern Mariana Islands' },\n  { key: 'NO', value: 'NO', flag: 'no', text: 'Norway' },\n  { key: 'OM', value: 'OM', flag: 'om', text: 'Oman' },\n  { key: 'PK', value: 'PK', flag: 'pk', text: 'Pakistan' },\n  { key: 'PW', value: 'PW', flag: 'pw', text: 'Palau' },\n  { key: 'PS', value: 'PS', flag: 'ps', text: 'Palestine' },\n  { key: 'PA', value: 'PA', flag: 'pa', text: 'Panama' },\n  { key: 'PY', value: 'PY', flag: 'py', text: 'Paraguay' },\n  { key: 'PE', value: 'PE', flag: 'pe', text: 'Peru' },\n  { key: 'PH', value: 'PH', flag: 'ph', text: 'Philippines' },\n  { key: 'PN', value: 'PN', flag: 'pn', text: 'Pitcairn Islands' },\n  { key: 'PL', value: 'PL', flag: 'pl', text: 'Poland' },\n  { key: 'PT', value: 'PT', flag: 'pt', text: 'Portugal' },\n  { key: 'PR', value: 'PR', flag: 'pr', text: 'Puerto Rico' },\n  { key: 'QA', value: 'QA', flag: 'qa', text: 'Qatar' },\n  { key: 'RE', value: 'RE', flag: 're', text: 'Reunion' },\n  { key: 'RO', value: 'RO', flag: 'ro', text: 'Romania' },\n  { key: 'RU', value: 'RU', flag: 'ru', text: 'Russia' },\n  { key: 'RW', value: 'RW', flag: 'rw', text: 'Rwanda' },\n  { key: 'SH', value: 'SH', flag: 'sh', text: 'Saint Helena' },\n  { key: 'KN', value: 'KN', flag: 'kn', text: 'Saint Kitts and Nevis' },\n  { key: 'LC', value: 'LC', flag: 'lc', text: 'Saint Lucia' },\n  { key: 'PM', value: 'PM', flag: 'pm', text: 'Saint Pierre' },\n  { key: 'VC', value: 'VC', flag: 'vc', text: 'Saint Vincent' },\n  { key: 'WS', value: 'WS', flag: 'ws', text: 'Samoa' },\n  { key: 'SM', value: 'SM', flag: 'sm', text: 'San Marino' },\n  { key: 'GS', value: 'GS', flag: 'gs', text: 'Sandwich Islands' },\n  { key: 'ST', value: 'ST', flag: 'st', text: 'Sao Tome' },\n  { key: 'SA', value: 'SA', flag: 'sa', text: 'Saudi Arabia' },\n  { key: 'SN', value: 'SN', flag: 'sn', text: 'Senegal' },\n  { key: 'CS', value: 'CS', flag: 'cs', text: 'Serbia' },\n  { key: 'RS', value: 'RS', flag: 'rs', text: 'Serbia' },\n  { key: 'SC', value: 'SC', flag: 'sc', text: 'Seychelles' },\n  { key: 'SL', value: 'SL', flag: 'sl', text: 'Sierra Leone' },\n  { key: 'SG', value: 'SG', flag: 'sg', text: 'Singapore' },\n  { key: 'SK', value: 'SK', flag: 'sk', text: 'Slovakia' },\n  { key: 'SI', value: 'SI', flag: 'si', text: 'Slovenia' },\n  { key: 'SB', value: 'SB', flag: 'sb', text: 'Solomon Islands' },\n  { key: 'SO', value: 'SO', flag: 'so', text: 'Somalia' },\n  { key: 'ZA', value: 'ZA', flag: 'za', text: 'South Africa' },\n  { key: 'KR', value: 'KR', flag: 'kr', text: 'South Korea' },\n  { key: 'ES', value: 'ES', flag: 'es', text: 'Spain' },\n  { key: 'LK', value: 'LK', flag: 'lk', text: 'Sri Lanka' },\n  { key: 'SD', value: 'SD', flag: 'sd', text: 'Sudan' },\n  { key: 'SR', value: 'SR', flag: 'sr', text: 'Suriname' },\n  { key: 'SJ', value: 'SJ', flag: 'sj', text: 'Svalbard' },\n  { key: 'SZ', value: 'SZ', flag: 'sz', text: 'Swaziland' },\n  { key: 'SE', value: 'SE', flag: 'se', text: 'Sweden' },\n  { key: 'CH', value: 'CH', flag: 'ch', text: 'Switzerland' },\n  { key: 'SY', value: 'SY', flag: 'sy', text: 'Syria' },\n  { key: 'TW', value: 'TW', flag: 'tw', text: 'Taiwan' },\n  { key: 'TJ', value: 'TJ', flag: 'tj', text: 'Tajikistan' },\n  { key: 'TZ', value: 'TZ', flag: 'tz', text: 'Tanzania' },\n  { key: 'TH', value: 'TH', flag: 'th', text: 'Thailand' },\n  { key: 'TL', value: 'TL', flag: 'tl', text: 'Timorleste' },\n  { key: 'TG', value: 'TG', flag: 'tg', text: 'Togo' },\n  { key: 'TK', value: 'TK', flag: 'tk', text: 'Tokelau' },\n  { key: 'TO', value: 'TO', flag: 'to', text: 'Tonga' },\n  { key: 'TT', value: 'TT', flag: 'tt', text: 'Trinidad' },\n  { key: 'TN', value: 'TN', flag: 'tn', text: 'Tunisia' },\n  { key: 'TR', value: 'TR', flag: 'tr', text: 'Turkey' },\n  { key: 'TM', value: 'TM', flag: 'tm', text: 'Turkmenistan' },\n  { key: 'TV', value: 'TV', flag: 'tv', text: 'Tuvalu' },\n  { key: 'UG', value: 'UG', flag: 'ug', text: 'Uganda' },\n  { key: 'UA', value: 'UA', flag: 'ua', text: 'Ukraine' },\n  { key: 'AE', value: 'AE', flag: 'ae', text: 'United Arab Emirates' },\n  { key: 'US', value: 'US', flag: 'us', text: 'United States' },\n  { key: 'UY', value: 'UY', flag: 'uy', text: 'Uruguay' },\n  { key: 'UM', value: 'UM', flag: 'um', text: 'Us Minor Islands' },\n  { key: 'VI', value: 'VI', flag: 'vi', text: 'Us Virgin Islands' },\n  { key: 'UZ', value: 'UZ', flag: 'uz', text: 'Uzbekistan' },\n  { key: 'VU', value: 'VU', flag: 'vu', text: 'Vanuatu' },\n  { key: 'VA', value: 'VA', flag: 'va', text: 'Vatican City' },\n  { key: 'VE', value: 'VE', flag: 've', text: 'Venezuela' },\n  { key: 'VN', value: 'VN', flag: 'vn', text: 'Vietnam' },\n  { key: 'WF', value: 'WF', flag: 'wf', text: 'Wallis and Futuna' },\n  { key: 'EH', value: 'EH', flag: 'eh', text: 'Western Sahara' },\n  { key: 'YE', value: 'YE', flag: 'ye', text: 'Yemen' },\n  { key: 'ZM', value: 'ZM', flag: 'zm', text: 'Zambia' },\n  { key: 'ZW', value: 'ZW', flag: 'zw', text: 'Zimbabwe' }\n]\n","import { constants } from '@bloks/constants'\nimport { JsonRpc } from '../index'\nimport { Country, CountryOption, UserInfo, KycProvider, KycIpInfo, ApplyForKycParams, KycApplyResponse, KycStatus, KycStatusResponse } from '../types';\nimport countryOptions from './countryOptions';\n\nexport async function fetchKycCountries (\n  this: JsonRpc,\n  { chain }: { chain: string }\n): Promise<CountryOption[]> {\n  const url = `${constants.BLOKS_API}/${chain}/kyc?type=countries&chain=${chain}`\n  const { content: countries } = await this.get(url)\n  const countriesById = countries.reduce((acc: { [key: string]: Country }, country: Country) => {\n    acc[country.id] = country\n    return acc\n  }, {})\n  return countryOptions.filter(countryOption => countriesById[countryOption.key])\n}\n\n/**\n * Checks blockchain for a list of kycproviders, and sorts through the ones that are blacklisted.\n * @returns An array of strings with valid kyc provider names.\n */\nexport async function getValidKycProviders(this: JsonRpc) {\n  try {\n    const { rows } = await this.get_table_rows({\n      code: 'eosio.proton',\n      table: 'kycproviders',\n      scope: 'eosio.proton',\n    });\n    this.validKycProviders = rows.map((provider: KycProvider) => !provider.blisted && provider.kyc_provider)\n  } catch (e) {\n    throw new Error('Unable to get KYC Providers.')\n  }\n}\n\n/**\n * Takes an account or a list of accounts and checks to make sure that they are light-verified\n * @param account This could be an array of user rows from the usersinfo table on the blockchain, or a singular string for an account name\n * @returns An object of the user data as pulled from the usersinfo table on the blockchain with an additional key, isLightKYCVerified (boolean)\n */\nexport async function isLightKYCVerified(\n  this: JsonRpc,\n  account: UserInfo[] | string\n) {\n    const lightKyc = [\n      \"firstname\",\n      \"lastname\",\n      \"birthdate\",\n      \"address\"\n    ];\n\n    if (account.length === 0) {\n      throw new Error('Please enter an account.');\n    }\n\n    if (this.validKycProviders.length === 0) {\n      await this.getValidKycProviders();\n    }\n\n    let users: UserInfo[] = [];\n\n    if (Array.isArray(account)) {\n      users = account;\n    } else if (typeof account === 'string') {\n      try {\n        const { rows } = await this.get_table_rows({\n            code: 'eosio.proton',\n            table: 'usersinfo',\n            scope: 'eosio.proton',\n            lower_bound: account,\n            upper_bound: account,\n        });\n        \n        users = rows;\n      } catch(e) {\n        throw new Error('Account not found!');\n      }\n    }\n    \n    const resultsWithKycStatus: UserInfo[] = users.map((user: UserInfo) => {\n      const levelsResult: string[] = user.kyc.reduce((acc: string[], kyc) => {\n        if (this.validKycProviders.indexOf(kyc.kyc_provider) >= 0) {\n          const result = kyc.kyc_level.split(',').map((kycItem: string) => kycItem.split(':')[1]);\n          acc = result.concat(acc);\n        }\n\n        return acc\n      }, []);\n\n      user.isLightKYCVerified = lightKyc.every(lightKycField => levelsResult.includes(lightKycField));\n\n      return user\n    })\n\n    return resultsWithKycStatus;\n};\n\n/**\n * FAILED\n * UNSUBMITTED\n * PENDING\n * PASSED\n */\nexport async function checkUserKycStatus (\n  this: JsonRpc,\n  { chain, actor, expectedTier }: { chain: string; actor: string; expectedTier: number; }\n): Promise<KycStatus> {\n  if (!chain || !actor || !expectedTier) {\n    throw new Error('Invalid parameters')\n  }\n\n  return new Promise(async (resolve, reject) => {\n    // Get all KYC records for user\n    const getStatus = async () => {\n      const [userInfo] = await this.isLightKYCVerified(actor)\n      if (userInfo && userInfo.isLightKYCVerified) {\n        return resolve(KycStatus.PASSED)\n      }\n\n      const url = `${constants.BLOKS_API}/${chain}/kyc?type=status&chain=${chain}&actor=${actor}`\n      const kyc: KycStatusResponse = await this.get(url)\n      if (!kyc || !kyc.length) {\n        return reject(new Error('Could not fetch KYC record'))\n      }\n  \n      // Find relevant KYC record\n      const matchedTier = kyc.find(({ tier }: { tier: string }) => tier === String(expectedTier))\n      if (!matchedTier) {\n        return reject(new Error('No kyc data matching tier found'))\n      }\n  \n      // Unwrap kyc data\n      const { status } = matchedTier\n      if (!matchedTier.status) {\n        return reject(new Error('KYC Status not found'))\n      }\n\n      if (status === KycStatus.PENDING) {\n        setTimeout(() => getStatus(), 1000 * 2)\n      } else {\n        return resolve(status)\n      }\n    }\n\n    getStatus()\n  })\n}\n\nexport async function applyForKyc (this: JsonRpc, params: ApplyForKycParams): Promise<KycApplyResponse> {\n  const url = `${constants.BLOKS_API}/${params.chain}/kyc`\n  const data: KycApplyResponse = await this.post(url, {\n    type: 'apply',\n    ...params\n  })\n\n  if (data) {\n    return data\n  } else {\n    throw new Error('Could not apply for KYC')\n  }\n}\n\nexport async function currentLocation (this: JsonRpc): Promise<KycIpInfo> {\n  const url = `${constants.PROTON_API}/v1/kyc/ip-info`\n  return await this.get(url)\n}\n  ","import { constants } from '@bloks/constants'\nimport { JsonRpc } from '../index'\nimport { ExchangeRates, exchangeRatesParser, WithdrawalFeeQuote, withdrawalFeeQuoteParser } from './parsers'\n\nexport async function getTokenPrices (this: JsonRpc) : Promise<ExchangeRates> {\n    const url = constants.METAL_PROTON_ENDPOINT + `/v1/chain/exchange-rates/info`\n    try {\n        const { data } = await this.get(url)\n        return exchangeRatesParser.parse(data)\n    } catch (e) {\n        throw new Error(`Could not fetch exchange rates`)\n    }\n}\n\nexport async function getWithdrawalFee (this: JsonRpc, { currency, network }: { currency: string, network: string }) : Promise<WithdrawalFeeQuote | undefined> {\n    const url = constants.METAL_PROTON_ENDPOINT + `/v1/swaps/calculate-estimated-fee`\n    try {\n        const { data } = await this.post(url, { currency, network })\n        return withdrawalFeeQuoteParser.parse(data)\n    } catch (e) {\n        console.log(e)\n        return undefined\n    }\n}\n","import { constants } from '@bloks/constants'\nimport { OtcQuoteBody, OtcQuoteResponse, OtcOrderResponse } from './parsers';\nimport { JsonRpc } from '../index'\n\nexport async function otcQuote (this: JsonRpc, body: OtcQuoteBody): Promise<OtcQuoteResponse> {\n    const url = constants.SWAP_URL + `/v1/quote/${body.baseSymbol}/${body.baseAmount}/${body.quoteSymbol}`\n    const { data } = await this.get(url)\n    return data\n}\n\nexport async function otcOrder (this: JsonRpc, id: string): Promise<OtcOrderResponse> {\n    const url = constants.SWAP_URL + `/v1/order/${id}`\n    const { data } = await this.get(url)\n    return data\n}","import { constants } from '@bloks/constants'\nimport { GenerateAddressBody, GenerateAddressResponse, WithdrawBody, WithdrawMetalResponse, WithdrawHistoryMetalResponse } from './parsers'\nimport { JsonRpc } from '../index'\n\nexport async function generateAddress (this: JsonRpc, body: GenerateAddressBody): Promise<GenerateAddressResponse> {\n    const url = constants.WRAP_SERVER_URL + '/address/generate'\n    const { data } = await this.post(url, body)\n    return data\n}\n\nexport async function withdrawMetal (this: JsonRpc, body: WithdrawBody): Promise<WithdrawMetalResponse> {\n    const url = constants.WRAP_SERVER_URL + '/withdraw'\n    const { data } = await this.post(url, body)\n    return data\n}\n\nexport async function withdrawalHistoryMetal (this: JsonRpc, account: string): Promise<WithdrawHistoryMetalResponse> {\n    const url = constants.WRAP_SERVER_URL + `/withdrawals/${account}`\n    const { data } = await this.get(url)\n    return data\n}\n\n","import { JsonRpc } from './index'\n\n/** Raw call to `/v1/chain/get_table_rows` */\nexport async function get_table_rows(this: JsonRpc, {\n    json = true,\n    code,\n    scope,\n    table,\n    table_key = '',\n    lower_bound = '',\n    upper_bound = '',\n    index_position = 1,\n    key_type = '',\n    limit = 10,\n    reverse = false,\n    show_payer = false,\n}: any): Promise<any> {\n    return await this.post(\n        '/v1/chain/get_table_rows', {\n            json,\n            code,\n            scope,\n            table,\n            table_key,\n            lower_bound,\n            upper_bound,\n            index_position,\n            key_type,\n            limit,\n            reverse,\n            show_payer,\n        });\n}\n\n/** Raw call to `/v1/chain/get_kv_table_rows` */\nexport async function get_kv_table_rows(this: JsonRpc, {\n    json = true,\n    code,\n    table,\n    index_name,\n    encode_type = 'bytes',\n    index_value = '',\n    lower_bound = '',\n    upper_bound = '',\n    limit = 10,\n    reverse = false,\n    show_payer = false,\n}: any): Promise<any> {\n    return await this.post(\n        '/v1/chain/get_kv_table_rows', {\n            json,\n            code,\n            table,\n            index_name,\n            encode_type,\n            index_value,\n            lower_bound,\n            upper_bound,\n            limit,\n            reverse,\n            show_payer,\n        }\n    );\n}\n\n/** Raw call to `/v1/chain/get_table_by_scope` */\nexport async function get_table_by_scope(this: JsonRpc, {\n    code,\n    table,\n    lower_bound = '',\n    upper_bound = '',\n    limit = 10,\n}: any): Promise<any> {\n    return await this.post(\n        '/v1/chain/get_table_by_scope', {\n            code,\n            table,\n            lower_bound,\n            upper_bound,\n            limit,\n        }\n    );\n}\n","export const arrayToHex = (data: Uint8Array) => {\n    let result = '';\n    for (const x of data) {\n        result += ('00' + x.toString(16)).slice(-2);\n    }\n    return result;\n};","import { JsonRpc } from './index'\nimport { arrayToHex } from './utils'\nimport { PushTransactionArgs } from './types';\n\n/** Push a serialized transaction (replaced by send_transaction, but returned format has changed) */\nexport async function push_transaction(\n    this: JsonRpc,\n    { signatures, compression = 0, serializedTransaction, serializedContextFreeData }: PushTransactionArgs\n): Promise<any> {\n    try {\n        return await this.post('/v1/chain/push_transaction', {\n            signatures,\n            compression,\n            packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),\n            packed_trx: arrayToHex(serializedTransaction),\n        });\n    } catch (e) {\n        if (e && e.json && e.json.error) {\n            const expired = e.json.error.name === 'expired_tx_exception'\n            if (expired) {\n                e.json.error.message = 'Transaction Expired: Try Again'\n                this.nextEndpoint()\n            }\n        }\n        throw e\n    }\n}\n\n/** Send a serialized transaction */\nexport async function send_transaction(\n    this: JsonRpc,\n    { signatures, compression = 0, serializedTransaction, serializedContextFreeData }: PushTransactionArgs\n): Promise<any> {\n    return await this.post('/v1/chain/send_transaction', {\n        signatures,\n        compression,\n        packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),\n        packed_trx: arrayToHex(serializedTransaction),\n    });\n}\n","import { JsonRpc } from './index'\nimport { base64ToBinary } from '../api/numeric';\nimport { BinaryAbi } from '../api/types';\nimport {\n    GetAbiResult,\n    GetCodeResult,\n    GetRawCodeAndAbiResult,\n    GetRawAbiResult,\n} from './types';\n\n/** Raw call to `/v1/chain/get_abi` */\nexport async function get_abi(this: JsonRpc, accountName: string): Promise<GetAbiResult> {\n    return await this.post('/v1/chain/get_abi', { account_name: accountName });\n}\n\n/** Raw call to `/v1/chain/get_raw_code_and_abi` */\nexport async function get_raw_code_and_abi(this: JsonRpc, accountName: string): Promise<GetRawCodeAndAbiResult> {\n    return await this.post('/v1/chain/get_raw_code_and_abi', { account_name: accountName });\n}\n\n/** calls `/v1/chain/get_raw_abi` and pulls out unneeded raw wasm code */\nexport async function getRawAbi(this: JsonRpc, accountName: string): Promise<BinaryAbi> {\n    const rawCodeAndAbi = await this.get_raw_abi(accountName);\n    const abi = base64ToBinary(rawCodeAndAbi.abi);\n    return {\n        accountName: rawCodeAndAbi.account_name,\n        abi\n    };\n}\n\n/** Raw call to `/v1/chain/get_raw_abi` */\nexport async function get_raw_abi(this: JsonRpc, accountName: string): Promise<GetRawAbiResult> {\n    return await this.post('/v1/chain/get_raw_abi', { account_name: accountName });\n}\n\n/** Raw call to `/v1/chain/get_code` */\nexport async function get_code(this: JsonRpc, accountName: string): Promise<GetCodeResult> {\n    return await this.post('/v1/chain/get_code', {\n        account_name: accountName,\n        code_as_wasm: true\n    });\n}\n","/**\n * @module RPC-Error\n */\n\n/** Holds detailed error information */\nexport class RpcError extends Error {\n    /** Detailed error information */\n    public json: any;\n\n    constructor(json: any) {\n        if (json && json.error && json.error.details && json.error.details.length && json.error.details[0].message) {\n            super(json.error.details[0].message);\n        } else if (json && json.processed && json.processed.except && json.processed.except.message) {\n            super(json.processed.except.message);\n        } else if(json) {\n            super(json.message);\n        } else {\n            super(json);\n        }\n        Object.setPrototypeOf(this, RpcError.prototype);\n        this.json = json;\n    }\n}\n","import { AbiProvider, AuthorityProvider } from '../api/types';\nimport {\n    get_account,\n    get_block_header_state,\n    get_block_info,\n    get_block,\n    get_currency_balance,\n    get_currency_stats,\n    get_info,\n    get_producer_schedule,\n    get_producers,\n    get_scheduled_transactions,\n    get_activated_protocol_features,\n    getRequiredKeys\n} from './chain'\nimport {\n    history_get_actions,\n    history_get_transaction,\n    history_get_key_accounts,\n    history_get_controlled_accounts\n} from './history'\nimport {\n    db_size_get\n} from './db'\nimport {\n    applyForKyc,\n    checkUserKycStatus,\n    currentLocation,\n    getValidKycProviders,\n    isLightKYCVerified,\n    fetchKycCountries,\n    otcQuote,\n    otcOrder,\n    generateAddress,\n    withdrawMetal,\n    withdrawalHistoryMetal,\n    getTokenPrices,\n    getWithdrawalFee\n} from './proton'\nimport {\n    get_table_rows,\n    get_kv_table_rows,\n    get_table_by_scope\n} from './tables'\nimport {\n    push_transaction,\n    send_transaction\n} from './pushTransaction'\nimport {\n    get_abi,\n    get_raw_code_and_abi,\n    getRawAbi,\n    get_raw_abi,\n    get_code\n} from './abiCode'\nimport { RpcError } from './error';\nimport { constants } from '@bloks/constants'\nimport fetch from 'cross-fetch';\n\n/** Make RPC calls */\nexport class JsonRpc implements AuthorityProvider, AbiProvider {\n    public endpoints: string[];\n    public maxRetries: number = 3;\n    public currentEndpoint: string;\n    public validKycProviders: string[] = [];\n\n    /**\n     * @param args\n     *`fetch`:\n     * browsers: leave `null` or `undefined`\n     * node: provide an implementation\n     */\n    constructor(endpoints: string | string[]) {\n        endpoints = Array.isArray(endpoints) ? endpoints : [endpoints];\n        this.endpoints = endpoints.map(endpoint => endpoint.replace(/\\/$/, ''))\n        this.currentEndpoint = ''\n        this.nextEndpoint();\n    }\n\n    public nextEndpoint() {\n        if (this.endpoints.length) {\n            if (this.currentEndpoint) {\n                const removed = this.endpoints.shift();\n                this.endpoints = this.endpoints.concat(removed || []);\n            }\n\n            this.currentEndpoint = this.endpoints[0];\n        }\n    }\n\n    /** Post `body` to `endpoint + path`. Throws detailed error information in `RpcError` when available. */\n    public async post(path: string, body: any, currentRetries: number = 0): Promise<any> {\n        let response;\n        let json;\n        try {\n            response = await fetch(this.currentEndpoint + path, {\n                body: JSON.stringify(body),\n                method: 'POST',\n            });\n            json = await response.json();\n\n            if (json.processed && json.processed.except) {\n                throw new RpcError(json);\n            }\n        } catch (e) {\n            if (this.endpoints.length > 1) {\n                this.nextEndpoint()\n                if (currentRetries < this.maxRetries)  {\n                    return this.post(path, body, ++currentRetries)\n                } else {\n                    e.isFetchError = true;\n                    throw new RpcError(e);\n                }\n            }\n        }\n\n        if (!(response && response.ok)) {\n            throw new RpcError(json);\n        }\n\n        // Check for synced\n        if (json && json.head_block_time) {\n            const headTime = new Date(json.head_block_time + 'Z').getTime()\n            const ct = new Date().getTime()\n            const secondsBehind = (ct - headTime) / 1000\n\n            if (secondsBehind > constants.MAX_SECONDS_BEHIND && this.endpoints.length > 1) {\n                this.nextEndpoint()\n                if (currentRetries < this.maxRetries)  {\n                    return this.post(path, body, ++currentRetries)\n                }\n            }\n        }\n\n        return json;\n    }\n\n    /** Get from endpoint  */\n    public async get(path: string): Promise<any> {\n        const res = await fetch(path);\n\n        if (res.status >= 400) {\n            throw new Error(\"Bad response from server \" + res.status);\n        }\n\n        return await res.json()\n    }\n\n    public get_account = get_account;\n    public get_block_header_state = get_block_header_state;\n    public get_block_info = get_block_info;\n    public get_block = get_block;\n    public get_currency_balance = get_currency_balance;\n    public get_currency_stats = get_currency_stats;\n    public get_info = get_info;\n    public get_producer_schedule = get_producer_schedule;\n    public get_producers = get_producers;\n    public get_scheduled_transactions = get_scheduled_transactions;\n    public get_activated_protocol_features = get_activated_protocol_features;\n    public getRequiredKeys = getRequiredKeys;\n\n    public get_abi = get_abi;\n    public get_raw_code_and_abi = get_raw_code_and_abi;\n    public getRawAbi = getRawAbi;\n    public get_raw_abi = get_raw_abi;\n    public get_code = get_code;\n\n    public push_transaction = push_transaction;\n    public send_transaction = send_transaction;\n\n    public get_table_rows = get_table_rows;\n    public get_kv_table_rows = get_kv_table_rows;\n    public get_table_by_scope = get_table_by_scope;\n\n    public history_get_actions = history_get_actions;\n    public history_get_transaction = history_get_transaction;\n    public history_get_key_accounts = history_get_key_accounts;\n    public history_get_controlled_accounts = history_get_controlled_accounts;\n\n    public db_size_get = db_size_get;\n\n    // Proton\n    public fetchKycCountries = fetchKycCountries;\n    public getValidKycProviders = getValidKycProviders;\n    public isLightKYCVerified = isLightKYCVerified;\n    public checkUserKycStatus = checkUserKycStatus;\n    public applyForKyc = applyForKyc;\n    public currentLocation = currentLocation;\n\n    public otcQuote = otcQuote;\n    public otcOrder = otcOrder;\n    public generateAddress = generateAddress;\n    public withdrawMetal = withdrawMetal;\n    public withdrawalHistoryMetal = withdrawalHistoryMetal;\n    public getTokenPrices = getTokenPrices;\n    public getWithdrawalFee = getWithdrawalFee;\n} // JsonRpc\n\nexport { RpcError } from './error';\n","import { Api } from './api';\nimport * as ApiInterfaces from './api/types';\n\nimport { JsonRpc, RpcError } from './rpc';\nimport * as RpcInterfaces from './rpc/types';\n\nimport * as Numeric from './api/numeric';\nimport * as Serialize from './api/serialize';\n\nimport { JsSignatureProvider } from './cryptography/jsSignatureProvider';\n\nimport * as Key from './cryptography/key'\nimport { sha256 } from './cryptography/conversions'\n\nexport {\n  Api,\n  ApiInterfaces,\n  JsonRpc,\n  Numeric,\n  RpcInterfaces,\n  RpcError,\n  Serialize,\n  JsSignatureProvider,\n  Key,\n  sha256\n};\n\nexport default {\n  Api,\n  ApiInterfaces,\n  JsonRpc,\n  Numeric,\n  RpcInterfaces,\n  RpcError,\n  Serialize,\n  JsSignatureProvider,\n  Key,\n  sha256\n};\n"],"names":["KeyType","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","ripemd160","RIPEMD160","hash","base58Chars","base64Chars","base58Map","base58M","Array","fill","charCodeAt","create_base58_map","base64Map","base64M","create_base64_map","isNegative","bignum","negate","carry","x","decimalToBinary","size","s","Uint8Array","srcDigit","j","signedDecimalToBinary","negative","substr","binaryToDecimal","minDigits","String","fromCharCode","signedBinaryToDecimal","base58ToBinary","base58ToBinaryVarSize","binaryToBase58","base64ToBinary","len","groups","bytes","group","digit0","digit1","digit2","digit3","digestSuffixRipemd160","data","suffix","d","stringToKey","whole","buffer","digest","keyToString","prefix","stringToPublicKey","publicKeyDataSize","k1","r1","wa","publicKeyToLegacyString","publicKeyToString","convertLegacyPublicKey","convertLegacyPublicKeys","map","stringToPrivateKey","privateKeyDataSize","privateKeyToLegacyString","byte","sha256","update","privateKeyToString","stringToSignature","signatureToString","signature","publicKey","nonPrefixPublicKey","bytesWithChecksum","bs58","suffixBytes","Buffer","from","binaryPublicKey","SerializerState","options","SerialBuffer","array","textEncoder","textDecoder","TextEncoder","TextDecoder","reserve","l","Math","ceil","newArray","set","haveReadData","readPos","restartRead","asUint8Array","byteOffset","pushArray","v","get","pushUint8ArrayChecked","getUint8Array","skip","pushUint16","getUint16","pushUint32","getUint32","pushNumberAsUint64","floor","getUint64AsNumber","low","pushVaruint32","getVaruint32","bit","b","pushVarint32","getVarint32","pushFloat32","Float32Array","getFloat32","pushFloat64","Float64Array","getFloat64","pushName","RegExp","test","charToSymbol","c","a","getName","endsWith","pushBytes","getBytes","pushString","encode","getString","decode","pushSymbolCode","getSymbolCode","pushSymbol","precision","getSymbol","pushAsset","pos","amount","trim","foundDigit","numeric","getAsset","pushPublicKey","getPublicKey","begin","pushPrivateKey","getPrivateKey","pushSignature","getSignature","supportedAbiVersion","version","startsWith","checkDateParse","date","Date","parse","Number","dateToTimePoint","round","timePointToDate","us","toISOString","dateToTimePointSec","timePointSecToDate","sec","dateToBlockTimestamp","blockTimestampToDate","slot","stringToSymbol","m","match","symbolToString","arrayToHex","toUpperCase","hexToUint8Array","hex","parseInt","serializeUnknown","_","__","deserializeUnknown","serializeStruct","allowExtensions","JSON","stringify","base","serialize","fields","field","skippedBinaryExtension","extensionOf","deserializeStruct","deserialize","serializeVariant","isArray","findIndex","deserializeVariant","serializeArray","arrayOf","deserializeArray","serializeOptional","optionalOf","deserializeOptional","serializeExtension","deserializeExtension","serializeObject","entries","dataType","deserializeObject","KycStatus","createType","attrs","aliasOfName","baseName","checkRange","orig","converted","createInitialTypes","Map","bool","uint8","int8","uint16","int16","uint32","uint64","int64","int32","varuint32","varint32","uint128","int128","float32","float64","float128","bytesAsUint8Array","string","time_point","time_point_sec","block_timestamp_type","symbol_code","symbol","asset","checksum160","checksum256","checksum512","public_key","private_key","typeName","createAbiTypes","initialTypes","getType","types","getTypesFromAbi","abi","new_type_name","structs","variants","transactionHeader","refBlock","expireSeconds","h","timestamp","header","id","expiration","ref_block_num","block_num","ref_block_prefix","serializeActionData","contract","account","action","actions","serializeAction","authorization","deserializeActionData","deserializeAction","serializeAnyvar","anyvar","def","anyvarDefs","null_t","any_array","any_object","index","deserializeAnyvar","defIndex","anyvarDefsByIndex","useShortForm","deserializeAnyvarShort","serializeAnyObject","deserializeAnyObject","serializeAnyArray","arr","deserializeAnyArray","additionalTypes","addAdditionalTypes","serializeQuery","query","filter","constructElliptic","EC","PublicKey","ec","fromString","publicKeyStr","fromElliptic","keyType","getPublic","getX","toArray","y","getY","concat","toLegacyString","toElliptic","keyPair","pub","isValid","validate","BN","require","Signature","sig","ellipticSig","recoveryParam","eosioRecoveryParam","r","sigData","ellipticRecoveryBitField","lengthOfR","toBinary","verify","shouldHash","encoding","ellipticSignature","ellipticPublicKey","recover","recoveredPublicKey","recoverPubKey","ellipticKPub","keyFromPublic","PrivateKey","privKey","getPrivate","toArrayLike","keyString","privateKey","keyFromPrivate","ellipticPrivateKey","sign","tries","constructSignature","_this","canonical","pers","secureEnv","ellipticKeyPair","genKeyPair","ecOptions","defaultEc","digestFromSerializedData","chainId","serializedTransaction","serializedContextFreeData","e","signBuf","JsSignatureProvider","privateKeys","priv","privElliptic","pubStr","availableKeys","getAvailableKeys","requiredKeys","signatures","tables","ricardian_clauses","error_messages","abi_extensions","Api","args","rpc","authorityProvider","abiProvider","signatureProvider","abiTypes","ser","transactionTypes","transactionAbi","rawAbiToJson","rawAbi","jsonToRawAbi","jsonAbi","getCachedAbi","accountName","reload","cachedAbis","getRawAbi","cachedAbi","message","_context","getAbi","getTransactionAbis","transaction","context_free_actions","accounts","uniqueAccounts","Set","actionPromises","all","getContract","contracts","serializeTransaction","max_net_usage_words","max_cpu_usage_ms","delay_sec","transaction_extensions","serializeContextFreeData","contextFreeData","deserializeTransaction","serializeActions","_this2","deserializeActions","_this3","deserializeActionsSync","deserializedActions","deserializeTransactionWithActions","deserializedTransaction","deserializedCFActions","deflateSerializedArray","serializedArray","deflate","level","inflateSerializedArray","compressedSerializedArray","inflate","transact","broadcast","compression","blocksBehind","useLastIrreversible","get_info","generateTapos","hasRequiredTaposFields","abis","context_free_data","pushTransactionArgs","getRequiredKeys","chain_id","pushCompressedSignedTransaction","pushSignedTransaction","transactWithDelay","params","delay","wait","ms","setTimeout","success","short","tryRefBlockFromGetInfo","queryBuffer","send_transaction","returnBuffer","processed","action_traces","return_value","push_transaction","compressedSerializedTransaction","compressedSerializedContextFreeData","taposBlockNumber","head_block_num","last_irreversible_block_num","tryGetBlockInfo","tryGetBlockHeaderState","get_block_header_state","blockNumber","get_block_info","get_block","last_irreversible_block_id","last_irreversible_block_time","block","ActionBuilder","buildTransaction","cb","tx","TransactionBuilder","getAccountKeys","actor","permission","get_account","relevantPermission","permissions","find","perm_name","required_auth","console","log","checkIfKeysMatchTransaction","verified","some","api","actionBuilder","associateContextFree","contextFreeGroup","contextFreeGroups","send","config","contextFreeDataSet","contextFreeActions","serializedData","contextFreeCallback","cfd","cfa","contextFreeAction","as","actorName","ActionSerializer","parent","assign","_this4","post","account_name","blockNumOrId","block_num_or_id","blockNum","get_currency_balance","code","get_currency_stats","get_producer_schedule","get_producers","json","lowerBound","limit","lower_bound","get_scheduled_transactions","get_activated_protocol_features","available_keys","required_keys","history_get_actions","offset","history_get_transaction","blockNumHint","block_num_hint","history_get_key_accounts","history_get_controlled_accounts","controllingAccount","controlling_account","db_size_get","Status","flag","text","fetchKycCountries","url","constants","BLOKS_API","chain","countriesById","content","reduce","acc","country","countryOptions","countryOption","getValidKycProviders","get_table_rows","table","scope","validKycProviders","rows","provider","blisted","kyc_provider","isLightKYCVerified","lightKyc","users","upper_bound","resultsWithKycStatus","user","levelsResult","kyc","indexOf","kyc_level","split","kycItem","every","lightKycField","includes","checkUserKycStatus","expectedTier","getStatus","userInfo","PASSED","matchedTier","tier","status","PENDING","applyForKyc","currentLocation","PROTON_API","rateParser","z","counterCurrency","price","priceChangePercent","marketCap","volume","exchangeRatesParser","rank","rates","withdrawalFeeQuoteParser","quoteId","estimatedFee","currency","network","getTokenPrices","METAL_PROTON_ENDPOINT","getWithdrawalFee","otcQuote","body","SWAP_URL","baseSymbol","baseAmount","quoteSymbol","otcOrder","generateAddress","WRAP_SERVER_URL","withdrawMetal","withdrawalHistoryMetal","table_key","index_position","key_type","show_payer","get_kv_table_rows","index_name","encode_type","index_value","get_table_by_scope","packed_context_free_data","packed_trx","nextEndpoint","get_abi","get_raw_code_and_abi","get_raw_abi","rawCodeAndAbi","get_code","code_as_wasm","RpcError","details","except","JsonRpc","endpoints","endpoint","replace","currentEndpoint","removed","shift","path","currentRetries","fetch","response","maxRetries","isFetchError","ok","head_block_time","headTime","getTime","MAX_SECONDS_BEHIND","res","ApiInterfaces","Numeric","RpcInterfaces","Serialize","Key"],"mappings":"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"}