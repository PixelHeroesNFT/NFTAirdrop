{"version":3,"file":"js.cjs.production.min.js","sources":["../src/api/numeric.ts","../node_modules/regenerator-runtime/runtime.js","../src/api/serialize.ts","../src/cryptography/conversions.ts","../src/cryptography/publicKey.ts","../src/cryptography/signature.ts","../src/cryptography/privateKey.ts","../src/cryptography/key.ts","../src/cryptography/jsSignatureProvider.ts","../src/api/index.ts","../src/rpc/error.ts","../src/rpc/proton.ts","../src/rpc/index.ts","../src/cryptography/webauthn.ts","../src/index.ts"],"sourcesContent":["/**\n * @module Numeric\n */\n import { sha256 } from 'hash.js';\n import RIPEMD160 from 'ripemd-ts'\n \n const ripemd160 = RIPEMD160.hash as (a: Uint8Array) => ArrayBuffer;\n const base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n \n const create_base58_map = (): number[] => {\n    const base58M = Array(256).fill(-1) as number[];\n     for (let i = 0; i < base58Chars.length; ++i) {\n         base58M[base58Chars.charCodeAt(i)] = i;\n     }\n     return base58M;\n };\n \n const base58Map = create_base58_map();\n \n const create_base64_map = (): number[] => {\n    const base64M = Array(256).fill(-1) as number[];\n     for (let i = 0; i < base64Chars.length; ++i) {\n         base64M[base64Chars.charCodeAt(i)] = i;\n     }\n     base64M['='.charCodeAt(0)] = 0;\n     return base64M;\n };\n \n const base64Map = create_base64_map();\n \n /** Is `bignum` a negative number? */\n export const isNegative = (bignum: Uint8Array): boolean => {\n    return (bignum[bignum.length - 1] & 0x80) !== 0;\n };\n \n /** Negate `bignum` */\n export const negate = (bignum: Uint8Array): void => {\n    let carry = 1;\n     for (let i = 0; i < bignum.length; ++i) {\n         const x = (~bignum[i] & 0xff) + carry;\n         bignum[i] = x;\n         carry = x >> 8;\n     }\n };\n \n /**\n  * Convert an unsigned decimal number in `s` to a bignum\n  *\n  * @param size bignum size (bytes)\n  */\nexport const decimalToBinary = (size: number, s: string): Uint8Array => {\n    const result = new Uint8Array(size);\n     for (let i = 0; i < s.length; ++i) {\n         const srcDigit = s.charCodeAt(i);\n         if (srcDigit < '0'.charCodeAt(0) || srcDigit > '9'.charCodeAt(0)) {\n             throw new Error('invalid number');\n         }\n         let carry = srcDigit - '0'.charCodeAt(0);\n         for (let j = 0; j < size; ++j) {\n             const x = result[j] * 10 + carry;\n             result[j] = x;\n             carry = x >> 8;\n         }\n         if (carry) {\n             throw new Error('number is out of range');\n         }\n     }\n     return result;\n };\n \n /**\n  * Convert a signed decimal number in `s` to a bignum\n  *\n  * @param size bignum size (bytes)\n  */\nexport const signedDecimalToBinary = (size: number, s: string): Uint8Array => {\n    const negative = s[0] === '-';\n     if (negative) {\n         s = s.substr(1);\n     }\n     const result = decimalToBinary(size, s);\n     if (negative) {\n         negate(result);\n         if (!isNegative(result)) {\n             throw new Error('number is out of range');\n         }\n     } else if (isNegative(result)) {\n         throw new Error('number is out of range');\n     }\n     return result;\n };\n \n /**\n  * Convert `bignum` to an unsigned decimal number\n  *\n  * @param minDigits 0-pad result to this many digits\n  */\nexport const binaryToDecimal = (bignum: Uint8Array, minDigits = 1): string => {\n    const result = Array(minDigits).fill('0'.charCodeAt(0)) as number[];\n    for (let i = bignum.length - 1; i >= 0; --i) {\n        let carry = bignum[i];\n        for (let j = 0; j < result.length; ++j) {\n            const x = ((result[j] - '0'.charCodeAt(0)) << 8) + carry;\n            result[j] = '0'.charCodeAt(0) + x % 10;\n            carry = (x / 10) | 0;\n        }\n        while (carry) {\n            result.push('0'.charCodeAt(0) + carry % 10);\n            carry = (carry / 10) | 0;\n        }\n     }\n     result.reverse();\n     return String.fromCharCode(...result);\n };\n \n /**\n  * Convert `bignum` to a signed decimal number\n  *\n  * @param minDigits 0-pad result to this many digits\n  */\nexport const signedBinaryToDecimal = (bignum: Uint8Array, minDigits = 1): string => {\n    if (isNegative(bignum)) {\n         const x = bignum.slice();\n         negate(x);\n         return '-' + binaryToDecimal(x, minDigits);\n     }\n     return binaryToDecimal(bignum, minDigits);\n };\n \nconst base58ToBinaryVarSize = (s: string): Uint8Array => {\n    const result = [] as number[];\n    for (let i = 0; i < s.length; ++i) {\n        let carry = base58Map[s.charCodeAt(i)];\n        if (carry < 0) {\n            throw new Error('invalid base-58 value');\n        }\n        for (let j = 0; j < result.length; ++j) {\n            const x = result[j] * 58 + carry;\n            result[j] = x & 0xff;\n            carry = x >> 8;\n        }\n        if (carry) {\n            result.push(carry);\n        }\n    }\n    for (const ch of s) {\n        if (ch === '1') {\n            result.push(0);\n        } else {\n            break;\n        }\n    }\n    result.reverse();\n    return new Uint8Array(result);\n };\n \n /**\n  * Convert an unsigned base-58 number in `s` to a bignum\n  *\n  * @param size bignum size (bytes)\n  */\nexport const base58ToBinary = (size: number, s: string): Uint8Array => {\n    if (!size) {\n        return base58ToBinaryVarSize(s);\n    }\n    const result = new Uint8Array(size);\n    for (let i = 0; i < s.length; ++i) {\n        let carry = base58Map[s.charCodeAt(i)];\n        if (carry < 0) {\n            throw new Error('invalid base-58 value');\n        }\n        for (let j = 0; j < size; ++j) {\n            const x = result[j] * 58 + carry;\n            result[j] = x;\n            carry = x >> 8;\n        }\n        if (carry) {\n            throw new Error('base-58 value is out of range');\n        }\n    }\n    result.reverse();\n    return result;\n };\n \n /**\n  * Convert `bignum` to a base-58 number\n  *\n  * @param minDigits 0-pad result to this many digits\n  */\nexport const binaryToBase58 = (bignum: Uint8Array): string => {\n    const result = [] as number[];\n    for (const byte of bignum) {\n        let carry = byte;\n        for (let j = 0; j < result.length; ++j) {\n            const x = (base58Map[result[j]] << 8) + carry;\n            result[j] = base58Chars.charCodeAt(x % 58);\n            carry = (x / 58) | 0;\n        }\n        while (carry) {\n            result.push(base58Chars.charCodeAt(carry % 58));\n            carry = (carry / 58) | 0;\n        }\n    }\n    for (const byte of bignum) {\n        if (byte) {\n            break;\n        } else {\n            result.push('1'.charCodeAt(0));\n        }\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n };\n \n /** Convert an unsigned base-64 number in `s` to a bignum */\nexport const base64ToBinary = (s: string): Uint8Array => {\n     let len = s.length;\n     if ((len & 3) === 1 && s[len - 1] === '=') {\n         len -= 1;\n     } // fc appends an extra '='\n     if ((len & 3) !== 0) {\n         throw new Error('base-64 value is not padded correctly');\n     }\n     const groups = len >> 2;\n     let bytes = groups * 3;\n     if (len > 0 && s[len - 1] === '=') {\n         if (s[len - 2] === '=') {\n             bytes -= 2;\n         } else {\n             bytes -= 1;\n         }\n     }\n     const result = new Uint8Array(bytes);\n \n     for (let group = 0; group < groups; ++group) {\n         const digit0 = base64Map[s.charCodeAt(group * 4 + 0)];\n         const digit1 = base64Map[s.charCodeAt(group * 4 + 1)];\n         const digit2 = base64Map[s.charCodeAt(group * 4 + 2)];\n         const digit3 = base64Map[s.charCodeAt(group * 4 + 3)];\n         result[group * 3 + 0] = (digit0 << 2) | (digit1 >> 4);\n         if (group * 3 + 1 < bytes) {\n             result[group * 3 + 1] = ((digit1 & 15) << 4) | (digit2 >> 2);\n         }\n         if (group * 3 + 2 < bytes) {\n             result[group * 3 + 2] = ((digit2 & 3) << 6) | digit3;\n         }\n     }\n     return result;\n };\n \n /** Key types this library supports */\n export enum KeyType {\n     k1 = 0,\n     r1 = 1,\n     wa = 2,\n     rsa = 100,\n     eth = 101\n }\n \n /** Public key data size, excluding type field */\n export const publicKeyDataSize = 33;\n \n /** Private key data size, excluding type field */\n export const privateKeyDataSize = 32;\n \n /** Signature data size, excluding type field */\n export const signatureDataSize = 65;\n \n /** Public key, private key, or signature in binary form */\n export interface Key {\n     type: KeyType;\n     data: Uint8Array;\n }\n \nconst digestSuffixRipemd160 = (data: Uint8Array, suffix: string): ArrayBuffer => {\n    const d = new Uint8Array(data.length + suffix.length);\n    for (let i = 0; i < data.length; ++i) {\n        d[i] = data[i];\n    }\n    for (let i = 0; i < suffix.length; ++i) {\n        d[data.length + i] = suffix.charCodeAt(i);\n    }\n    return ripemd160(d);\n};\n \n const stringToKey = (s: string, type: KeyType, size: number, suffix: string): Key => {\n     const whole = base58ToBinary(size ? size + 4 : 0, s);\n     const result = { type, data: new Uint8Array(whole.buffer, 0, whole.length - 4) };\n     const digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));\n     if (\n        digest[0] !== whole[whole.length - 4] ||\n        digest[1] !== whole[whole.length - 3] ||\n        digest[2] !== whole[whole.length - 2] ||\n        digest[3] !== whole[whole.length - 1]\n     ) {\n        throw new Error('checksum doesn\\'t match');\n     }\n     return result;\n };\n \nconst keyToString = (key: Key, suffix: string, prefix: string): string => {\n    const digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));\n    const whole = new Uint8Array(key.data.length + 4);\n    for (let i = 0; i < key.data.length; ++i) {\n        whole[i] = key.data[i];\n    }\n    for (let i = 0; i < 4; ++i) {\n        whole[i + key.data.length] = digest[i];\n    }\n    return prefix + binaryToBase58(whole);\n};\n \n /** Convert key in `s` to binary form */\n export const stringToPublicKey = (s: string, prefix = 'EOS'): Key => {\n     if (typeof s !== 'string') {\n         throw new Error('expected string containing public key');\n     }\n     if (s.substr(0, 3) === prefix) {\n         const whole = base58ToBinary(publicKeyDataSize + 4, s.substr(3));\n         const key = { type: KeyType.k1, data: new Uint8Array(publicKeyDataSize) };\n         for (let i = 0; i < publicKeyDataSize; ++i) {\n             key.data[i] = whole[i];\n         }\n         const digest = new Uint8Array(ripemd160(key.data));\n         if (digest[0] !== whole[publicKeyDataSize] || digest[1] !== whole[34]\n             || digest[2] !== whole[35] || digest[3] !== whole[36]) {\n             throw new Error('checksum doesn\\'t match');\n         }\n         return key;\n     } else if (s.substr(0, 7) === 'PUB_K1_') {\n         return stringToKey(s.substr(7), KeyType.k1, publicKeyDataSize, 'K1');\n     } else if (s.substr(0, 7) === 'PUB_R1_') {\n         return stringToKey(s.substr(7), KeyType.r1, publicKeyDataSize, 'R1');\n     } else if (s.substr(0, 7) === 'PUB_WA_') {\n         return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');\n     } else {\n         throw new Error('unrecognized public key format');\n     }\n };\n \n /** Convert public `key` to legacy string (base-58) form */\n export const publicKeyToLegacyString = (key: Key, prefix: string = 'EOS') => {\n     if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {\n         return keyToString(key, '', prefix);\n     } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {\n         throw new Error('Key format not supported in legacy conversion');\n     } else {\n         throw new Error('unrecognized public key format');\n     }\n };\n \n /** Convert `key` to string (base-58) form */\n export const publicKeyToString = (key: Key): string => {\n    if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {\n         return keyToString(key, 'K1', 'PUB_K1_');\n     } else if (key.type === KeyType.r1 && key.data.length === publicKeyDataSize) {\n         return keyToString(key, 'R1', 'PUB_R1_');\n     } else if (key.type === KeyType.wa) {\n         return keyToString(key, 'WA', 'PUB_WA_');\n     } else {\n         throw new Error('unrecognized public key format');\n     }\n };\n \n /** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).\n  * Leaves other formats untouched\n  */\n export const convertLegacyPublicKey = (s: string, prefix = 'EOS'): string => {\n     if (s.substr(0, 3) === prefix) {\n         return publicKeyToString(stringToPublicKey(s, prefix));\n     }\n     return s;\n };\n \n /** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).\n  * Leaves other formats untouched\n  */\n export const convertLegacyPublicKeys = (keys: string[], prefix = 'EOS'): string[] => {\n     return keys.map((key: string) => convertLegacyPublicKey(key, prefix));\n };\n \n /** Convert key in `s` to binary form */\n export const stringToPrivateKey = (s: string): Key => {\n     if (typeof s !== 'string') {\n         throw new Error('expected string containing private key');\n     }\n     if (s.substr(0, 7) === 'PVT_R1_') {\n         return stringToKey(s.substr(7), KeyType.r1, privateKeyDataSize, 'R1');\n     } else if (s.substr(0, 7) === 'PVT_K1_') {\n         return stringToKey(s.substr(7), KeyType.k1, privateKeyDataSize, 'K1');\n     } else {\n         // todo: Verify checksum: sha256(sha256(key.data)).\n         //       Not critical since a bad key will fail to produce a\n         //       valid signature anyway.\n         const whole = base58ToBinary(privateKeyDataSize + 5, s);\n         const key = { type: KeyType.k1, data: new Uint8Array(privateKeyDataSize) };\n         if (whole[0] !== 0x80) {\n             throw new Error('unrecognized private key type');\n         }\n         for (let i = 0; i < privateKeyDataSize; ++i) {\n             key.data[i] = whole[i + 1];\n         }\n         return key;\n     }\n };\n \n /** Convert private `key` to legacy string (base-58) form */\n export const privateKeyToLegacyString = (key: Key): string => {\n     if (key.type === KeyType.k1 && key.data.length === privateKeyDataSize) {\n         const whole = [] as number[];\n         whole.push(128);\n         key.data.forEach((byte) => whole.push(byte));\n         const digest = new Uint8Array(\n             sha256().update(\n                 sha256().update(whole).digest()\n             ).digest()\n         );\n \n         const result = new Uint8Array(privateKeyDataSize + 5);\n         for (let i = 0; i < whole.length; i++) {\n             result[i] = whole[i];\n         }\n         for (let i = 0; i < 4; i++) {\n             result[i + whole.length] = digest[i];\n         }\n         return binaryToBase58(result);\n     } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {\n         throw new Error('Key format not supported in legacy conversion');\n     } else {\n         throw new Error('unrecognized public key format');\n     }\n };\n \n /** Convert `key` to string (base-58) form */\n export const privateKeyToString = (key: Key): string => {\n     if (key.type === KeyType.r1) {\n         return keyToString(key, 'R1', 'PVT_R1_');\n     } else if (key.type === KeyType.k1) {\n         return keyToString(key, 'K1', 'PVT_K1_');\n     } else {\n         throw new Error('unrecognized private key format');\n     }\n };\n \n /** Convert key in `s` to binary form */\n export const stringToSignature = (s: string): Key => {\n     if (typeof s !== 'string') {\n         throw new Error('expected string containing signature');\n     }\n     if (s.substr(0, 7) === 'SIG_K1_') {\n         return stringToKey(s.substr(7), KeyType.k1, signatureDataSize, 'K1');\n     } else if (s.substr(0, 7) === 'SIG_R1_') {\n         return stringToKey(s.substr(7), KeyType.r1, signatureDataSize, 'R1');\n     } else if (s.substr(0, 7) === 'SIG_WA_') {\n         return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');\n     } else {\n         throw new Error('unrecognized signature format');\n     }\n };\n \n /** Convert `signature` to string (base-58) form */\n export const signatureToString = (signature: Key): string => {\n     if (signature.type === KeyType.k1) {\n         return keyToString(signature, 'K1', 'SIG_K1_');\n     } else if (signature.type === KeyType.r1) {\n         return keyToString(signature, 'R1', 'SIG_R1_');\n     } else if (signature.type === KeyType.wa) {\n         return keyToString(signature, 'WA', 'SIG_WA_');\n     } else {\n         throw new Error('unrecognized signature format');\n     }\n };\n ","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/**\n * @module Serialize\n */\n/* eslint-disable max-classes-per-file */\n/* eslint-disable jsdoc/check-indentation */\n\nimport * as numeric from './numeric';\nimport { Abi, BlockTaposInfo } from '../rpc/types';\nimport { Query, TransactionHeader } from './types';\nimport 'fast-text-encoding';\n\n/** A field in an abi */\nexport interface Field {\n    /** Field name */\n    name: string;\n\n    /** Type name in string form */\n    typeName: string;\n\n    /** Type of the field */\n    type?: Type;\n}\n\n/** Options for serialize() and deserialize() */\nexport interface SerializerOptions {\n    bytesAsUint8Array?: boolean;\n}\n\n/** State for serialize() and deserialize() */\nexport class SerializerState {\n    public options: SerializerOptions;\n\n    /** Have any binary extensions been skipped? */\n    public skippedBinaryExtension = false;\n\n    constructor(options: SerializerOptions = {}) {\n        this.options = options;\n    }\n}\n\n/**\n * An Anyvar (non-short form) may be any of the following:\n *  * null\n *  * string\n *  * number\n *    * Caution: assumes number is int32. Use {type, value} form for other numeric types\n *  * an array of anyvar\n *  * {type, value}\n *      * type is a string matching one of the predefined types in anyvarDefs\n *      * value:\n *          * If type === 'any_object', then value is an object. The values within the object are anyvar.\n *          * If type === 'any_array', then value is an array of anyvar.\n *          * Else, value must be eosjs-compatible with the specified type (e.g. uint64 should be a string\n *            containing the value in decimal).\n *  * Other object. The values within the object are anyvar.\n *\n * The short form is more convenient, but it can't be converted back to binary (serialized).\n * Wherever the anyvar would have {type, value}, it has just the value instead.\n */\nexport type Anyvar = null | string | number | Anyvar[] | { type: string, value: any } | Record<string, unknown>;\n\ninterface AnyvarDef {\n    index: number;\n    useShortForm: boolean;\n    type: {\n        name: string,\n        serialize(buffer: SerialBuffer, value: any): void,\n        deserialize(buffer: SerialBuffer, state?: SerializerState): any,\n    };\n}\n\n/** A type in an abi */\nexport interface Type {\n    /** Type name */\n    name: string;\n\n    /** Type name this is an alias of, if any */\n    aliasOfName: string;\n\n    /** Type this is an array of, if any */\n    arrayOf?: Type;\n\n    /** Type this is an optional of, if any */\n    optionalOf?: Type;\n\n    /** Marks binary extension fields */\n    extensionOf?: Type;\n\n    /** Base name of this type, if this is a struct */\n    baseName: string;\n\n    /** Base of this type, if this is a struct */\n    base?: Type;\n\n    /** Contained fields, if this is a struct */\n    fields: Field[];\n\n    /** Convert `data` to binary form and store in `buffer` */\n    serialize: (buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean) => void;\n\n    /** Convert data in `buffer` from binary form */\n    deserialize: (buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) => any;\n}\n\n/** Structural representation of a symbol */\nexport interface Symbol {\n    /** Name of the symbol, not including precision */\n    name: string;\n\n    /** Number of digits after the decimal point */\n    precision: number;\n}\n\nexport interface Contract {\n    actions: Map<string, Type>;\n    types: Map<string, Type>;\n}\n\nexport interface Authorization {\n    actor: string;\n    permission: string;\n}\n\n/** Action with data in structured form */\nexport interface Action {\n    account: string;\n    name: string;\n    authorization: Authorization[];\n    data: any;\n    hex_data?: string;\n}\n\n/** Action with data in serialized hex form */\nexport interface SerializedAction {\n    account: string;\n    name: string;\n    authorization: Authorization[];\n    data: string;\n}\n\n/** Serialize and deserialize data */\nexport class SerialBuffer {\n    /** Amount of valid data in `array` */\n    public length: number;\n\n    /** Data in serialized (binary) form */\n    public array: Uint8Array;\n\n    /** Current position while reading (deserializing) */\n    public readPos = 0;\n\n    public textEncoder: TextEncoder;\n    public textDecoder: TextDecoder;\n\n    /**\n     * @param __namedParameters\n     * `array`: `null` if serializing, or binary data to deserialize\n     * `textEncoder`: `TextEncoder` instance to use. Pass in `null` if running in a browser\n     * `textDecoder`: `TextDecider` instance to use. Pass in `null` if running in a browser\n     */\n    constructor({ array, textEncoder, textDecoder } = {} as { array?: Uint8Array, textEncoder?: TextEncoder, textDecoder?: TextDecoder }) {\n        this.array = array || new Uint8Array(1024);\n        this.length = array ? array.length : 0;\n        this.textEncoder = textEncoder || new TextEncoder()\n        this.textDecoder = textDecoder || new TextDecoder('utf-8')\n    }\n\n    /** Resize `array` if needed to have at least `size` bytes free */\n    public reserve(size: number): void {\n        if (this.length + size <= this.array.length) {\n            return;\n        }\n        let l = this.array.length;\n        while (this.length + size > l) {\n            l = Math.ceil(l * 1.5);\n        }\n        const newArray = new Uint8Array(l);\n        newArray.set(this.array);\n        this.array = newArray;\n    }\n\n    /** Is there data available to read? */\n    public haveReadData(): boolean {\n        return this.readPos < this.length;\n    }\n\n    /** Restart reading from the beginning */\n    public restartRead(): void {\n        this.readPos = 0;\n    }\n\n    /** Return data with excess storage trimmed away */\n    public asUint8Array(): Uint8Array {\n        return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);\n    }\n\n    /** Append bytes */\n    public pushArray(v: number[] | Uint8Array): void {\n        this.reserve(v.length);\n        this.array.set(v, this.length);\n        this.length += v.length;\n    }\n\n    /** Append bytes */\n    public push(...v: number[]): void {\n        this.pushArray(v);\n    }\n\n    /** Get a single byte */\n    public get(): number {\n        if (this.readPos < this.length) {\n            return this.array[this.readPos++];\n        }\n        throw new Error('Read past end of buffer');\n    }\n\n    /** Append bytes in `v`. Throws if `len` doesn't match `v.length` */\n    public pushUint8ArrayChecked(v: Uint8Array, len: number): void {\n        if (v.length !== len) {\n            throw new Error('Binary data has incorrect size');\n        }\n        this.pushArray(v);\n    }\n\n    /** Get `len` bytes */\n    public getUint8Array(len: number): Uint8Array {\n        if (this.readPos + len > this.length) {\n            throw new Error('Read past end of buffer');\n        }\n        const result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);\n        this.readPos += len;\n        return result;\n    }\n\n    /** Skip `len` bytes */\n    public skip(len: number): void {\n        if (this.readPos + len > this.length) {\n            throw new Error('Read past end of buffer');\n        }\n        this.readPos += len;\n    }\n\n    /** Append a `uint16` */\n    public pushUint16(v: number): void {\n        this.push((v >> 0) & 0xff, (v >> 8) & 0xff);\n    }\n\n    /** Get a `uint16` */\n    public getUint16(): number {\n        let v = 0;\n        v |= this.get() << 0;\n        v |= this.get() << 8;\n        return v;\n    }\n\n    /** Append a `uint32` */\n    public pushUint32(v: number): void {\n        this.push((v >> 0) & 0xff, (v >> 8) & 0xff, (v >> 16) & 0xff, (v >> 24) & 0xff);\n    }\n\n    /** Get a `uint32` */\n    public getUint32(): number {\n        let v = 0;\n        v |= this.get() << 0;\n        v |= this.get() << 8;\n        v |= this.get() << 16;\n        v |= this.get() << 24;\n        return v >>> 0;\n    }\n\n    /** Append a `uint64`. *Caution*: `number` only has 53 bits of precision */\n    public pushNumberAsUint64(v: number): void {\n        this.pushUint32(v >>> 0);\n        this.pushUint32(Math.floor(v / 0x10000_0000) >>> 0);\n    }\n\n    /**\n     * Get a `uint64` as a `number`. *Caution*: `number` only has 53 bits of precision; some values will change.\n     * `numeric.binaryToDecimal(serialBuffer.getUint8Array(8))` recommended instead\n     */\n    public getUint64AsNumber(): number {\n        const low = this.getUint32();\n        const high = this.getUint32();\n        return (high >>> 0) * 0x10000_0000 + (low >>> 0);\n    }\n\n    /** Append a `varuint32` */\n    public pushVaruint32(v: number): void {\n        while (true) {\n            if (v >>> 7) {\n                this.push(0x80 | (v & 0x7f));\n                v = v >>> 7;\n            } else {\n                this.push(v);\n                break;\n            }\n        }\n    }\n\n    /** Get a `varuint32` */\n    public getVaruint32(): number {\n        let v = 0;\n        let bit = 0;\n        while (true) {\n            const b = this.get();\n            v |= (b & 0x7f) << bit;\n            bit += 7;\n            if (!(b & 0x80)) {\n                break;\n            }\n        }\n        return v >>> 0;\n    }\n\n    /** Append a `varint32` */\n    public pushVarint32(v: number): void {\n        this.pushVaruint32((v << 1) ^ (v >> 31));\n    }\n\n    /** Get a `varint32` */\n    public getVarint32(): number {\n        const v = this.getVaruint32();\n        if (v & 1) {\n            return ((~v) >> 1) | 0x8000_0000;\n        } else {\n            return v >>> 1;\n        }\n    }\n\n    /** Append a `float32` */\n    public pushFloat32(v: number): void {\n        this.pushArray(new Uint8Array((new Float32Array([v])).buffer));\n    }\n\n    /** Get a `float32` */\n    public getFloat32(): number {\n        return new Float32Array(this.getUint8Array(4).slice().buffer)[0];\n    }\n\n    /** Append a `float64` */\n    public pushFloat64(v: number): void {\n        this.pushArray(new Uint8Array((new Float64Array([v])).buffer));\n    }\n\n    /** Get a `float64` */\n    public getFloat64(): number {\n        return new Float64Array(this.getUint8Array(8).slice().buffer)[0];\n    }\n\n    /** Append a `name` */\n    public pushName(s: string): void {\n        if (typeof s !== 'string') {\n            throw new Error('Expected string containing name');\n        }\n        const regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);\n        if (!regex.test(s)) {\n            throw new Error('Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz'); // eslint-disable-line\n        }\n        const charToSymbol = (c: number): number => {\n            if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {\n                return (c - 'a'.charCodeAt(0)) + 6;\n            }\n            if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {\n                return (c - '1'.charCodeAt(0)) + 1;\n            }\n            return 0;\n        };\n        const a = new Uint8Array(8);\n        let bit = 63;\n        for (let i = 0; i < s.length; ++i) {\n            let c = charToSymbol(s.charCodeAt(i));\n            if (bit < 5) {\n                c = c << 1;\n            }\n            for (let j = 4; j >= 0; --j) {\n                if (bit >= 0) {\n                    a[Math.floor(bit / 8)] |= ((c >> j) & 1) << (bit % 8);\n                    --bit;\n                }\n            }\n        }\n        this.pushArray(a);\n    }\n\n    /** Get a `name` */\n    public getName(): string {\n        const a = this.getUint8Array(8);\n        let result = '';\n        for (let bit = 63; bit >= 0;) {\n            let c = 0;\n            for (let i = 0; i < 5; ++i) {\n                if (bit >= 0) {\n                    c = (c << 1) | ((a[Math.floor(bit / 8)] >> (bit % 8)) & 1);\n                    --bit;\n                }\n            }\n            if (c >= 6) {\n                result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);\n            } else if (c >= 1) {\n                result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);\n            } else {\n                result += '.';\n            }\n        }\n        while (result.endsWith('.')) {\n            result = result.substr(0, result.length - 1);\n        }\n        return result;\n    }\n\n    /** Append length-prefixed binary data */\n    public pushBytes(v: number[] | Uint8Array): void {\n        this.pushVaruint32(v.length);\n        this.pushArray(v);\n    }\n\n    /** Get length-prefixed binary data */\n    public getBytes(): Uint8Array {\n        return this.getUint8Array(this.getVaruint32());\n    }\n\n    /** Append a string */\n    public pushString(v: string): void {\n        this.pushBytes(this.textEncoder.encode(v));\n    }\n\n    /** Get a string */\n    public getString(): string {\n        return this.textDecoder.decode(this.getBytes());\n    }\n\n    /** Append a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */\n    public pushSymbolCode(name: string): void {\n        if (typeof name !== 'string') {\n            throw new Error('Expected string containing symbol_code');\n        }\n        const a = [];\n        a.push(...this.textEncoder.encode(name));\n        while (a.length < 8) {\n            a.push(0);\n        }\n        this.pushArray(a.slice(0, 8));\n    }\n\n    /** Get a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */\n    public getSymbolCode(): string {\n        const a = this.getUint8Array(8);\n        let len;\n        for (len = 0; len < a.length; ++len) {\n            if (!a[len]) {\n                break;\n            }\n        }\n        const name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));\n        return name;\n    }\n\n    /** Append a `symbol` */\n    public pushSymbol({ name, precision }: { name: string, precision: number }): void {\n        if (!/^[A-Z]{1,7}$/.test(name)) {\n            throw new Error('Expected symbol to be A-Z and between one and seven characters');\n        }\n        const a = [precision & 0xff];\n        a.push(...this.textEncoder.encode(name));\n        while (a.length < 8) {\n            a.push(0);\n        }\n        this.pushArray(a.slice(0, 8));\n    }\n\n    /** Get a `symbol` */\n    public getSymbol(): { name: string, precision: number } {\n        const precision = this.get();\n        const a = this.getUint8Array(7);\n        let len;\n        for (len = 0; len < a.length; ++len) {\n            if (!a[len]) {\n                break;\n            }\n        }\n        const name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));\n        return { name, precision };\n    }\n\n    /** Append an asset */\n    public pushAsset(s: string): void {\n        if (typeof s !== 'string') {\n            throw new Error('Expected string containing asset');\n        }\n        s = s.trim();\n        let pos = 0;\n        let amount = '';\n        let precision = 0;\n        if (s[pos] === '-') {\n            amount += '-';\n            ++pos;\n        }\n        let foundDigit = false;\n        while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {\n            foundDigit = true;\n            amount += s[pos];\n            ++pos;\n        }\n        if (!foundDigit) {\n            throw new Error('Asset must begin with a number');\n        }\n        if (s[pos] === '.') {\n            ++pos;\n            while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {\n                amount += s[pos];\n                ++precision;\n                ++pos;\n            }\n        }\n        const name = s.substr(pos).trim();\n        this.pushArray(numeric.signedDecimalToBinary(8, amount));\n        this.pushSymbol({ name, precision });\n    }\n\n    /** Get an asset */\n    public getAsset(): string {\n        const amount = this.getUint8Array(8);\n        const { name, precision } = this.getSymbol();\n        let s = numeric.signedBinaryToDecimal(amount, precision + 1);\n        if (precision) {\n            s = s.substr(0, s.length - precision) + '.' + s.substr(s.length - precision);\n        }\n        return s + ' ' + name;\n    }\n\n    /** Append a public key */\n    public pushPublicKey(s: string): void {\n        const key = numeric.stringToPublicKey(s);\n        this.push(key.type);\n        this.pushArray(key.data);\n    }\n\n    /** Get a public key */\n    public getPublicKey(): string {\n        const type = this.get();\n        let data: Uint8Array;\n        if (type === numeric.KeyType.wa) {\n            const begin = this.readPos;\n            this.skip(34);\n            this.skip(this.getVaruint32());\n            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);\n        } else {\n            data = this.getUint8Array(numeric.publicKeyDataSize);\n        }\n        return numeric.publicKeyToString({ type, data });\n    }\n\n    /** Append a private key */\n    public pushPrivateKey(s: string): void {\n        const key = numeric.stringToPrivateKey(s);\n        this.push(key.type);\n        this.pushArray(key.data);\n    }\n\n    /** Get a private key */\n    public getPrivateKey(): string {\n        const type = this.get();\n        const data = this.getUint8Array(numeric.privateKeyDataSize);\n        return numeric.privateKeyToString({ type, data });\n    }\n\n    /** Append a signature */\n    public pushSignature(s: string): void {\n        const key = numeric.stringToSignature(s);\n        this.push(key.type);\n        this.pushArray(key.data);\n    }\n\n    /** Get a signature */\n    public getSignature(): string {\n        const type = this.get();\n        let data: Uint8Array;\n        if (type === numeric.KeyType.wa) {\n            const begin = this.readPos;\n            this.skip(65);\n            this.skip(this.getVaruint32());\n            this.skip(this.getVaruint32());\n            data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);\n        } else {\n            data = this.getUint8Array(numeric.signatureDataSize);\n        }\n        return numeric.signatureToString({ type, data });\n    }\n} // SerialBuffer\n\n/** Is this a supported ABI version? */\nexport const supportedAbiVersion = (version: string): boolean => {\n    return version.startsWith('eosio::abi/1.');\n};\n\nconst checkDateParse = (date: string): number => {\n    const result = Date.parse(date);\n    if (Number.isNaN(result)) {\n        throw new Error('Invalid time format');\n    }\n    return result;\n};\n\n/** Convert date in ISO format to `time_point` (miliseconds since epoch) */\nexport const dateToTimePoint = (date: string): number => {\n    return Math.round(checkDateParse(date + 'Z') * 1000);\n};\n\n/** Convert `time_point` (miliseconds since epoch) to date in ISO format */\nexport const timePointToDate = (us: number): string => {\n    const s = (new Date(us / 1000)).toISOString();\n    return s.substr(0, s.length - 1);\n};\n\n/** Convert date in ISO format to `time_point_sec` (seconds since epoch) */\nexport const dateToTimePointSec = (date: string): number => {\n    return Math.round(checkDateParse(date + 'Z') / 1000);\n};\n\n/** Convert `time_point_sec` (seconds since epoch) to to date in ISO format */\nexport const timePointSecToDate = (sec: number): string => {\n    const s = (new Date(sec * 1000)).toISOString();\n    return s.substr(0, s.length - 1);\n};\n\n/** Convert date in ISO format to `block_timestamp_type` (half-seconds since a different epoch) */\nexport const dateToBlockTimestamp = (date: string): number => {\n    return Math.round((checkDateParse(date + 'Z') - 946684800000) / 500);\n};\n\n/** Convert `block_timestamp_type` (half-seconds since a different epoch) to to date in ISO format */\nexport const blockTimestampToDate = (slot: number): string => {\n    const s = (new Date(slot * 500 + 946684800000)).toISOString();\n    return s.substr(0, s.length - 1);\n};\n\n/** Convert `string` to `Symbol`. format: `precision,NAME`. */\nexport const stringToSymbol = (s: string): { name: string, precision: number } => {\n    if (typeof s !== 'string') {\n        throw new Error('Expected string containing symbol');\n    }\n    const m = s.match(/^([0-9]+),([A-Z]+)$/);\n    if (!m) {\n        throw new Error('Invalid symbol');\n    }\n    return { name: m[2], precision: +m[1] };\n};\n\n/** Convert `Symbol` to `string`. format: `precision,NAME`. */\nexport const symbolToString = ({ name, precision }: { name: string, precision: number }): string => {\n    return precision + ',' + name;\n};\n\n/** Convert binary data to hex */\nexport const arrayToHex = (data: Uint8Array): string => {\n    let result = '';\n    for (const x of data) {\n        result += ('00' + x.toString(16)).slice(-2);\n    }\n    return result.toUpperCase();\n};\n\n/** Convert hex to binary data */\nexport const hexToUint8Array = (hex: string): Uint8Array => {\n    if (typeof hex !== 'string') {\n        throw new Error('Expected string containing hex digits');\n    }\n    if (hex.length % 2) {\n        throw new Error('Odd number of hex digits');\n    }\n    const l = hex.length / 2;\n    const result = new Uint8Array(l);\n    for (let i = 0; i < l; ++i) {\n        const x = parseInt(hex.substr(i * 2, 2), 16);\n        if (Number.isNaN(x)) {\n            throw new Error('Expected hex string');\n        }\n        result[i] = x;\n    }\n    return result;\n};\n\nfunction serializeUnknown(this: Type, _: SerialBuffer, __: any): SerialBuffer {\n    throw new Error('Don\\'t know how to serialize ' + this.name);\n}\n\nfunction deserializeUnknown(this: Type, _: SerialBuffer): SerialBuffer {\n    throw new Error('Don\\'t know how to deserialize ' + this.name);\n}\n\nfunction serializeStruct(\n    this: Type, buffer: SerialBuffer, data: any, state = new SerializerState(), allowExtensions = true\n): void {\n    if (typeof data !== 'object') {\n        throw new Error('expected object containing data: ' + JSON.stringify(data));\n    }\n    if (this.base) {\n        this.base.serialize(buffer, data, state, allowExtensions);\n    }\n    for (const field of this.fields) {\n        if (field.name in data) {\n            if (state.skippedBinaryExtension) {\n                throw new Error('unexpected ' + this.name + '.' + field.name);\n            }\n            field.type!.serialize(\n                buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);\n        } else {\n            if (allowExtensions && field.type!.extensionOf) {\n                state.skippedBinaryExtension = true;\n            } else {\n                throw new Error('missing ' + this.name + '.' + field.name + ' (type=' + field.type!.name + ')');\n            }\n        }\n    }\n}\n\nfunction deserializeStruct(this: Type, buffer: SerialBuffer, state = new SerializerState(), allowExtensions = true): any {\n    let result;\n    if (this.base) {\n        result = this.base.deserialize(buffer, state, allowExtensions);\n    } else {\n        result = {};\n    }\n    for (const field of this.fields) {\n        if (allowExtensions && field.type!.extensionOf && !buffer.haveReadData()) {\n            state.skippedBinaryExtension = true;\n        } else {\n            result[field.name] = field.type!.deserialize(buffer, state, allowExtensions);\n        }\n    }\n    return result;\n}\n\nfunction serializeVariant(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n): void {\n    if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== 'string') {\n        throw new Error('expected variant: [\"type\", value]');\n    }\n    const i = this.fields.findIndex((field: Field) => field.name === data[0]);\n    if (i < 0) {\n        throw new Error(`type \"${data[0]}\" is not valid for variant`);\n    }\n    buffer.pushVaruint32(i);\n    this.fields[i].type!.serialize(buffer, data[1], state, allowExtensions);\n}\n\nfunction deserializeVariant(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any[] {\n    const i = buffer.getVaruint32();\n    if (i >= this.fields.length) {\n        throw new Error(`type index ${i} is not valid for variant`);\n    }\n    const field = this.fields[i];\n    return [field.name, field.type!.deserialize(buffer, state, allowExtensions)];\n}\n\nfunction serializeArray(\n    this: Type, buffer: SerialBuffer, data: any[], state?: SerializerState, _?: boolean\n): void {\n    buffer.pushVaruint32(data.length);\n    for (const item of data) {\n        this.arrayOf!.serialize(buffer, item, state, false);\n    }\n}\n\nfunction deserializeArray(this: Type, buffer: SerialBuffer, state?: SerializerState, _?: boolean): any[] {\n    const len = buffer.getVaruint32();\n    const result = [];\n    for (let i = 0; i < len; ++i) {\n        result.push(this.arrayOf!.deserialize(buffer, state, false));\n    }\n    return result;\n}\n\nfunction serializeOptional(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n): void {\n    if (data === null || data === undefined) {\n        buffer.push(0);\n    } else {\n        buffer.push(1);\n        this.optionalOf!.serialize(buffer, data, state, allowExtensions);\n    }\n}\n\nfunction deserializeOptional(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any {\n    if (buffer.get()) {\n        return this.optionalOf!.deserialize(buffer, state, allowExtensions);\n    } else {\n        return null;\n    }\n}\n\nfunction serializeExtension(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n): void {\n    this.extensionOf!.serialize(buffer, data, state, allowExtensions);\n}\n\nfunction deserializeExtension(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any {\n    return this.extensionOf!.deserialize(buffer, state, allowExtensions);\n}\n\nfunction serializeObject(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n    ): void {\n    const entries = Object.entries(data);\n    buffer.pushVaruint32(entries.length);\n    for (const [key, value] of entries) {\n        const keyType = this.fields[0].type;\n        const dataType = this.fields[1].type;\n        keyType!.serialize(buffer, key, state, allowExtensions);\n        dataType!.serialize(buffer, value, state, allowExtensions);\n    }\n}\n\nfunction deserializeObject(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any {\n    const len = buffer.getVaruint32();\n    const result = {} as any;\n    for (let i = 0; i < len; ++i) {\n        const keyType = this.fields[0].type;\n        const dataType = this.fields[1].type;\n        const key = keyType!.deserialize(buffer, state, allowExtensions);\n        (result as any)[key] = dataType!.deserialize(buffer, state, allowExtensions);\n    }\n    return result;\n}\n\nfunction serializePair(\n    this: Type, buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean\n): void {\n    buffer.pushVaruint32(data.length);\n    data.forEach((item: [number, string]) => {\n        this.fields[0].type!.serialize(buffer, item[0], state, allowExtensions);\n        this.fields[1].type!.serialize(buffer, item[1], state, allowExtensions);\n    });\n}\n\nfunction deserializePair(this: Type, buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean): any {\n    const result = [] as any;\n    const len = buffer.getVaruint32();\n    for (let i = 0; i < len; ++i) {\n        result.push(this.fields[0].type!.deserialize(buffer, state, allowExtensions));\n        result.push(this.fields[1].type!.deserialize(buffer, state, allowExtensions));\n    }\n    return result;\n}\n\ninterface CreateTypeArgs {\n    name?: string;\n    aliasOfName?: string;\n    arrayOf?: Type;\n    optionalOf?: Type;\n    extensionOf?: Type;\n    baseName?: string;\n    base?: Type;\n    fields?: Field[];\n    serialize?: (buffer: SerialBuffer, data: any, state?: SerializerState, allowExtensions?: boolean) => void;\n    deserialize?: (buffer: SerialBuffer, state?: SerializerState, allowExtensions?: boolean) => any;\n}\n\nconst createType = (attrs: CreateTypeArgs): Type => {\n    return {\n        name: '<missing name>',\n        aliasOfName: '',\n        arrayOf: undefined,\n        optionalOf: undefined,\n        extensionOf: undefined,\n        baseName: '',\n        base: undefined,\n        fields: [],\n        serialize: serializeUnknown,\n        deserialize: deserializeUnknown,\n        ...attrs,\n    };\n};\n\nconst checkRange = (orig: number, converted: number) => {\n    if (Number.isNaN(+orig) || Number.isNaN(+converted) || (typeof orig !== 'number' && typeof orig !== 'string')) {\n        throw new Error('Expected number');\n    }\n    if (+orig !== +converted) {\n        throw new Error('Number is out of range');\n    }\n    return +orig;\n};\n\n/** Create the set of types built-in to the abi format */\nexport const createInitialTypes = (): Map<string, Type> => {\n    const result: Map<string, Type> = new Map(Object.entries({\n        bool: createType({\n            name: 'bool',\n            serialize: (buffer: SerialBuffer, data: boolean) => {\n                if ( !(typeof data === 'boolean' || typeof data === 'number' && ( data === 1 || data === 0))) {\n                    throw new Error('Expected boolean or number equal to 1 or 0');\n                }\n                buffer.push(data ? 1 : 0);\n            },\n            deserialize: (buffer: SerialBuffer) => { return !!buffer.get(); },\n        }),\n        uint8: createType({\n            name: 'uint8',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.push(checkRange(data, data & 0xff)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.get(); },\n        }),\n        int8: createType({\n            name: 'int8',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.push(checkRange(data, data << 24 >> 24)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.get() << 24 >> 24; },\n        }),\n        uint16: createType({\n            name: 'uint16',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint16(checkRange(data, data & 0xffff)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint16(); },\n        }),\n        int16: createType({\n            name: 'int16',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint16(checkRange(data, data << 16 >> 16)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint16() << 16 >> 16; },\n        }),\n        uint32: createType({\n            name: 'uint32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint32(checkRange(data, data >>> 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint32(); },\n        }),\n        uint64: createType({\n            name: 'uint64',\n            serialize: (buffer: SerialBuffer, data: string | number) => {\n                buffer.pushArray(numeric.decimalToBinary(8, '' + data));\n            },\n            deserialize: (buffer: SerialBuffer) => { return numeric.binaryToDecimal(buffer.getUint8Array(8)); },\n        }),\n        int64: createType({\n            name: 'int64',\n            serialize: (buffer: SerialBuffer, data: string | number) => {\n                buffer.pushArray(numeric.signedDecimalToBinary(8, '' + data));\n            },\n            deserialize: (buffer: SerialBuffer) => { return numeric.signedBinaryToDecimal(buffer.getUint8Array(8)); },\n        }),\n        int32: createType({\n            name: 'int32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushUint32(checkRange(data, data | 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getUint32() | 0; },\n        }),\n        varuint32: createType({\n            name: 'varuint32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushVaruint32(checkRange(data, data >>> 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getVaruint32(); },\n        }),\n        varint32: createType({\n            name: 'varint32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushVarint32(checkRange(data, data | 0)); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getVarint32(); },\n        }),\n        uint128: createType({\n            name: 'uint128',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushArray(numeric.decimalToBinary(16, '' + data)); },\n            deserialize: (buffer: SerialBuffer) => { return numeric.binaryToDecimal(buffer.getUint8Array(16)); },\n        }),\n        int128: createType({\n            name: 'int128',\n            serialize: (buffer: SerialBuffer, data: string) => {\n                buffer.pushArray(numeric.signedDecimalToBinary(16, '' + data));\n            },\n            deserialize: (buffer: SerialBuffer) => { return numeric.signedBinaryToDecimal(buffer.getUint8Array(16)); },\n        }),\n        float32: createType({\n            name: 'float32',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushFloat32(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getFloat32(); },\n        }),\n        float64: createType({\n            name: 'float64',\n            serialize: (buffer: SerialBuffer, data: number) => { buffer.pushFloat64(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getFloat64(); },\n        }),\n        float128: createType({\n            name: 'float128',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(16)); },\n        }),\n\n        bytes: createType({\n            name: 'bytes',\n            serialize: (buffer: SerialBuffer, data: string | Uint8Array | number[]) => {\n                if (data instanceof Uint8Array || Array.isArray(data)) {\n                    buffer.pushBytes(data);\n                } else {\n                    buffer.pushBytes(hexToUint8Array(data));\n                }\n            },\n            deserialize: (buffer: SerialBuffer, state?: SerializerState) => {\n                if (state && state.options.bytesAsUint8Array) {\n                    return buffer.getBytes();\n                } else {\n                    return arrayToHex(buffer.getBytes());\n                }\n            },\n        }),\n        string: createType({\n            name: 'string',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushString(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getString(); },\n        }),\n        name: createType({\n            name: 'name',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushName(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getName(); },\n        }),\n        time_point: createType({\n            name: 'time_point',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushNumberAsUint64(dateToTimePoint(data)); },\n            deserialize: (buffer: SerialBuffer) => { return timePointToDate(buffer.getUint64AsNumber()); },\n        }),\n        time_point_sec: createType({\n            name: 'time_point_sec',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint32(dateToTimePointSec(data)); },\n            deserialize: (buffer: SerialBuffer) => { return timePointSecToDate(buffer.getUint32()); },\n        }),\n        block_timestamp_type: createType({\n            name: 'block_timestamp_type',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint32(dateToBlockTimestamp(data)); },\n            deserialize: (buffer: SerialBuffer) => { return blockTimestampToDate(buffer.getUint32()); },\n        }),\n        symbol_code: createType({\n            name: 'symbol_code',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushSymbolCode(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getSymbolCode(); },\n        }),\n        symbol: createType({\n            name: 'symbol',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushSymbol(stringToSymbol(data)); },\n            deserialize: (buffer: SerialBuffer) => { return symbolToString(buffer.getSymbol()); },\n        }),\n        asset: createType({\n            name: 'asset',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushAsset(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getAsset(); },\n        }),\n        checksum160: createType({\n            name: 'checksum160',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(20)); },\n        }),\n        checksum256: createType({\n            name: 'checksum256',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(32)); },\n        }),\n        checksum512: createType({\n            name: 'checksum512',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64); },\n            deserialize: (buffer: SerialBuffer) => { return arrayToHex(buffer.getUint8Array(64)); },\n        }),\n        public_key: createType({\n            name: 'public_key',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushPublicKey(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getPublicKey(); },\n        }),\n        private_key: createType({\n            name: 'private_key',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushPrivateKey(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getPrivateKey(); },\n        }),\n        signature: createType({\n            name: 'signature',\n            serialize: (buffer: SerialBuffer, data: string) => { buffer.pushSignature(data); },\n            deserialize: (buffer: SerialBuffer) => { return buffer.getSignature(); },\n        }),\n    }));\n\n    result.set('extended_asset', createType({\n        name: 'extended_asset',\n        baseName: '',\n        fields: [\n            { name: 'quantity', typeName: 'asset', type: result.get('asset') },\n            { name: 'contract', typeName: 'name', type: result.get('name') },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n\n    return result;\n}; // createInitialTypes()\n\nexport const createAbiTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('extensions_entry', createType({\n        name: 'extensions_entry',\n        baseName: '',\n        fields: [\n            { name: 'tag', typeName: 'uint16', type: undefined },\n            { name: 'value', typeName: 'bytes', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('type_def', createType({\n        name: 'type_def',\n        baseName: '',\n        fields: [\n            { name: 'new_type_name', typeName: 'string', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('field_def', createType({\n        name: 'field_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'string', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('struct_def', createType({\n        name: 'struct_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'string', type: undefined },\n            { name: 'base', typeName: 'string', type: undefined },\n            { name: 'fields', typeName: 'field_def[]', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('action_def', createType({\n        name: 'action_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined },\n            { name: 'ricardian_contract', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('table_def', createType({\n        name: 'table_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'index_type', typeName: 'string', type: undefined },\n            { name: 'key_names', typeName: 'string[]', type: undefined },\n            { name: 'key_types', typeName: 'string[]', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('clause_pair', createType({\n        name: 'clause_pair',\n        baseName: '',\n        fields: [\n            { name: 'id', typeName: 'string', type: undefined },\n            { name: 'body', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('error_message', createType({\n        name: 'error_message',\n        baseName: '',\n        fields: [\n            { name: 'error_code', typeName: 'uint64', type: undefined },\n            { name: 'error_msg', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('variant_def', createType({\n        name: 'variant_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'string', type: undefined },\n            { name: 'types', typeName: 'string[]', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('action_result', createType({\n        name: 'action_result',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'result_type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('primary_key_index_def', createType({\n        name: 'primary_key_index_def',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'type', typeName: 'string', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('secondary_index_def', createType({\n        name: 'secondary_index_def',\n        baseName: '',\n        fields: [\n            { name: 'type', typeName: 'string', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('secondary_indices', createType({\n        name: 'secondary_indices',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'secondary_index_def', typeName: 'secondary_index_def', type: undefined }\n        ],\n        serialize: serializeObject,\n        deserialize: deserializeObject,\n    }));\n    initialTypes.set('kv_table_entry_def', createType({\n        name: 'kv_table_entry_def',\n        baseName: '',\n        fields: [\n            { name: 'type', typeName: 'string', type: undefined },\n            { name: 'primary_index', typeName: 'primary_key_index_def', type: undefined },\n            { name: 'secondary_indices', typeName: 'secondary_indices', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('kv_table', createType({\n        name: 'kv_table',\n        baseName: '',\n        fields: [\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'kv_table_entry_def', typeName: 'kv_table_entry_def', type: undefined }\n        ],\n        serialize: serializeObject,\n        deserialize: deserializeObject\n    }));\n    initialTypes.set('abi_def', createType({\n        name: 'abi_def',\n        baseName: '',\n        fields: [\n            { name: 'version', typeName: 'string', type: undefined },\n            { name: 'types', typeName: 'type_def[]', type: undefined },\n            { name: 'structs', typeName: 'struct_def[]', type: undefined },\n            { name: 'actions', typeName: 'action_def[]', type: undefined },\n            { name: 'tables', typeName: 'table_def[]', type: undefined },\n            { name: 'ricardian_clauses', typeName: 'clause_pair[]', type: undefined },\n            { name: 'error_messages', typeName: 'error_message[]', type: undefined },\n            { name: 'abi_extensions', typeName: 'extensions_entry[]', type: undefined },\n            { name: 'variants', typeName: 'variant_def[]$', type: undefined },\n            { name: 'action_results', typeName: 'action_result[]$', type: undefined },\n            { name: 'kv_tables', typeName: 'kv_table$', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    return initialTypes;\n};\n\n\nexport const createTransactionExtensionTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('resource_payer', createType({\n        name: 'resource_payer',\n        baseName: '',\n        fields: [\n            { name: 'payer', typeName: 'name', type: undefined },\n            { name: 'max_net_bytes', typeName: 'uint64', type: undefined },\n            { name: 'max_cpu_us', typeName: 'uint64', type: undefined },\n            { name: 'max_memory_bytes', typeName: 'uint64', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    return initialTypes;\n};\n\nexport const createTransactionTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('permission_level', createType({\n        name: 'permission_level',\n        baseName: '',\n        fields: [\n            { name: 'actor', typeName: 'name', type: undefined },\n            { name: 'permission', typeName: 'name', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('action', createType({\n        name: 'action',\n        baseName: '',\n        fields: [\n            { name: 'account', typeName: 'name', type: undefined },\n            { name: 'name', typeName: 'name', type: undefined },\n            { name: 'authorization', typeName: 'permission_level[]', type: undefined },\n            { name: 'data', typeName: 'bytes', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('extension', createType({\n        name: 'extension',\n        baseName: '',\n        fields: [\n            { name: 'type', typeName: 'uint16', type: undefined },\n            { name: 'data', typeName: 'bytes', type: undefined },\n        ],\n        serialize: serializePair,\n        deserialize: deserializePair,\n    }));\n    initialTypes.set('transaction_header', createType({\n        name: 'transaction_header',\n        baseName: '',\n        fields: [\n            { name: 'expiration', typeName: 'time_point_sec', type: undefined },\n            { name: 'ref_block_num', typeName: 'uint16', type: undefined },\n            { name: 'ref_block_prefix', typeName: 'uint32', type: undefined },\n            { name: 'max_net_usage_words', typeName: 'varuint32', type: undefined },\n            { name: 'max_cpu_usage_ms', typeName: 'uint8', type: undefined },\n            { name: 'delay_sec', typeName: 'varuint32', type: undefined },\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    initialTypes.set('transaction', createType({\n        name: 'transaction',\n        baseName: 'transaction_header',\n        fields: [\n            { name: 'context_free_actions', typeName: 'action[]', type: undefined },\n            { name: 'actions', typeName: 'action[]', type: undefined },\n            { name: 'transaction_extensions', typeName: 'extension', type: undefined }\n        ],\n        serialize: serializeStruct,\n        deserialize: deserializeStruct,\n    }));\n    return initialTypes;\n};\n\n/** Get type from `types` */\nexport const getType = (types: Map<string, Type>, name: string): Type => {\n    const type = types.get(name);\n    if (type && type.aliasOfName) {\n        return getType(types, type.aliasOfName);\n    }\n    if (type) {\n        return type;\n    }\n    if (name.endsWith('[]')) {\n        return createType({\n            name,\n            arrayOf: getType(types, name.substr(0, name.length - 2)),\n            serialize: serializeArray,\n            deserialize: deserializeArray,\n        });\n    }\n    if (name.endsWith('?')) {\n        return createType({\n            name,\n            optionalOf: getType(types, name.substr(0, name.length - 1)),\n            serialize: serializeOptional,\n            deserialize: deserializeOptional,\n        });\n    }\n    if (name.endsWith('$')) {\n        return createType({\n            name,\n            extensionOf: getType(types, name.substr(0, name.length - 1)),\n            serialize: serializeExtension,\n            deserialize: deserializeExtension,\n        });\n    }\n    throw new Error('Unknown type: ' + name);\n};\n\n/**\n * Get types from abi\n *\n * @param initialTypes Set of types to build on.\n * In most cases, it's best to fill this from a fresh call to `getTypesFromAbi()`.\n */\n export const getTypesFromAbi = (initialTypes: Map<string, Type>, abi?: Abi): Map<string, Type> => {\n    const types = new Map(initialTypes);\n    if (abi && abi.types) {\n        for (const { new_type_name, type } of abi.types) {\n            types.set(new_type_name,\n                createType({ name: new_type_name, aliasOfName: type }));\n        }\n    }\n    if (abi && abi.structs) {\n        for (const { name, base, fields } of abi.structs) {\n            types.set(name, createType({\n                name,\n                baseName: base,\n                fields: fields.map(({ name: n, type }) => ({ name: n, typeName: type, type: undefined })),\n                serialize: serializeStruct,\n                deserialize: deserializeStruct,\n            }));\n        }\n    }\n    if (abi && abi.variants) {\n        for (const { name, types: t } of abi.variants) {\n            types.set(name, createType({\n                name,\n                fields: t.map((s) => ({ name: s, typeName: s, type: undefined })),\n                serialize: serializeVariant,\n                deserialize: deserializeVariant,\n            }));\n        }\n    }\n    for (const [/*name*/ _, type] of types) {\n        if (type.baseName) {\n            type.base = getType(types, type.baseName);\n        }\n        for (const field of type.fields) {\n            field.type = getType(types, field.typeName);\n        }\n    }\n    return types;\n}; // getTypesFromAbi\n\nconst reverseHex = (h: string): string => {\n    return h.substr(6, 2) + h.substr(4, 2) + h.substr(2, 2) + h.substr(0, 2);\n};\n\n/** TAPoS: Return transaction fields which reference `refBlock` and expire `expireSeconds` after `timestamp` */\nexport const transactionHeader = (refBlock: BlockTaposInfo, expireSeconds: number): TransactionHeader => {\n    const timestamp = refBlock.header ? refBlock.header.timestamp : refBlock.timestamp;\n    const prefix = parseInt(reverseHex(refBlock.id.substr(16, 8)), 16);\n\n    return {\n        expiration: timePointSecToDate(dateToTimePointSec(timestamp as string) + expireSeconds),\n        ref_block_num: refBlock.block_num & 0xffff,\n        ref_block_prefix: prefix,\n    };\n};\n\n/** Convert action data to serialized form (hex) */\nexport const serializeActionData = (\n    contract: Contract, account: string, name: string, data: any\n): string => {\n    const action = contract.actions.get(name);\n    if (!action) {\n        throw new Error(`Unknown action ${name} in contract ${account}`);\n    }\n    const buffer = new SerialBuffer();\n    action.serialize(buffer, data);\n    return arrayToHex(buffer.asUint8Array());\n};\n\n/** Return action in serialized form */\nexport const serializeAction = (\n    contract: Contract, account: string, name: string, authorization: Authorization[],\n    data: any\n): SerializedAction => {\n    return {\n        account,\n        name,\n        authorization,\n        data: serializeActionData(contract, account, name, data),\n    };\n};\n\n/** Deserialize action data. If `data` is a `string`, then it's assumed to be in hex. */\nexport const deserializeActionData = (\n    contract: Contract, account: string, name: string, data: string | Uint8Array | number[],\n): any => {\n    const action = contract.actions.get(name);\n    if (typeof data === 'string') {\n        data = hexToUint8Array(data);\n    }\n    if (!action) {\n        throw new Error(`Unknown action ${name} in contract ${account}`);\n    }\n    const buffer = new SerialBuffer();\n    buffer.pushArray(data);\n    return action.deserialize(buffer);\n};\n\n/** Deserialize action. If `data` is a `string`, then it's assumed to be in hex. */\nexport const deserializeAction = (\n    contract: Contract, account: string, name: string, authorization: Authorization[],\n    data: string | Uint8Array | number[]\n): Action => {\n    return {\n        account,\n        name,\n        authorization,\n        data: deserializeActionData(contract, account, name, data),\n    };\n};\n\nexport const serializeAnyvar = (buffer: SerialBuffer, anyvar: Anyvar): void => {\n    let def: AnyvarDef;\n    let value: any;\n    if (anyvar === null) {\n        [def, value] = [anyvarDefs.null_t, anyvar] as any;\n    } else if (typeof anyvar === 'string') {\n        [def, value] = [anyvarDefs.string, anyvar] as any;\n    } else if (typeof anyvar === 'number') {\n        [def, value] = [anyvarDefs.int32, anyvar] as any;\n    } else if (anyvar instanceof Uint8Array) {\n        [def, value] = [anyvarDefs.bytes, anyvar] as any;\n    } else if (Array.isArray(anyvar)) {\n        [def, value] = [anyvarDefs.any_array, anyvar] as any;\n    } else if (Object.keys(anyvar).length === 2 && anyvar.hasOwnProperty('type') && anyvar.hasOwnProperty('value')) {\n        [def, value] = [(anyvarDefs as any)[(anyvar as any).type] as AnyvarDef, (anyvar as any).value];\n    } else {\n        [def, value] = [anyvarDefs.any_object, anyvar] as any;\n    }\n    buffer.pushVaruint32(def.index);\n    def.type.serialize(buffer, value);\n};\n\nexport const deserializeAnyvar = (buffer: SerialBuffer, state?: SerializerState): any => {\n    const defIndex = buffer.getVaruint32();\n    if (defIndex >= anyvarDefsByIndex.length) {\n        throw new Error('Tried to deserialize unknown anyvar type');\n    }\n    const def = anyvarDefsByIndex[defIndex];\n    const value = def.type!.deserialize(buffer, state);\n    if (state && (state.options as any).useShortForm || def.useShortForm) {\n        return value;\n    } else {\n        return { type: def.type!.name, value };\n    }\n};\n\nexport const deserializeAnyvarShort = (buffer: SerialBuffer): any => {\n    return deserializeAnyvar(buffer, new SerializerState({ useShortForm: true } as any));\n};\n\nexport const serializeAnyObject = (buffer: SerialBuffer, obj: any): void => {\n    const entries = Object.entries(obj);\n    buffer.pushVaruint32(entries.length);\n    for (const [key, value] of entries) {\n        buffer.pushString(key);\n        serializeAnyvar(buffer, value as Anyvar);\n    }\n};\n\nexport const deserializeAnyObject = (buffer: SerialBuffer, state?: SerializerState): any => {\n    const len = buffer.getVaruint32();\n    const result = {};\n    for (let i = 0; i < len; ++i) {\n        let key = buffer.getString();\n        if (key in result) {\n            let j = 1;\n            while (key + '_' + j in result) {\n                ++j;\n            }\n            key = key + '_' + j;\n        }\n        (result as any)[key] = deserializeAnyvar(buffer, state);\n    }\n    return result;\n};\n\nexport const serializeAnyArray = (buffer: SerialBuffer, arr: Anyvar[]): void => {\n    buffer.pushVaruint32(arr.length);\n    for (const x of arr) {\n        serializeAnyvar(buffer, x);\n    }\n};\n\nexport const deserializeAnyArray = (buffer: SerialBuffer, state?: SerializerState): any[] => {\n    const len = buffer.getVaruint32();\n    const result = [];\n    for (let i = 0; i < len; ++i) {\n        result.push(deserializeAnyvar(buffer, state));\n    }\n    return result;\n};\n\nconst addAdditionalTypes = (): Map<string, Type> => {\n    const initialTypes = createInitialTypes();\n    initialTypes.set('null_t', createType({\n        name: 'null_t',\n        serialize: (_: SerialBuffer, __: Anyvar) => {},\n        deserialize: (_: SerialBuffer, __?: SerializerState) => {}\n    }));\n    initialTypes.set('any_object', createType({\n        name: 'any_object',\n        serialize: serializeAnyObject,\n        deserialize: deserializeAnyObject\n    }));\n    initialTypes.set('any_array', createType({\n        name: 'any_array',\n        serialize: serializeAnyArray,\n        deserialize: deserializeAnyArray\n    }));\n    return initialTypes;\n};\n\nconst additionalTypes = addAdditionalTypes();\n\nconst anyvarDefs = {\n    null_t: { index: 0, useShortForm: true, type: additionalTypes.get('null_t') },\n    int64: { index: 1, useShortForm: false, type: additionalTypes.get('int64') },\n    uint64: { index: 2, useShortForm: false, type: additionalTypes.get('uint64') },\n    int32: { index: 3, useShortForm: true, type: additionalTypes.get('int32') },\n    uint32: { index: 4, useShortForm: false, type: additionalTypes.get('uint32') },\n    int16: { index: 5, useShortForm: false, type: additionalTypes.get('int16') },\n    uint16: { index: 6, useShortForm: false, type: additionalTypes.get('uint16') },\n    int8: { index: 7, useShortForm: false, type: additionalTypes.get('int8') },\n    uint8: { index: 8, useShortForm: false, type: additionalTypes.get('uint8') },\n    time_point: { index: 9, useShortForm: false, type: additionalTypes.get('time_point') },\n    checksum256: { index: 10, useShortForm: false, type: additionalTypes.get('checksum256') },\n    float64: { index: 11, useShortForm: false, type: additionalTypes.get('float64') },\n    string: { index: 12, useShortForm: true, type: additionalTypes.get('string') },\n    any_object: { index: 13, useShortForm: true, type: additionalTypes.get('any_object') },\n    any_array: { index: 14, useShortForm: true, type: additionalTypes.get('any_array') },\n    bytes: { index: 15, useShortForm: false, type: additionalTypes.get('bytes') },\n    symbol: { index: 16, useShortForm: false, type: additionalTypes.get('symbol') },\n    symbol_code: { index: 17, useShortForm: false, type: additionalTypes.get('symbol_code') },\n    asset: { index: 18, useShortForm: false, type: additionalTypes.get('asset') },\n};\n\nconst anyvarDefsByIndex = [\n    anyvarDefs.null_t,\n    anyvarDefs.int64,\n    anyvarDefs.uint64,\n    anyvarDefs.int32,\n    anyvarDefs.uint32,\n    anyvarDefs.int16,\n    anyvarDefs.uint16,\n    anyvarDefs.int8,\n    anyvarDefs.uint8,\n    anyvarDefs.time_point,\n    anyvarDefs.checksum256,\n    anyvarDefs.float64,\n    anyvarDefs.string,\n    anyvarDefs.any_object,\n    anyvarDefs.any_array,\n    anyvarDefs.bytes,\n    anyvarDefs.symbol,\n    anyvarDefs.symbol_code,\n    anyvarDefs.asset,\n];\n\nexport const serializeQuery = (buffer: SerialBuffer, query: Query): void => {\n    let method: string;\n    let arg: Anyvar;\n    let filter: Query[];\n    if (typeof query === 'string') {\n        method = query;\n    } else if (Array.isArray(query) && query.length === 2) {\n        [method, filter] = query;\n    } else if (Array.isArray(query) && query.length === 3) {\n        [method, arg, filter] = query;\n    } else {\n        [method, arg, filter] = [query.method, query.arg, query.filter] as any;\n    }\n    buffer.pushString(method);\n\n    // @ts-ignore\n    if (arg === undefined) {\n        buffer.push(0);\n    } else {\n        buffer.push(1);\n        serializeAnyvar(buffer, arg);\n    }\n\n    // @ts-ignore\n    if (filter === undefined) {\n        buffer.push(0);\n    } else {\n        buffer.pushVaruint32(filter.length);\n        for (const q of filter) {\n            serializeQuery(buffer, q);\n        }\n    }\n};\n\nexport function b64tob64u(a: string) {\n    a = a.replace(/\\=/g, '');\n    a = a.replace(/\\+/g, '-');\n    a = a.replace(/\\//g, '_');\n    return a;\n}\n","import {ec as EC} from 'elliptic';\nimport * as hash from 'hash.js';\nimport {KeyType} from '../api/numeric';\n\n/** Construct the elliptic curve object based on key type */\nexport const constructElliptic = (type: KeyType): EC => {\n    if (type === KeyType.k1) {\n        return new EC('secp256k1');\n    }\n    return new EC('p256');\n};\n\nexport const sha256 = (data: string|Buffer): string => {\n    return hash.sha256().update(data).digest('hex');\n};\n","import { ec as EC } from 'elliptic';\nimport {\n    Key,\n    KeyType,\n    publicKeyToLegacyString,\n    publicKeyToString,\n    stringToPublicKey,\n} from '../api/numeric';\nimport { constructElliptic } from './conversions';\n\n/** Represents/stores a public key and provides easy conversion for use with `elliptic` lib */\nexport class PublicKey {\n    constructor(public key: Key, private ec: EC) {}\n\n    /** Instantiate public key from an EOSIO-format public key */\n    public static fromString(publicKeyStr: string, ec?: EC): PublicKey {\n        const key = stringToPublicKey(publicKeyStr);\n        if (!ec) {\n            ec = constructElliptic(key.type);\n        }\n        return new PublicKey(key, ec);\n    }\n\n    /** Instantiate public key from an `elliptic`-format public key */\n    public static fromElliptic(publicKey: EC.KeyPair, keyType: KeyType, ec?: EC): PublicKey {\n        const x = publicKey.getPublic().getX().toArray('be', 32);\n        const y = publicKey.getPublic().getY().toArray('be', 32);\n        if (!ec) {\n            ec = constructElliptic(keyType);\n        }\n        return new PublicKey({\n            type: keyType,\n            data: new Uint8Array([(y[31] & 1) ? 3 : 2].concat(x)),\n        }, ec);\n    }\n\n    /** Export public key as EOSIO-format public key */\n    public toString(): string {\n        return publicKeyToString(this.key);\n    }\n\n    /** Export public key as Legacy EOSIO-format public key */\n    public toLegacyString(prefix?: string): string {\n        return publicKeyToLegacyString(this.key, prefix);\n    }\n\n    /** Export public key as `elliptic`-format public key */\n    public toElliptic(): EC.KeyPair {\n        return this.ec.keyPair({\n            pub: Buffer.from(this.key.data),\n        });\n    }\n\n    /** Get key type from key */\n    public getType(): KeyType {\n        return this.key.type;\n    }\n\n    /** Validate a public key */\n    public isValid(): boolean {\n        try {\n            const ellipticPublicKey = this.toElliptic();\n            const validationObj = ellipticPublicKey.validate();\n            return validationObj.result;\n        } catch {\n            return false;\n        }\n    }\n}\n","import { BNInput, ec as EC } from 'elliptic';\nconst BN = require('bn.js');\n\nimport {\n    Key,\n    KeyType,\n    signatureToString,\n    stringToSignature,\n} from '../api/numeric';\nimport { constructElliptic } from './conversions';\nimport { PublicKey } from './publicKey'\n\n/** Represents/stores a Signature and provides easy conversion for use with `elliptic` lib */\nexport class Signature {\n    constructor(private signature: Key, private ec: EC) {}\n\n    /** Instantiate Signature from an EOSIO-format Signature */\n    public static fromString(sig: string, ec?: EC): Signature {\n        const signature = stringToSignature(sig);\n        if (!ec) {\n            ec = constructElliptic(signature.type);\n        }\n        return new Signature(signature, ec);\n    }\n\n    /** Instantiate Signature from an `elliptic`-format Signature */\n    public static fromElliptic(ellipticSig: EC.Signature, keyType: KeyType, ec?: EC): Signature {\n        if (!ellipticSig.recoveryParam) {\n            ellipticSig.recoveryParam = 0\n        }\n\n        const r = ellipticSig.r.toArray('be', 32);\n        const s = ellipticSig.s.toArray('be', 32);\n        let eosioRecoveryParam;\n        if (keyType === KeyType.k1 || keyType === KeyType.r1) {\n            eosioRecoveryParam = ellipticSig.recoveryParam + 27;\n            if (ellipticSig.recoveryParam <= 3) {\n                eosioRecoveryParam += 4;\n            }\n        } else if (keyType === KeyType.wa) {\n            eosioRecoveryParam = ellipticSig.recoveryParam;\n        }\n        const sigData = new Uint8Array([eosioRecoveryParam].concat(r, s) as any);\n        if (!ec) {\n            ec = constructElliptic(keyType);\n        }\n        return new Signature({\n            type: keyType,\n            data: sigData,\n        }, ec);\n    }\n\n    /** Export Signature as `elliptic`-format Signature\n     * NOTE: This isn't an actual elliptic-format Signature, as ec.Signature is not exported by the library.\n     * That's also why the return type is `any`.  We're *actually* returning an object with the 3 params\n     * not an ec.Signature.\n     * Further NOTE: @types/elliptic shows ec.Signature as exported; it is *not*.  Hence the `any`.\n     */\n    public toElliptic(): any {\n        const lengthOfR = 32;\n        const lengthOfS = 32;\n        const r = new BN(this.signature.data.slice(1, lengthOfR + 1));\n        const s = new BN(this.signature.data.slice(lengthOfR + 1, lengthOfR + lengthOfS + 1));\n\n        let ellipticRecoveryBitField;\n        if (this.signature.type === KeyType.k1 || this.signature.type === KeyType.r1) {\n            ellipticRecoveryBitField = this.signature.data[0] - 27;\n            if (ellipticRecoveryBitField > 3) {\n                ellipticRecoveryBitField -= 4;\n            }\n        } else if (this.signature.type === KeyType.wa) {\n            ellipticRecoveryBitField = this.signature.data[0];\n        } else {\n            ellipticRecoveryBitField = 0\n        }\n        const recoveryParam = ellipticRecoveryBitField & 3;\n        return { r, s, recoveryParam };\n    }\n\n    /** Export Signature as EOSIO-format Signature */\n    public toString(): string {\n        return signatureToString(this.signature);\n    }\n\n    /** Export Signature in binary format */\n    public toBinary(): Uint8Array {\n        return this.signature.data;\n    }\n\n    /** Get key type from signature */\n    public getType(): KeyType {\n        return this.signature.type;\n    }\n\n    /** Verify a signature with a message or hashed message digest and public key */\n    public verify(data: BNInput, publicKey: PublicKey, shouldHash: boolean = true, encoding: BufferEncoding = 'utf8'): boolean {\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        const ellipticSignature = this.toElliptic();\n        const ellipticPublicKey = publicKey.toElliptic();\n        return this.ec.verify(data, ellipticSignature, ellipticPublicKey, encoding);\n    }\n\n    /** Recover a public key from a message or hashed message digest and signature */\n    public recover(data: BNInput, shouldHash: boolean = true, encoding: BufferEncoding = 'utf8'): PublicKey {\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        const ellipticSignature = this.toElliptic();\n        const recoveredPublicKey = this.ec.recoverPubKey(\n            data,\n            ellipticSignature,\n            ellipticSignature.recoveryParam,\n            encoding\n        );\n        const ellipticKPub = this.ec.keyFromPublic(recoveredPublicKey);\n        return PublicKey.fromElliptic(ellipticKPub, this.getType(), this.ec);\n    }\n}\n","import { BNInput, ec as EC } from 'elliptic';\nimport {\n    Key,\n    KeyType,\n    privateKeyToLegacyString,\n    privateKeyToString,\n    stringToPrivateKey,\n} from '../api/numeric';\nimport { constructElliptic } from './conversions';\nimport { PublicKey } from './publicKey'\nimport { Signature } from './signature'\n\n/** Represents/stores a private key and provides easy conversion for use with `elliptic` lib */\nexport class PrivateKey {\n    constructor(private key: Key, private ec: EC) {}\n\n    /** Instantiate private key from an `elliptic`-format private key */\n    public static fromElliptic(privKey: EC.KeyPair, keyType: KeyType, ec?: EC): PrivateKey {\n        if (!ec) {\n            ec = constructElliptic(keyType);\n        }\n        return new PrivateKey({\n            type: keyType,\n            data: privKey.getPrivate().toArrayLike(Buffer, 'be', 32),\n        }, ec);\n    }\n\n    /** Instantiate private key from an EOSIO-format private key */\n    public static fromString(keyString: string, ec?: EC): PrivateKey {\n        const privateKey = stringToPrivateKey(keyString);\n        if (!ec) {\n            ec = constructElliptic(privateKey.type);\n        }\n        return new PrivateKey(privateKey, ec);\n    }\n\n    /** Export private key as `elliptic`-format private key */\n    public toElliptic(): EC.KeyPair {\n        return this.ec.keyFromPrivate(this.key.data);\n    }\n\n    public toLegacyString(): string {\n        return privateKeyToLegacyString(this.key);\n    }\n\n    /** Export private key as EOSIO-format private key */\n    public toString(): string {\n        return privateKeyToString(this.key);\n    }\n\n    /** Get key type from key */\n    public getType(): KeyType {\n        return this.key.type;\n    }\n\n    /** Retrieve the public key from a private key */\n    public getPublicKey(): PublicKey {\n        const ellipticPrivateKey = this.toElliptic();\n        return PublicKey.fromElliptic(ellipticPrivateKey, this.getType(), this.ec);\n    }\n\n    /** Sign a message or hashed message digest with private key */\n    public sign(data: BNInput, shouldHash: boolean = true, encoding: BufferEncoding = 'utf8'): Signature {\n        if (shouldHash) {\n            if (typeof data === 'string') {\n                data = Buffer.from(data, encoding);\n            }\n            data = this.ec.hash().update(data).digest();\n        }\n        let tries = 0;\n        let signature: Signature;\n        const isCanonical = (sigData: Uint8Array): boolean =>\n            !(sigData[1] & 0x80) && !(sigData[1] === 0 && !(sigData[2] & 0x80))\n            && !(sigData[33] & 0x80) && !(sigData[33] === 0 && !(sigData[34] & 0x80));\n        const constructSignature = (options: EC.SignOptions): Signature => {\n            const ellipticPrivateKey = this.toElliptic();\n            const ellipticSignature = ellipticPrivateKey.sign(data, options);\n            return Signature.fromElliptic(ellipticSignature, this.getType(), this.ec);\n        };\n\n        if (this.key.type === KeyType.k1) {\n            do {\n                signature = constructSignature({canonical: true, pers: [++tries]});\n            } while (!isCanonical(signature.toBinary()));\n        } else {\n            signature = constructSignature({canonical: true});\n        }\n        return signature;\n    }\n\n    /** Validate a private key */\n    public isValid(): boolean {\n        try {\n            const ellipticPrivateKey = this.toElliptic();\n            const validationObj = ellipticPrivateKey.validate();\n            return validationObj.result;\n        } catch {\n            return false;\n        }\n    }\n}\n","import { PrivateKey } from './privateKey';\nimport { PublicKey } from './publicKey';\nimport { ec as EC } from 'elliptic';\nimport {KeyType} from '../api/numeric';\n\nexport { PrivateKey } from './privateKey';\nexport { PublicKey } from './publicKey';\nexport { Signature } from './signature';\nexport { constructElliptic } from './conversions';\n\nexport const generateKeyPair = (\n    type: KeyType, options: { secureEnv?: boolean, ecOptions?: EC.GenKeyPairOptions } = {}\n): { publicKey: PublicKey, privateKey: PrivateKey } => {\n    if (!options.secureEnv) {\n        throw new Error('Key generation is completely INSECURE in production environments in the browser. ' +\n            'If you are absolutely certain this does NOT describe your environment, set `secureEnv` in your ' +\n            'options to `true`.  If this does describe your environment and you set `secureEnv` to `true`, ' +\n            'YOU DO SO AT YOUR OWN RISK AND THE RISK OF YOUR USERS.');\n    }\n    let ec;\n    if (type === KeyType.k1) {\n        ec = new EC('secp256k1') as any;\n    } else {\n        ec = new EC('p256') as any;\n    }\n    const ellipticKeyPair = ec.genKeyPair(options.ecOptions);\n    const publicKey = PublicKey.fromElliptic(ellipticKeyPair, type, ec);\n    const privateKey = PrivateKey.fromElliptic(ellipticKeyPair, type, ec);\n    return {publicKey, privateKey};\n};","/**\n * @module JS-Sig\n */\n// copyright defined in eosjs/LICENSE.txt\n\nimport { ec } from 'elliptic';\n\nimport { SignatureProvider, SignatureProviderArgs } from '../api/types';\nimport {\n    PrivateKey,\n    PublicKey,\n    Signature,\n} from './key';\nimport { convertLegacyPublicKey } from '../api/numeric';\n\n/** expensive to construct; so we do it once and reuse it */\nconst defaultEc = new ec('secp256k1');\n\n/** Construct the digest from transaction details */\nconst digestFromSerializedData = (\n    chainId: string,\n    serializedTransaction: Uint8Array,\n    serializedContextFreeData?: Uint8Array,\n    e = defaultEc) => {\n    const signBuf = Buffer.concat([\n        Buffer.from(chainId, 'hex'),\n        Buffer.from(serializedTransaction),\n        Buffer.from(\n            serializedContextFreeData ?\n                new Uint8Array(e.hash().update(serializedContextFreeData).digest()) :\n                new Uint8Array(32)\n        ),\n    ]);\n    return e.hash().update(signBuf).digest();\n};\n\n/** Signs transactions using in-process private keys */\nclass JsSignatureProvider implements SignatureProvider {\n    /** map public to private keys */\n    public keys = new Map<string, ec.KeyPair>();\n\n    /** public keys */\n    public availableKeys = [] as string[];\n\n    /** @param privateKeys private keys to sign with */\n    constructor(privateKeys: string[]) {\n        for (const k of privateKeys) {\n            const priv = PrivateKey.fromString(k);\n            const privElliptic = priv.toElliptic();\n            const pubStr = priv.getPublicKey().toString();\n            this.keys.set(pubStr, privElliptic);\n            this.availableKeys.push(pubStr);\n        }\n    }\n\n    /** Public keys associated with the private keys that the `SignatureProvider` holds */\n    public async getAvailableKeys() {\n        return this.availableKeys;\n    }\n\n    /** Sign a transaction */\n    public async sign(\n        { chainId, requiredKeys, serializedTransaction, serializedContextFreeData }: SignatureProviderArgs,\n    ) {\n        const digest = digestFromSerializedData( chainId, serializedTransaction, serializedContextFreeData, defaultEc);\n\n        const signatures = [] as string[];\n        for (const key of requiredKeys) {\n            const publicKey = PublicKey.fromString(key);\n            const ellipticPrivateKey = this.keys.get(convertLegacyPublicKey(key));\n            if (ellipticPrivateKey) {\n                const privateKey = PrivateKey.fromElliptic(ellipticPrivateKey, publicKey.getType());\n                const signature = privateKey.sign(digest, false);\n                signatures.push(signature.toString());\n            }\n        }\n\n        return { signatures, serializedTransaction, serializedContextFreeData };\n    }\n}\n\nexport {\n    PrivateKey,\n    PublicKey,\n    Signature,\n    digestFromSerializedData,\n    JsSignatureProvider,\n};\n","/* eslint-disable max-classes-per-file */\n\nimport { inflate, deflate } from 'pako';\nimport { ec } from 'elliptic';\nimport base64url from 'base64url';\nimport {\n    AbiProvider,\n    ActionSerializerType,\n    AuthorityProvider,\n    BinaryAbi,\n    CachedAbi,\n    ContextFreeGroupCallback,\n    Query,\n    QueryConfig,\n    SignatureProvider,\n    TransactConfig,\n    Transaction,\n    TransactResult,\n} from './types';\nimport { JsonRpc } from '../rpc';\nimport {\n    Abi,\n    BlockTaposInfo,\n    GetInfoResult,\n    PushTransactionArgs,\n    GetBlockHeaderStateResult,\n    GetBlockInfoResult,\n    GetBlockResult,\n    ReadOnlyTransactResult,\n    RsaKey\n} from '../rpc/types';\nimport * as ser from './serialize';\nimport { digestFromSerializedData } from '../cryptography/jsSignatureProvider'\nimport { PublicKey, Signature } from '../cryptography/key' \nimport * as Numeric from './numeric';\nimport { b64tob64u } from './serialize';\nimport { sha256 } from '../cryptography/conversions';\nimport { ApiInterfaces } from '..';\nimport type { recoverPersonalSignature as RecoverPersonalSignature } from 'eth-sig-util'\n\nexport class Api {\n    /** Issues RPC calls */\n    public rpc: JsonRpc;\n\n    /** Get subset of `availableKeys` needed to meet authorities in a `transaction` */\n    public authorityProvider: AuthorityProvider;\n\n    /** Supplies ABIs in raw form (binary) */\n    public abiProvider: AbiProvider;\n\n    /** Signs transactions */\n    public signatureProvider?: SignatureProvider;\n\n    /** Converts abi files between binary and structured form (`abi.abi.json`) */\n    public abiTypes: Map<string, ser.Type>;\n\n    /** Converts transactions between binary and structured form (`transaction.abi.json`) */\n    public transactionTypes: Map<string, ser.Type>;\n\n    /** Holds information needed to serialize contract actions */\n    public contracts = new Map<string, ser.Contract>();\n\n    /** Fetched abis */\n    public cachedAbis = new Map<string, CachedAbi>();\n\n    /** Crypto */    \n    public crypto?: Crypto\n    public recoverPersonalSignature?: typeof RecoverPersonalSignature\n\n    /**\n     * @param args\n     *    * `rpc`: Issues RPC calls\n     *    * `authorityProvider`: Get public keys needed to meet authorities in a transaction\n     *    * `abiProvider`: Supplies ABIs in raw form (binary)\n     *    * `signatureProvider`: Signs transactions\n     */\n    constructor(args: {\n        rpc: JsonRpc,\n        authorityProvider?: AuthorityProvider,\n        abiProvider?: AbiProvider,\n        signatureProvider?: SignatureProvider,\n        crypto?: Crypto,\n        recoverPersonalSignature?: typeof RecoverPersonalSignature\n    }) {\n        this.rpc = args.rpc;\n        this.authorityProvider = args.authorityProvider || args.rpc;\n        this.abiProvider = args.abiProvider || args.rpc;\n        if (args.signatureProvider) {\n            this.signatureProvider = args.signatureProvider;\n        }\n\n        this.abiTypes = ser.getTypesFromAbi(ser.createAbiTypes());\n        this.transactionTypes = ser.getTypesFromAbi(ser.createTransactionTypes());\n\n        this.crypto = args.crypto || (typeof window !== \"undefined\" && window && window.crypto) || (global && global.crypto)\n        this.recoverPersonalSignature = args.recoverPersonalSignature\n    }\n\n    getCrypto() {\n        if (!this.crypto) {\n            throw new Error(`No 'crypto' module found. On nodejs, do const { Crypto } = require('@peculiar/webcrypto'); const crypto = new Crypto; new Api({ rpc, crypto });`)\n        }\n\n        return this.crypto\n    }\n\n    getRecoverPersonalSignature() {\n        if (!this.recoverPersonalSignature) {\n            throw new Error(`No 'recoverPersonalSignature' function found. Do const { recoverPersonalSignature } = require('eth-sig-util'); new Api({ rpc, recoverPersonalSignature });`)\n        }\n\n        return this.recoverPersonalSignature\n    }\n\n    /** Decodes an abi as Uint8Array into json. */\n    public rawAbiToJson(rawAbi: Uint8Array): Abi {\n        const buffer = new ser.SerialBuffer({\n            array: rawAbi\n        });\n        if (!ser.supportedAbiVersion(buffer.getString())) {\n            throw new Error('Unsupported abi version');\n        }\n        buffer.restartRead();\n        return this.abiTypes.get('abi_def')!.deserialize(buffer);\n    }\n\n    /** Encodes a json abi as Uint8Array. */\n    public jsonToRawAbi(jsonAbi: Abi): Uint8Array {\n        const buffer = new ser.SerialBuffer();\n        this.abiTypes.get('abi_def')!.serialize(buffer, jsonAbi);\n        if (!ser.supportedAbiVersion(buffer.getString())) {\n            throw new Error('Unsupported abi version');\n        }\n        return buffer.asUint8Array();\n    }\n\n    /** Get abi in both binary and structured forms. Fetch when needed. */\n    public async getCachedAbi(accountName: string, reload = false): Promise<CachedAbi> {\n        if (!reload && this.cachedAbis.get(accountName)) {\n            return this.cachedAbis.get(accountName) as CachedAbi;\n        }\n        let cachedAbi: CachedAbi;\n        try {\n            const rawAbi = (await this.abiProvider.getRawAbi(accountName)).abi;\n            const abi = this.rawAbiToJson(rawAbi);\n            cachedAbi = { rawAbi, abi };\n        } catch (e) {\n            e.message = `fetching abi for ${accountName}: ${e.message}`;\n            throw e;\n        }\n        if (!cachedAbi) {\n            throw new Error(`Missing abi for ${accountName}`);\n        }\n        this.cachedAbis.set(accountName, cachedAbi);\n        return cachedAbi;\n    }\n\n    /** Get abi in structured form. Fetch when needed. */\n    public async getAbi(accountName: string, reload = false): Promise<Abi> {\n        return (await this.getCachedAbi(accountName, reload)).abi;\n    }\n\n    /** Get abis needed by a transaction */\n    public async getTransactionAbis(transaction: any, reload = false): Promise<BinaryAbi[]> {\n        const actions = (transaction.context_free_actions || []).concat(transaction.actions);\n        const accounts: string[] = actions.map((action: ser.Action): string => action.account);\n        const uniqueAccounts: Set<string> = new Set(accounts);\n        const actionPromises: Promise<BinaryAbi>[] = Array.from(uniqueAccounts).map(\n            async (account: string): Promise<BinaryAbi> => {\n                const { rawAbi } = await this.getCachedAbi(account, reload)\n                return {\n                    accountName: account,\n                    abi: rawAbi\n                }\n            }\n        );\n        return Promise.all(actionPromises);\n    }\n\n    /** Get data needed to serialize actions in a contract */\n    public async getContract(accountName: string, reload = false): Promise<ser.Contract> {\n        if (!reload && this.contracts.get(accountName)) {\n            return this.contracts.get(accountName) as ser.Contract;\n        }\n        const abi = await this.getAbi(accountName, reload);\n        const types = ser.getTypesFromAbi(ser.createInitialTypes(), abi);\n        const actions = new Map<string, ser.Type>();\n        for (const { name, type } of abi.actions) {\n            actions.set(name, ser.getType(types, type));\n        }\n        const result = { types, actions };\n        this.contracts.set(accountName, result);\n        return result;\n    }\n\n    /** Convert `value` to binary form. `type` must be a built-in abi type or in `transaction.abi.json`. */\n    public serialize(buffer: ser.SerialBuffer, type: string, value: any): void {\n        this.transactionTypes.get(type)!.serialize(buffer, value);\n    }\n\n    /** Convert data in `buffer` to structured form. `type` must be a built-in abi type or in `transaction.abi.json`. */\n    public deserialize(buffer: ser.SerialBuffer, type: string): any {\n        return this.transactionTypes.get(type)!.deserialize(buffer);\n    }\n\n    /** Convert a transaction to binary */\n    public serializeTransaction(transaction: Transaction): Uint8Array {\n        const buffer = new ser.SerialBuffer();\n        this.serialize(buffer, 'transaction', {\n            max_net_usage_words: 0,\n            max_cpu_usage_ms: 0,\n            delay_sec: 0,\n            context_free_actions: [],\n            transaction_extensions: [],\n            ...transaction,\n        });\n        return buffer.asUint8Array();\n    }\n\n    /** Serialize context-free data */\n    public serializeContextFreeData(contextFreeData?: Uint8Array[]): Uint8Array | undefined {\n        if (!contextFreeData || !contextFreeData.length) {\n            return undefined;\n        }\n        const buffer = new ser.SerialBuffer();\n        buffer.pushVaruint32(contextFreeData.length);\n        for (const data of contextFreeData) {\n            buffer.pushBytes(data);\n        }\n        return buffer.asUint8Array();\n    }\n\n    /** Convert a transaction from binary. Leaves actions in hex. */\n    public deserializeTransaction(transaction: Uint8Array): Transaction {\n        const buffer = new ser.SerialBuffer();\n        buffer.pushArray(transaction);\n        return this.deserialize(buffer, 'transaction');\n    }\n\n    private transactionExtensions = [\n        { id: 1, type: 'resource_payer', keys: ['payer', 'max_net_bytes', 'max_cpu_us', 'max_memory_bytes'] },\n    ];\n\n    // Order of adding to transaction_extension is transaction_extension id ascending\n    public serializeTransactionExtensions(transaction: Transaction): [number, string][] {\n        let transaction_extensions: [number, string][] = [];\n        if (transaction.resource_payer) {\n            const extensionBuffer = new ser.SerialBuffer();\n            const types = ser.getTypesFromAbi(ser.createTransactionExtensionTypes());\n            types.get('resource_payer')!.serialize(extensionBuffer, transaction.resource_payer);\n            transaction_extensions = [...transaction_extensions, [1, ser.arrayToHex(extensionBuffer.asUint8Array())]];\n        }\n        return transaction_extensions;\n    };\n\n    // Usage: transaction = {...transaction, ...this.deserializeTransactionExtensions(transaction.transaction_extensions)}\n    public deserializeTransactionExtensions(data: [number, string][]): any[] {\n        const transaction = {} as any;\n        data.forEach((extensionData: [number, string]) => {\n            const transactionExtension = this.transactionExtensions.find(extension => extension.id === extensionData[0]);\n            if (transactionExtension === undefined) {\n                throw new Error(`Transaction Extension could not be determined: ${extensionData}`);\n            }\n            const types = ser.getTypesFromAbi(ser.createTransactionExtensionTypes());\n            const extensionBuffer = new ser.SerialBuffer();\n            extensionBuffer.pushArray(ser.hexToUint8Array(extensionData[1]));\n            const deserializedObj = types.get(transactionExtension.type)!.deserialize(extensionBuffer);\n            if (extensionData[0] === 1) {\n                deserializedObj.max_net_bytes = Number(deserializedObj.max_net_bytes);\n                deserializedObj.max_cpu_us = Number(deserializedObj.max_cpu_us);\n                deserializedObj.max_memory_bytes = Number(deserializedObj.max_memory_bytes);\n                transaction.resource_payer = deserializedObj;\n            }\n        });\n        return transaction;\n    };\n\n    // Transaction extensions are serialized and moved to `transaction_extensions`, deserialized objects are not needed on the transaction\n    public deleteTransactionExtensionObjects(transaction: Transaction): Transaction {\n        delete transaction.resource_payer;\n        return transaction;\n    }\n\n    /** Convert actions to hex */\n    public async serializeActions(actions: ser.Action[]): Promise<ser.SerializedAction[]> {\n        return await Promise.all(actions.map(async (action) => {\n            const { account, name, authorization, data } = action;\n            const contract = await this.getContract(account);\n            if (typeof data !== 'object') {\n                return action;\n            }\n            return ser.serializeAction(\n                contract, account, name, authorization, data);\n        }));\n    }\n\n    /** Convert actions from hex */\n    public async deserializeActions(actions: ser.Action[]): Promise<ser.Action[]> {\n        return await Promise.all(actions.map(async ({ account, name, authorization, data }) => {\n            const contract = await this.getContract(account);\n            return ser.deserializeAction(\n                contract, account, name, authorization, data);\n        }));\n    }\n\n    public async deserializeActionsSync(actions: ser.Action[] = []): Promise<ser.Action[]> {\n        let deserializedActions = []\n        for (const { account, name, authorization, data } of actions) {\n            const contract = await this.getContract(account);\n            deserializedActions.push(\n                ser.deserializeAction(\n                    contract, account, name, authorization, data\n                )\n            )\n        }\n        return deserializedActions\n    }\n\n    /** Convert a transaction from binary. Also deserializes actions. */\n    public async deserializeTransactionWithActions(transaction: Uint8Array | string): Promise<any> {\n        if (typeof transaction === 'string') {\n            transaction = ser.hexToUint8Array(transaction);\n        }\n        const deserializedTransaction = this.deserializeTransaction(transaction);\n        const deserializedCFActions = await this.deserializeActionsSync(deserializedTransaction.context_free_actions);\n        const deserializedActions = await this.deserializeActionsSync(deserializedTransaction.actions);\n        return {\n            ...deserializedTransaction, context_free_actions: deserializedCFActions, actions: deserializedActions\n        };\n    }\n\n    /** Deflate a serialized object */\n    public deflateSerializedArray(serializedArray: Uint8Array): Uint8Array {\n        return deflate(serializedArray, { level: 9 });\n    }\n\n    /** Inflate a compressed serialized object */\n    public inflateSerializedArray(compressedSerializedArray: Uint8Array): Uint8Array {\n        return inflate(compressedSerializedArray);\n    }\n\n    /**\n     * Create and optionally broadcast a transaction.\n     *\n     * Named Parameters:\n     * `broadcast`: broadcast this transaction?\n     * `sign`: sign this transaction?\n     * `compression`: compress this transaction?\n     * `readOnlyTrx`: read only transaction?\n     * `returnFailureTraces`: return failure traces? (only available for read only transactions currently)\n     *\n     * If both `blocksBehind` and `expireSeconds` are present,\n     * then fetch the block which is `blocksBehind` behind head block,\n     * use it as a reference for TAPoS, and expire the transaction `expireSeconds` after that block's time.\n     *\n     * If both `useLastIrreversible` and `expireSeconds` are present,\n     * then fetch the last irreversible block, use it as a reference for TAPoS,\n     * and expire the transaction `expireSeconds` after that block's time.\n     *\n     * @returns node response if `broadcast`, `{signatures, serializedTransaction}` if `!broadcast`\n     */\n    public async transact(\n        transaction: Transaction,\n        {\n            broadcast = true,\n            sign = true,\n            readOnlyTrx,\n            returnFailureTraces,\n            requiredKeys, // When you will sign later\n            compression,\n            blocksBehind,\n            useLastIrreversible,\n            expireSeconds,\n            transactionHeader\n        }:\n        TransactConfig = {}): Promise<TransactResult|ReadOnlyTransactResult|PushTransactionArgs>\n    {\n        const info: GetInfoResult = await this.rpc.get_info();;\n\n        // Calculate header if not provided\n        if (!transactionHeader) {\n            if (typeof blocksBehind === 'number' && useLastIrreversible) {\n                throw new Error('Use either blocksBehind or useLastIrreversible');\n            } else if (typeof blocksBehind !== 'number' && !useLastIrreversible) {\n                throw new Error('Must provide one blocksBehind or useLastIrreversible');\n            } else if (!expireSeconds) {\n                throw new Error('Must provide expireSeconds');\n            } else {\n                transactionHeader = await this.generateTapos(info, transaction, blocksBehind, useLastIrreversible, expireSeconds);;\n            }\n\n            if (!this.hasRequiredTaposFields(transactionHeader)) {\n                throw new Error('Required configuration or TAPOS fields are not present');\n            }\n        }\n\n        const abis: BinaryAbi[] = await this.getTransactionAbis(transaction);\n        transaction = {\n            ...transactionHeader,\n            transaction_extensions: await this.serializeTransactionExtensions(transaction),\n            context_free_actions: await this.serializeActions(transaction.context_free_actions || []),\n            actions: await this.serializeActions(transaction.actions)\n        };\n        transaction = this.deleteTransactionExtensionObjects(transaction);\n        const serializedTransaction = this.serializeTransaction(transaction);\n        const serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);\n        let pushTransactionArgs: PushTransactionArgs = {\n            serializedTransaction, serializedContextFreeData, signatures: []\n        };\n\n        if (sign) {\n            if (!this.signatureProvider) {\n                throw new Error('No signature provider available')\n            }\n            \n            if (!requiredKeys) {\n                const availableKeys = await this.signatureProvider.getAvailableKeys();\n                requiredKeys = await this.authorityProvider.getRequiredKeys({ transaction, availableKeys });\n            }\n\n            pushTransactionArgs = await this.signatureProvider.sign({\n                chainId: info.chain_id,\n                requiredKeys,\n                serializedTransaction,\n                serializedContextFreeData,\n                abis,\n            });\n        }\n        if (broadcast) {\n            if (compression) {\n                return this.pushCompressedSignedTransaction(\n                    pushTransactionArgs,\n                    readOnlyTrx,\n                    returnFailureTraces,\n                ) as Promise<TransactResult|ReadOnlyTransactResult>;\n            }\n            return this.pushSignedTransaction(\n                pushTransactionArgs,\n                readOnlyTrx,\n                returnFailureTraces,\n            ) as Promise<TransactResult|ReadOnlyTransactResult>;\n        }\n        return {\n            ...pushTransactionArgs,\n            transactionHeader //\n        };\n    }\n\n    public async transactWithDelay(transaction: any, params: TransactConfig = {}, delay: number): Promise<any> {\n        async function wait (ms: number) {\n            return new Promise(resolve => {\n              setTimeout(resolve, ms);\n            });\n        }\n\n        const success = await this.transact(transaction, params)\n        await wait(delay)\n        return success\n    }\n\n    public async query(\n        account: string, short: boolean, query: Query,\n        { sign, requiredKeys, authorization = [] }: QueryConfig\n    ): Promise<any> {\n        const info = await this.rpc.get_info();\n        const refBlock = await this.tryRefBlockFromGetInfo(info);\n        const queryBuffer = new ser.SerialBuffer();\n        ser.serializeQuery(queryBuffer, query);\n\n        const transaction = {\n            ...ser.transactionHeader(refBlock, 60 * 30),\n            context_free_actions: [] as ser.Action[],\n            actions: [{\n                account,\n                name: 'queryit',\n                authorization,\n                data: ser.arrayToHex(queryBuffer.asUint8Array()),\n            }],\n        };\n\n        const serializedTransaction = this.serializeTransaction(transaction);\n        let signatures: string[] = [];\n        if (sign) {\n            if (!this.signatureProvider) {\n                throw new Error('No signature provider available')\n            }\n    \n            const abis: BinaryAbi[] = await this.getTransactionAbis(transaction);\n            if (!requiredKeys) {\n                const availableKeys = await this.signatureProvider.getAvailableKeys();\n                requiredKeys = await this.authorityProvider.getRequiredKeys({ transaction, availableKeys });\n            }\n\n            const signResponse = await this.signatureProvider.sign({\n                chainId: info.chain_id,\n                requiredKeys,\n                serializedTransaction,\n                serializedContextFreeData: undefined,\n                abis,\n            });\n\n            signatures = signResponse.signatures;\n        }\n\n        const response = await this.rpc.send_transaction({\n            signatures,\n            compression: 0,\n            serializedTransaction\n        }) as any;\n\n        const returnBuffer = new ser.SerialBuffer({\n            array: ser.hexToUint8Array(response.processed.action_traces[0][1].return_value)\n        });\n        if (short) {\n            return ser.deserializeAnyvarShort(returnBuffer);\n        } else {\n            return ser.deserializeAnyvar(returnBuffer);\n        }\n    }\n\n    /** Broadcast a signed transaction */\n    public async pushSignedTransaction(\n        { signatures, serializedTransaction, serializedContextFreeData }: PushTransactionArgs,\n        readOnlyTrx = false,\n        returnFailureTraces = false,\n        ): Promise<TransactResult|ReadOnlyTransactResult> {\n            if (readOnlyTrx) {\n                return this.rpc.push_ro_transaction({\n                    signatures,\n                    serializedTransaction,\n                    serializedContextFreeData,\n                }, returnFailureTraces);\n            }\n        return this.rpc.push_transaction({\n            signatures,\n            serializedTransaction,\n            serializedContextFreeData\n        });\n    }\n\n    public async pushCompressedSignedTransaction(\n        { signatures, serializedTransaction, serializedContextFreeData }: PushTransactionArgs,\n        readOnlyTrx = false,\n        returnFailureTraces = false,\n    ): Promise<TransactResult|ReadOnlyTransactResult> {\n        const compressedSerializedTransaction = this.deflateSerializedArray(serializedTransaction);\n        const compressedSerializedContextFreeData =\n            this.deflateSerializedArray(serializedContextFreeData || new Uint8Array(0));\n\n        if (readOnlyTrx) {\n            return this.rpc.push_ro_transaction({\n                signatures,\n                compression: 1,\n                serializedTransaction: compressedSerializedTransaction,\n                serializedContextFreeData: compressedSerializedContextFreeData\n            }, returnFailureTraces);\n        }\n        return this.rpc.push_transaction({\n            signatures,\n            compression: 1,\n            serializedTransaction: compressedSerializedTransaction,\n            serializedContextFreeData: compressedSerializedContextFreeData\n        });\n    }\n\n    public async generateTapos(\n        info: GetInfoResult | undefined,\n        transaction: Transaction,\n        blocksBehind: number = 3,\n        useLastIrreversible: boolean | undefined,\n        expireSeconds: number\n    ) {\n        if (!info) {\n            info = await this.rpc.get_info();\n        }\n        if (useLastIrreversible) {\n            const block = await this.tryRefBlockFromGetInfo(info);\n            return { ...ser.transactionHeader(block, expireSeconds), ...transaction };\n        }\n\n        const taposBlockNumber: number = info.head_block_num - blocksBehind;\n\n        const refBlock: GetBlockHeaderStateResult | GetBlockResult | GetBlockInfoResult =\n            taposBlockNumber <= info.last_irreversible_block_num\n                ? await this.tryGetBlockInfo(taposBlockNumber)\n                : await this.tryGetBlockHeaderState(taposBlockNumber);\n\n        return { ...ser.transactionHeader(refBlock, expireSeconds), ...transaction };\n    }\n\n    // eventually break out into TransactionValidator class\n    private hasRequiredTaposFields({ expiration, ref_block_num, ref_block_prefix }: Transaction): boolean {\n        return !!(expiration && typeof(ref_block_num) === 'number' && typeof(ref_block_prefix) === 'number');\n    }\n\n    private async tryGetBlockHeaderState(taposBlockNumber: number): Promise<GetBlockHeaderStateResult | GetBlockResult | GetBlockInfoResult>\n    {\n        try {\n            return await this.rpc.get_block_header_state(taposBlockNumber);\n        } catch (error) {\n            return await this.tryGetBlockInfo(taposBlockNumber);\n        }\n    }\n\n    private async tryGetBlockInfo(blockNumber: number): Promise<GetBlockInfoResult | GetBlockResult> {\n        try {\n            return await this.rpc.get_block_info(blockNumber);\n        } catch (error) {\n            return await this.rpc.get_block(blockNumber);\n        }\n    }\n\n    private async tryRefBlockFromGetInfo(info: GetInfoResult): Promise<BlockTaposInfo | GetBlockInfoResult | GetBlockResult> {\n        if (\n            info.hasOwnProperty('last_irreversible_block_id') &&\n            info.hasOwnProperty('last_irreversible_block_num') &&\n            info.hasOwnProperty('last_irreversible_block_time')\n        ) {\n            return {\n                block_num: info.last_irreversible_block_num,\n                id: info.last_irreversible_block_id,\n                timestamp: info.last_irreversible_block_time,\n            };\n        } else {\n            const block = await this.tryGetBlockInfo(info.last_irreversible_block_num);\n            return {\n                block_num: block.block_num,\n                id: block.id,\n                timestamp: block.timestamp,\n            };\n        }\n    }\n\n    public with(accountName: string): ActionBuilder {\n        return new ActionBuilder(this, accountName);\n    }\n\n    public buildTransaction(cb?: (tx: TransactionBuilder) => void): TransactionBuilder|void {\n        const tx = new TransactionBuilder(this);\n        if (cb) {\n            return cb(tx);\n        }\n        return tx as TransactionBuilder;\n    }\n\n    public async getAccountKeys (actor: string, permission: string) {\n        try {\n            const { permissions } = await this.rpc.get_account(actor)\n            const relevantPermission = permissions.find(({ perm_name }: any) => perm_name === permission)\n            if (relevantPermission) {\n                return relevantPermission.required_auth.keys.map(({ key }: any) => PublicKey.fromString(key).toString())\n            }\n        } catch (e) {\n            console.log(e)\n        }\n\n        return []\n    }\n\n    public async sha256Digest (\n        array: Uint8Array | ArrayBuffer\n    ): Promise<Uint8Array> {\n        const buffer = array instanceof Uint8Array ? array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength) : array;\n        return new Uint8Array(await this.getCrypto().subtle.digest('SHA-256', buffer));\n    };\n\n    async matchRsaKeyToSignature({ actor, transaction }: { actor: string, transaction: Transaction }) {\n        // 0. Destructure\n        const { signature, nonce, trx }: {\n            account: string,\n            signature: { auth_data: string; signature: string; client_json: string },\n            nonce: number,\n            trx: ApiInterfaces.Transaction\n        } = transaction.actions[0].data\n\n        // 1. Get user creds\n        let creds = await this.rpc.fetchCredentials(actor);\n    \n        // 2. Filter RSA\n        creds = creds.filter((cred) => cred.key.key[0] === 'rsa_public_key');\n    \n        // 3. For each cred\n        for (const cred of creds) {\n            // Create key \n            const rsaKey = cred.key.key[1] as RsaKey;\n        \n            // Create crypto key\n            const exponentBase64 = b64tob64u(Buffer.from(rsaKey.exponent, 'hex').toString('base64'));\n            const modulusBase64 = b64tob64u(Buffer.from(rsaKey.modulus, 'hex').toString('base64'));\n        \n            // Check challenge\n            const clientJson = JSON.parse(signature.client_json);\n            const signedDigest = new Uint8Array(base64url.toBuffer(clientJson.challenge).buffer);\n        \n            // Create TX Digest\n            const signBuf = new ser.SerialBuffer();\n            const serializedTransaction = this.serializeTransaction(trx);\n            signBuf.pushArray(serializedTransaction);\n            signBuf.pushNumberAsUint64(nonce);\n            const actualDigest = await this.sha256Digest(signBuf.asUint8Array().slice());\n        \n            if (ser.arrayToHex(signedDigest) !== ser.arrayToHex(actualDigest)) {\n                continue;\n            }\n        \n            // Check signature\n            const publicKey = await this.getCrypto().subtle.importKey(\n                'jwk',\n                {\n                    //this is an example jwk key, other key types are Uint8Array objects\n                    kty: 'RSA',\n                    e: exponentBase64,\n                    n: modulusBase64,\n                    alg: 'RS256',\n                    ext: false,\n                },\n                {\n                    name: 'RSASSA-PKCS1-v1_5',\n                    hash: {\n                        name: 'SHA-256',\n                    },\n                },\n                false,\n                ['verify']\n            );\n        \n            const authData = ser.hexToUint8Array(signature.auth_data);\n            const clientJsonHash = ser.hexToUint8Array(sha256(signature.client_json));\n            const resultingHash = new Uint8Array([...authData, ...clientJsonHash]);\n\n            const verified = await this.getCrypto().subtle.verify(\n                'RSASSA-PKCS1-v1_5',\n                publicKey,\n                ser.hexToUint8Array(signature.signature),\n                resultingHash\n            );\n        \n            if (verified) {\n                return true;\n            }\n        }\n    \n        return false;\n    }\n  \n    async matchEthKeyToSignature({ actor, transaction }: { actor: string, transaction: Transaction }) {\n        // 0. Destructure\n        const { signature, nonce, trx }: {\n            signature: { auth_data: string; signature: string; client_json: string },\n            nonce: number,\n            trx: ApiInterfaces.Transaction\n        } = transaction.actions[0].data\n\n        // 1. Get user creds\n        let creds = await this.rpc.fetchCredentials(actor);\n    \n        // 2. Filter RSA\n        creds = creds.filter((cred) => cred.key.key[0] === 'eth_public_key');\n    \n        // 3. For each cred\n        for (const cred of creds) {\n            // Create key\n            const ethKey = '0x' + cred.key.key[1];\n\n            // Create TX Digest\n            const signBuf = new ser.SerialBuffer();\n            const serializedTransaction = this.serializeTransaction(trx);\n            signBuf.pushArray(serializedTransaction);\n            signBuf.pushNumberAsUint64(nonce);\n            \n            const actualDigestArray = await this.sha256Digest(signBuf.asUint8Array().slice());\n            const actualDigest = ser.arrayToHex(actualDigestArray);\n\n            // Create signature\n            const ethSignature = '0x' + signature.signature;\n\n            // Verify\n            const signedWithKey = this.getRecoverPersonalSignature()({\n                data: actualDigest,\n                sig: ethSignature,\n            });\n\n            if (signedWithKey === ethKey) {\n                return true;\n            }\n        }\n    \n        return false;\n    }\n\n    public async matchWaKeyToSignature({ signature, key, digest }: { signature: string, key: string, digest: string }) {\n        try {\n          // Decode WA Signature data\n          const fullSignature = Numeric.stringToSignature(signature);\n          const sigData = new ser.SerialBuffer({ array: fullSignature.data });\n      \n          // Create R1\n          const r1Signature = new Signature({\n            type: Numeric.KeyType.r1,\n            data: sigData.getUint8Array(65),\n          }, new ec('p256'));\n      \n          // Recreate the data the browser actually signed\n          const authenticatorData = sigData.getBytes().slice();\n          const clientDataJSON = sigData.getBytes().slice();\n      \n          const whatItReallySigned = new ser.SerialBuffer();\n          whatItReallySigned.pushArray(authenticatorData);\n          whatItReallySigned.pushArray(await this.sha256Digest(clientDataJSON));\n      \n          // Recover public key\n          const recoveredR1Key = r1Signature.recover(whatItReallySigned.asUint8Array());\n      \n          // Create actual R1 Pub Key\n          const waPublicKey = PublicKey.fromString(key);\n          const actualR1KeyBuffer = new ser.SerialBuffer({\n            array: waPublicKey.key.data.slice(0, 33),\n          });\n          const actualR1Key = Numeric.publicKeyToString({\n            type: Numeric.KeyType.r1,\n            data: actualR1KeyBuffer.asUint8Array(),\n          });\n      \n          return recoveredR1Key.toString() === actualR1Key && r1Signature.verify(digest, recoveredR1Key, false);\n        } catch (e) {\n          return false\n        }\n    }\n\n    public async checkIfKeysMatchTransaction ({\n        actor,\n        permission,\n        transaction,\n        signatures,\n        chainId\n    }: {\n        actor: string,\n        permission: string,\n        transaction: any,\n        signatures: string[],\n        chainId?: string\n    }) {\n        // Copy by value\n        transaction = JSON.parse(JSON.stringify(transaction))\n        signatures = JSON.parse(JSON.stringify(signatures))\n\n        // RSA / ETH WA\n        if (\n            transaction.actions.length === 1 &&\n            transaction.actions[0].account === 'webauthn' &&\n            transaction.actions[0].name === 'exec' &&\n            permission === 'active'\n        ) {\n            // Destructure\n            const webauthTransaction = transaction.actions[0].data.trx\n            console.dir(webauthTransaction, { depth: null })\n\n            if (webauthTransaction.actions.length !== 1) {\n                return false\n            }\n\n            // Check authorization\n            for (const action of webauthTransaction.actions) {\n                for (const authorization of action.authorization) {\n                    if (authorization.actor !== actor || authorization.permission !== permission) {\n                        return false\n                    }\n                }\n            }\n\n            const typeOfKey = transaction.actions[0].data.key.key[0]\n            if (typeOfKey === 'eth_public_key') {\n                return this.matchEthKeyToSignature({ transaction, actor })\n            } else if (typeOfKey === 'rsa_public_key') {\n                return this.matchRsaKeyToSignature({ transaction, actor })\n            } else {\n                console.log(`Key type ${typeOfKey} not supported`)\n                return false\n            }\n        // normal keys\n        } else {\n            // Check authorization\n            for (const action of transaction.actions) {\n                for (const authorization of action.authorization) {\n                    if (authorization.actor !== actor || authorization.permission !== permission) {\n                        return false\n                    }\n                }\n            }\n\n            // Get chain ID\n            if (!chainId) {\n                const info = await this.rpc.get_info()\n                chainId = info.chain_id\n            }\n        \n            // Serialize\n            transaction.context_free_actions = await this.serializeActions(transaction.context_free_actions || []),\n            transaction.actions = await this.serializeActions(transaction.actions)\n    \n            const serializedTransaction = this.serializeTransaction(transaction);\n            const serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);\n    \n            const signature = Signature.fromString(signatures[0])\n            const signatureType = signature.getType()\n            const digest = digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData)\n        \n            // Check keys\n            const keys = await this.getAccountKeys(actor, permission)\n            const verified = keys.some((key: string) => {\n                const publicKey = PublicKey.fromString(key)\n    \n                if (signatureType === Numeric.KeyType.wa) {\n                    return this.matchWaKeyToSignature({\n                        signature: signature.toString(),\n                        key: publicKey.toString(),\n                        digest\n                    })\n                }  else if ([Numeric.KeyType.k1, Numeric.KeyType.r1].includes(signatureType)) {\n                    return signature.verify(digest, publicKey, false)\n                } else {\n                    console.log(`Key type ${signatureType} not supported`)\n                    return false\n                }\n            })\n            return verified\n        }\n    }\n} // Api\n\nexport class TransactionBuilder {\n    private api: Api;\n    private actions: ActionBuilder[] = [];\n    private contextFreeGroups: ContextFreeGroupCallback[] = [];\n    constructor(api: Api) {\n        this.api = api;\n    }\n\n    public with(accountName: string): ActionBuilder {\n        const actionBuilder = new ActionBuilder(this.api, accountName);\n        this.actions.push(actionBuilder);\n        return actionBuilder;\n    }\n\n    public associateContextFree(contextFreeGroup: ContextFreeGroupCallback): TransactionBuilder {\n        this.contextFreeGroups.push(contextFreeGroup);\n        return this;\n    }\n\n    public async send(config?: TransactConfig): Promise<PushTransactionArgs|ReadOnlyTransactResult|TransactResult> {\n        const contextFreeDataSet: Uint8Array[] = [];\n        const contextFreeActions: ser.SerializedAction[] = [];\n        const actions: ser.SerializedAction[] = this.actions.map((actionBuilder) => actionBuilder.serializedData as ser.SerializedAction);\n        await Promise.all(this.contextFreeGroups.map(\n            async (contextFreeCallback: ContextFreeGroupCallback) => {\n                const { action, contextFreeAction, contextFreeData } = contextFreeCallback({\n                    cfd: contextFreeDataSet.length,\n                    cfa: contextFreeActions.length\n                });\n                if (action) {\n                    actions.push(action);\n                }\n                if (contextFreeAction) {\n                    contextFreeActions.push(contextFreeAction);\n                }\n                if (contextFreeData) {\n                    contextFreeDataSet.push(contextFreeData);\n                }\n            }\n        ));\n        this.contextFreeGroups = [];\n        this.actions = [];\n        return await this.api.transact({\n            context_free_data: contextFreeDataSet,\n            context_free_actions: contextFreeActions,\n            actions\n        }, config);\n    }\n}\n\nexport class ActionBuilder {\n    private api: Api;\n    private readonly accountName: string;\n    public serializedData: ser.SerializedAction | undefined;\n\n    constructor(api: Api, accountName: string) {\n        this.api = api;\n        this.accountName = accountName;\n    }\n\n    public as(actorName: string | ser.Authorization[] = []): ActionSerializerType {\n        let authorization: ser.Authorization[] = [];\n        if (actorName && typeof actorName === 'string') {\n            authorization = [{ actor: actorName, permission: 'active'}];\n        } else {\n            authorization = actorName as ser.Authorization[];\n        }\n\n        return new ActionSerializer(this, this.api, this.accountName, authorization) as ActionSerializerType;\n    }\n}\n\nclass ActionSerializer implements ActionSerializerType {\n    constructor(\n        parent: ActionBuilder,\n        api: Api,\n        accountName: string,\n        authorization: ser.Authorization[],\n    ) {\n        const jsonAbi = api.cachedAbis.get(accountName);\n        if (!jsonAbi) {\n            throw new Error('ABI must be cached before using ActionBuilder, run api.getAbi()');\n        }\n        const types = ser.getTypesFromAbi(ser.createInitialTypes(), jsonAbi.abi);\n        const actions = new Map<string, ser.Type>();\n        for (const { name, type } of jsonAbi.abi.actions) {\n            actions.set(name, ser.getType(types, type));\n        }\n        actions.forEach((type, name) => {\n            Object.assign(this, {\n                [name]: (...args: any[]) => {\n                    const data: { [key: string]: any } = {};\n                    args.forEach((arg, index) => {\n                        const field = type.fields[index];\n                        data[field.name] = arg;\n                    });\n                    const serializedData = ser.serializeAction(\n                        { types, actions },\n                        accountName,\n                        name,\n                        authorization,\n                        data,\n                    );\n                    parent.serializedData = serializedData;\n                    return serializedData;\n                }\n            });\n        });\n    }\n}\n","/**\n * @module RPC-Error\n */\n\n/** Holds detailed error information */\nexport class RpcError extends Error {\n    /** Detailed error information */\n    public json: any;\n    public details: any;\n\n    constructor(json: any) {\n        if (json && json.error && json.error.details && json.error.details.length && json.error.details[0].message) {\n            super(json.error.details[0].message);\n            this.details = json.error.details;\n        } else if (json && json.processed && json.processed.except && json.processed.except.message) {\n            super(json.processed.except.message);\n            this.details = json.processed.except;\n        }else if (json && json.result && json.result.except && json.result.except.message) {\n            super(json.result.except.message);\n            this.details = json.result.except;\n        } else if(json) {\n            super(json.message);\n        } else {\n            super(json);\n        }\n        Object.setPrototypeOf(this, RpcError.prototype);\n        this.json = json;\n    }\n}\n","import type { JsonRpc } from './index'\nimport type { KycProvider, UserInfo, WaKey } from './types';\n\n\n/**\n * Checks blockchain for a list of kycproviders, and sorts through the ones that are blacklisted.\n * @returns An array of strings with valid kyc provider names.\n */\n export async function getValidKycProviders(this: JsonRpc) {\n    try {\n      const { rows } = await this.get_table_rows({\n        code: 'eosio.proton',\n        table: 'kycproviders',\n        scope: 'eosio.proton',\n      });\n      this.validKycProviders = rows.reduce((acc: string[], provider: KycProvider) => {\n        if (!provider.blisted) {\n          acc.push(provider.kyc_provider)\n        }\n\n        return acc\n      }, [])\n    } catch (e) {\n      throw new Error('Unable to get KYC Providers.')\n    }\n  }\n\n/**\n * Takes an account or a list of accounts and checks to make sure that they are light-verified\n * @param account This could be an array of user rows from the usersinfo table on the blockchain, or a singular string for an account name\n * @returns An object of the user data as pulled from the usersinfo table on the blockchain with an additional key, isLightKYCVerified (boolean)\n */\nexport async function isLightKYCVerified(\n  this: JsonRpc,\n  account: UserInfo[] | string\n) {\n    const lightKyc = [\n      \"firstname\",\n      \"lastname\",\n      \"birthdate\",\n      \"address\"\n    ];\n\n    if (account.length === 0) {\n      throw new Error('Please enter an account.');\n    }\n\n    if (this.validKycProviders.length === 0) {\n      await this.getValidKycProviders();\n    }\n\n    let users: UserInfo[] = [];\n\n    if (Array.isArray(account)) {\n      users = account;\n    } else if (typeof account === 'string') {\n      try {\n        const { rows } = await this.get_table_rows({\n            code: 'eosio.proton',\n            table: 'usersinfo',\n            scope: 'eosio.proton',\n            lower_bound: account,\n            upper_bound: account,\n        });\n        \n        users = rows;\n      } catch(e) {\n        throw new Error('Account not found!');\n      }\n    }\n    \n    const resultsWithKycStatus: UserInfo[] = users.map((user: UserInfo) => {\n      const levelsResult: string[] = user.kyc.reduce((acc: string[], kyc) => {\n        if (this.validKycProviders.indexOf(kyc.kyc_provider) >= 0) {\n          const result = kyc.kyc_level.split(',').map((kycItem: string) => kycItem.split(':')[1]);\n          acc = result.concat(acc);\n        }\n\n        return acc\n      }, []);\n\n      user.isLightKYCVerified = lightKyc.every(lightKycField => levelsResult.includes(lightKycField));\n\n      return user\n    })\n\n    return resultsWithKycStatus;\n};\n\nexport async function fetchCredentials(\n  this: JsonRpc,\n  actor: string\n): Promise<WaKey[]> {\n  const { rows: credentials }: { rows: WaKey[] } = await this.get_table_rows({\n    code: 'webauthn',\n    scope: 'webauthn',\n    table: 'credentials',\n    lower_bound: actor,\n    upper_bound: actor,\n    key_type: 'name',\n    index_position: 2,\n  });\n  return credentials;\n};\n  ","import { AbiProvider, AuthorityProvider, AuthorityProviderArgs, BinaryAbi, TransactResult } from '../api/types';\nimport { RpcError } from './error';\nimport { isLightKYCVerified, getValidKycProviders, fetchCredentials } from './proton'\nimport fetch from 'cross-fetch'\nimport { base64ToBinary, convertLegacyPublicKeys } from '../api/numeric';\nimport { Authorization } from '../api/serialize';\nimport { GetAccountResult, GetBlockHeaderStateResult, GetBlockInfoResult, GetBlockResult, GetInfoResult, GetActivatedProtocolFeaturesResult, GetAbiResult, GetRawCodeAndAbiResult, GetRawAbiResult, GetCodeResult, PushTransactionArgs, AbiBinToJsonResult, AbiJsonToBinResult, DBSizeGetResult, GetAccountsByAuthorizersResult, GetActivatedProtocolFeaturesParams, GetCodeHashResult, GetCurrencyStatsResult, GetProducerScheduleResult, GetProducersResult, GetScheduledTransactionsResult, GetTableByScopeResult, GetTableRowsResult, PackedTrx, ReadOnlyTransactResult, TraceApiGetBlockResult } from './types';\n\nconst arrayToHex = (data: Uint8Array): string => {\n    let result = '';\n    for (const x of data) {\n        result += ('00' + x.toString(16)).slice(-2);\n    }\n    return result;\n};\n\n/** Make RPC calls */\nexport class JsonRpc implements AuthorityProvider, AbiProvider {\n    public endpoints: string[];\n    public maxRetries: number = 3;\n    public currentEndpoint: string;\n    public validKycProviders: string[] = [];\n\n    /**\n     * @param args\n     *`fetch`:\n     * browsers: leave `null` or `undefined`\n     * node: provide an implementation\n     */\n    constructor(endpoints: string | string[]) {\n        endpoints = Array.isArray(endpoints) ? endpoints : [endpoints];\n        this.endpoints = endpoints.map(endpoint => endpoint.replace(/\\/$/, ''))\n        this.currentEndpoint = ''\n        this.nextEndpoint();\n    }\n\n    public nextEndpoint() {\n        if (this.endpoints.length) {\n            if (this.currentEndpoint) {\n                const removed = this.endpoints.shift();\n                this.endpoints = this.endpoints.concat(removed || []);\n            }\n\n            this.currentEndpoint = this.endpoints[0];\n        }\n    }\n\n    /** Post `body` to `endpoint + path`. Throws detailed error information in `RpcError` when available. */\n    public async fetch(path: string, body: any, currentRetries: number = 0): Promise<any> {\n        let response;\n        let json;\n        try {\n            response = await fetch(this.currentEndpoint + path, {\n                body: JSON.stringify(body),\n                method: 'POST',\n            });\n            json = await response.json();\n            if (json.processed && json.processed.except) {\n                throw new RpcError(json);\n            } else if (json.result && json.result.except) {\n                throw new RpcError(json);\n            }\n        } catch (e) {\n            console.log({\n                currentEndpoint: this.currentEndpoint,\n                endpoints: this.endpoints,\n                currentRetries: currentRetries,\n                error: e\n            })\n\n            if (this.endpoints.length > 1) {\n                this.nextEndpoint()\n                if (currentRetries < this.maxRetries)  {\n                    return this.fetch(path, body, ++currentRetries)\n                } else {\n                    e.isFetchError = true;\n                    throw new RpcError(e);\n                }\n            }\n        }\n\n        if (!(response && response.ok)) {\n            throw new RpcError(json);\n        }\n\n        // Check for synced\n        if (json && json.head_block_time) {\n            const headTime = new Date(json.head_block_time + 'Z').getTime()\n            const ct = new Date().getTime()\n            const secondsBehind = (ct - headTime) / 1000\n\n            if (secondsBehind > 30 && this.endpoints.length > 1) {\n                this.nextEndpoint()\n                if (currentRetries < this.maxRetries)  {\n                    return this.fetch(path, body, ++currentRetries)\n                }\n            }\n        }\n\n        return json;\n    }\n\n    /** Get from endpoint  */\n    public async get(path: string): Promise<any> {\n        const res = await fetch(path);\n\n        if (res.status >= 400) {\n            throw new Error(\"Bad response from server \" + res.status);\n        }\n\n        const data = await res.json()\n        return data\n    }\n\n    public async abi_bin_to_json(\n        code: string,\n        action: string,\n        binargs: string,\n    ): Promise<AbiBinToJsonResult> {\n        return await this.fetch('/v1/chain/abi_bin_to_json', { code, action, binargs });\n    }\n\n    public async abi_json_to_bin(\n        code: string,\n        action: string,\n        args: any[],\n    ): Promise<AbiJsonToBinResult> {\n        return await this.fetch('/v1/chain/abi_json_to_bin', { code, action, args });\n    }\n\n    /** Raw call to `/v1/chain/get_abi` */\n    public async get_abi(accountName: string): Promise<GetAbiResult> {\n        return await this.fetch('/v1/chain/get_abi', { account_name: accountName });\n    }\n\n    /** Raw call to `/v1/chain/get_account` */\n    public async get_account(accountName: string): Promise<GetAccountResult> {\n        return await this.fetch('/v1/chain/get_account', { account_name: accountName });\n    }\n\n    /** Raw call to `/v1/chain/get_accounts_by_authorizers` */\n    public async get_accounts_by_authorizers(accounts: Authorization[], keys: string[]): Promise<GetAccountsByAuthorizersResult> {\n        return await this.fetch('/v1/chain/get_accounts_by_authorizers', { accounts, keys });\n    }\n\n    /** Raw call to `get_activated_protocol_features` */\n    public async get_activated_protocol_features({\n        limit = 10,\n        search_by_block_num = false,\n        reverse = false,\n        lower_bound,\n        upper_bound,\n    }: GetActivatedProtocolFeaturesParams): Promise<GetActivatedProtocolFeaturesResult> {\n        return await this.fetch('/v1/chain/get_activated_protocol_features', { lower_bound, upper_bound, limit, search_by_block_num, reverse });\n    }\n\n    /** Raw call to `/v1/chain/get_block_header_state` */\n    public async get_block_header_state(blockNumOrId: number | string): Promise<GetBlockHeaderStateResult> {\n        return await this.fetch('/v1/chain/get_block_header_state', { block_num_or_id: blockNumOrId });\n    }\n\n    /** Raw call to `/v1/chain/get_block_info` */\n    public async get_block_info(blockNum: number): Promise<GetBlockInfoResult> {\n        return await this.fetch('/v1/chain/get_block_info', { block_num: blockNum });\n    }\n\n    /** Raw call to `/v1/chain/get_block` */\n    public async get_block(blockNumOrId: number | string): Promise<GetBlockResult> {\n        return await this.fetch('/v1/chain/get_block', { block_num_or_id: blockNumOrId });\n    }\n\n    /** Raw call to `/v1/chain/get_code` */\n    public async get_code(accountName: string): Promise<GetCodeResult> {\n        return await this.fetch('/v1/chain/get_code', {\n            account_name: accountName,\n            code_as_wasm: true\n        });\n    }\n\n    /** Raw call to `/v1/chain/get_code_hash` */\n    public async get_code_hash(accountName: string): Promise<GetCodeHashResult> {\n        return await this.fetch('/v1/chain/get_code_hash', { account_name: accountName });\n    }\n\n    /** Raw call to `/v1/chain/get_currency_balance` */\n    public async get_currency_balance(code: string, account: string, symbol: string): Promise<string[]> {\n        return await this.fetch('/v1/chain/get_currency_balance', { code, account, symbol });\n    }\n\n    /** Raw call to `/v1/chain/get_currency_stats` */\n    public async get_currency_stats(code: string, symbol: string): Promise<GetCurrencyStatsResult> {\n        return await this.fetch('/v1/chain/get_currency_stats', { code, symbol });\n    }\n\n    /** Raw call to `/v1/chain/get_info` */\n    public async get_info(): Promise<GetInfoResult> {\n        return await this.fetch('/v1/chain/get_info', {});\n    }\n\n    /** Raw call to `/v1/chain/get_producer_schedule` */\n    public async get_producer_schedule(): Promise<GetProducerScheduleResult> {\n        return await this.fetch('/v1/chain/get_producer_schedule', {});\n    }\n\n    /** Raw call to `/v1/chain/get_producers` */\n    public async get_producers(json = true, lowerBound = '', limit = 50): Promise<GetProducersResult> {\n        return await this.fetch('/v1/chain/get_producers', { json, lower_bound: lowerBound, limit });\n    }\n\n    /** Raw call to `/v1/chain/get_raw_code_and_abi` */\n    public async get_raw_code_and_abi(accountName: string): Promise<GetRawCodeAndAbiResult> {\n        return await this.fetch('/v1/chain/get_raw_code_and_abi', { account_name: accountName });\n    }\n\n    /** calls `/v1/chain/get_raw_code_and_abi` and pulls out unneeded raw wasm code */\n    public async getRawAbi(accountName: string): Promise<BinaryAbi> {\n        const rawAbi = await this.get_raw_abi(accountName);\n        const abi = base64ToBinary(rawAbi.abi);\n        return { accountName: rawAbi.account_name, abi };\n    }\n\n    /** Raw call to `/v1/chain/get_raw_abi` */\n    public async get_raw_abi(accountName: string): Promise<GetRawAbiResult> {\n        return await this.fetch('/v1/chain/get_raw_abi', { account_name: accountName });\n    }\n\n    /** Raw call to `/v1/chain/get_scheduled_transactions` */\n    public async get_scheduled_transactions(json = true, lowerBound = '', limit = 50): Promise<GetScheduledTransactionsResult> {\n        return await this.fetch('/v1/chain/get_scheduled_transactions', { json, lower_bound: lowerBound, limit });\n    }\n\n    /** Raw call to `/v1/chain/get_table_rows` */\n    public async get_table_rows({\n        json = true,\n        code,\n        scope,\n        table,\n        lower_bound = '',\n        upper_bound = '',\n        index_position = 1,\n        key_type = '',\n        limit = 10,\n        reverse = false,\n        show_payer = false,\n    }: any): Promise<GetTableRowsResult> {\n        return await this.fetch(\n            '/v1/chain/get_table_rows', {\n                json,\n                code,\n                scope,\n                table,\n                lower_bound,\n                upper_bound,\n                index_position,\n                key_type,\n                limit,\n                reverse,\n                show_payer,\n            });\n    }\n\n    /** Raw call to `/v1/chain/get_kv_table_rows` */\n    public async get_kv_table_rows({\n        json = true,\n        code,\n        table,\n        index_name,\n        encode_type = 'bytes',\n        index_value,\n        lower_bound,\n        upper_bound,\n        limit = 10,\n        reverse = false,\n        show_payer = false,\n    }: any): Promise<GetTableRowsResult> {\n        return await this.fetch(\n            '/v1/chain/get_kv_table_rows', {\n                json,\n                code,\n                table,\n                index_name,\n                encode_type,\n                index_value,\n                lower_bound,\n                upper_bound,\n                limit,\n                reverse,\n                show_payer,\n            });\n    }\n\n    /** Raw call to `/v1/chain/get_table_by_scope` */\n    public async get_table_by_scope({\n        code,\n        table,\n        lower_bound = '',\n        upper_bound = '',\n        limit = 10,\n    }: any): Promise<GetTableByScopeResult> {\n        return await this.fetch(\n            '/v1/chain/get_table_by_scope', {\n                code,\n                table,\n                lower_bound,\n                upper_bound,\n                limit,\n            });\n    }\n\n    /** Get subset of `availableKeys` needed to meet authorities in `transaction`. Implements `AuthorityProvider` */\n    public async getRequiredKeys(args: AuthorityProviderArgs): Promise<string[]> {\n        const requiredKeys = await this.fetch('/v1/chain/get_required_keys', {\n            transaction: args.transaction,\n            available_keys: args.availableKeys,\n        })\n        return convertLegacyPublicKeys(requiredKeys.required_keys);\n    }\n\n    /** Push a serialized transaction (replaced by send_transaction, but returned format has changed) */\n    public async push_transaction(\n        { signatures, compression = 0, serializedTransaction, serializedContextFreeData }: PushTransactionArgs\n    ): Promise<TransactResult> {\n            try {\n            return await this.fetch('/v1/chain/push_transaction', {\n                signatures,\n                compression,\n                packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),\n                packed_trx: arrayToHex(serializedTransaction),\n            });\n        } catch (e) {\n            if (e && e.json && e.json.error) {\n                const expired = e.json.error.name === 'expired_tx_exception'\n                if (expired) {\n                    e.json.error.message = 'Transaction Expired: Try Again'\n                    this.nextEndpoint()\n                }\n            }\n            throw e\n        }\n    }\n    \n    /** Raw call to `/v1/chain/push_ro_transaction */\n    public async push_ro_transaction({ signatures, compression = 0, serializedTransaction }: PushTransactionArgs,\n        returnFailureTraces: boolean = false): Promise<ReadOnlyTransactResult> {\n        return await this.fetch('/v1/chain/push_ro_transaction', {\n            transaction: {\n                signatures,\n                compression,\n                packed_context_free_data: arrayToHex(new Uint8Array(0)),\n                packed_trx: arrayToHex(serializedTransaction),\n            },\n            return_failure_traces: returnFailureTraces,\n        });\n    }\n\n    public async push_transactions(transactions: PushTransactionArgs[]): Promise<TransactResult[]> {\n        const packedTrxs: PackedTrx[] = transactions.map(({signatures, compression = 0, serializedTransaction, serializedContextFreeData }: PushTransactionArgs) => {\n            return {\n                signatures,\n                compression,\n                packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),\n                packed_trx: arrayToHex(serializedTransaction),\n            };\n        });\n        return await this.fetch('/v1/chain/push_transactions', packedTrxs );\n    }\n\n    /** Send a serialized transaction */\n    public async send_transaction(\n        { signatures, compression = 0, serializedTransaction, serializedContextFreeData }: PushTransactionArgs\n    ): Promise<TransactResult> {\n            return await this.fetch('/v1/chain/send_transaction', {\n            signatures,\n            compression,\n            packed_context_free_data: arrayToHex(serializedContextFreeData || new Uint8Array(0)),\n            packed_trx: arrayToHex(serializedTransaction),\n        });\n    }\n\n    /** Raw call to `/v1/db_size/get` */\n    public async db_size_get(): Promise<DBSizeGetResult> { return await this.fetch('/v1/db_size/get', {}); }\n\n    /** Raw call to `/v1/trace_api/get_block` */\n    public async trace_get_block(block_num: number): Promise<TraceApiGetBlockResult> {\n        return await this.fetch('/v1/trace_api/get_block', { block_num });\n    }\n\n    /** Raw call to `/v1/history/get_actions` */\n    public async history_get_actions(accountName: string, pos: number | null = null, offset: number | null = null) {\n        return await this.fetch('/v1/history/get_actions', { account_name: accountName, pos, offset });\n    }\n\n    /** Raw call to `/v1/history/get_transaction` */\n    public async history_get_transaction(id: string, blockNumHint: number | null = null) {\n        return await this.fetch('/v1/history/get_transaction', { id, block_num_hint: blockNumHint });\n    }\n\n    /** Raw call to `/v1/history/get_key_accounts` */\n    public async history_get_key_accounts(publicKey: string) {\n        return await this.fetch('/v1/history/get_key_accounts', { public_key: publicKey });\n    }\n\n    /** Raw call to `/v1/history/get_controlled_accounts` */\n    public async history_get_controlled_accounts(controllingAccount: string) {\n        return await this.fetch('/v1/history/get_controlled_accounts', { controlling_account: controllingAccount });\n    }\n\n    public isLightKYCVerified = isLightKYCVerified\n    public getValidKycProviders = getValidKycProviders\n    public fetchCredentials = fetchCredentials\n} // JsonRpc\n\nexport { RpcError } from './error';","/**\n * @module WebAuthn-Sig\n */\n// copyright defined in eosjs/LICENSE.txt\n\nimport { SignatureProvider, SignatureProviderArgs } from '../api/types';\nimport * as ser from '../api/serialize';\nimport * as numeric from '../api/numeric';\nimport { ec } from 'elliptic';\n\n/** Signs transactions using WebAuthn */\nexport class WebAuthnSignatureProvider implements SignatureProvider {\n    /** Map public key to credential ID (hex). User must populate this. */\n    public keys = new Map<string, string>();\n\n    /** Public keys that the `SignatureProvider` holds */\n    public async getAvailableKeys() {\n        return Array.from(this.keys.keys());\n    }\n\n    /** Sign a transaction */\n    public async sign(\n        { chainId, requiredKeys, serializedTransaction, serializedContextFreeData }: SignatureProviderArgs,\n    ) {\n        const signBuf = new ser.SerialBuffer();\n        signBuf.pushArray(ser.hexToUint8Array(chainId));\n        signBuf.pushArray(serializedTransaction);\n        if (serializedContextFreeData) {\n            signBuf.pushArray(new Uint8Array(await crypto.subtle.digest('SHA-256', serializedContextFreeData.buffer)));\n        } else {\n            signBuf.pushArray(new Uint8Array(32));\n        }\n        const digest = new Uint8Array(await crypto.subtle.digest('SHA-256', signBuf.asUint8Array().slice().buffer));\n\n        const signatures = [] as string[];\n        for (const key of requiredKeys) {\n            const id = ser.hexToUint8Array(this.keys.get(key) as string);\n            const assertion = await (navigator as any).credentials.get({\n                publicKey: {\n                    timeout: 60000,\n                    allowCredentials: [{\n                        id,\n                        type: 'public-key',\n                    }],\n                    challenge: digest.buffer,\n                },\n            });\n            const e = new ec('p256') as any; // https://github.com/indutny/elliptic/pull/232\n            const pubKey = e.keyFromPublic(numeric.stringToPublicKey(key).data.subarray(0, 33)).getPublic();\n\n            const fixup = (x: Uint8Array) => {\n                const a = Array.from(x);\n                while (a.length < 32) {\n                    a.unshift(0);\n                }\n                while (a.length > 32) {\n                    if (a.shift() !== 0) {\n                        throw new Error('Signature has an r or s that is too big');\n                    }\n                }\n                return new Uint8Array(a);\n            };\n\n            const der = new ser.SerialBuffer({ array: new Uint8Array(assertion.response.signature) });\n            if (der.get() !== 0x30) {\n                throw new Error('Signature missing DER prefix');\n            }\n            if (der.get() !== der.array.length - 2) {\n                throw new Error('Signature has bad length');\n            }\n            if (der.get() !== 0x02) {\n                throw new Error('Signature has bad r marker');\n            }\n            const r = fixup(der.getUint8Array(der.get()));\n            if (der.get() !== 0x02) {\n                throw new Error('Signature has bad s marker');\n            }\n            const s = fixup(der.getUint8Array(der.get()));\n\n            const whatItReallySigned = new ser.SerialBuffer();\n            whatItReallySigned.pushArray(new Uint8Array(assertion.response.authenticatorData));\n            whatItReallySigned.pushArray(new Uint8Array(\n                await crypto.subtle.digest('SHA-256', assertion.response.clientDataJSON)));\n            const hash = new Uint8Array(\n                await crypto.subtle.digest('SHA-256', whatItReallySigned.asUint8Array().slice()));\n            const recid = e.getKeyRecoveryParam(hash, new Uint8Array(assertion.response.signature), pubKey);\n\n            const sigData = new ser.SerialBuffer();\n            sigData.push(recid + 27 + 4);\n            sigData.pushArray(r);\n            sigData.pushArray(s);\n            sigData.pushBytes(new Uint8Array(assertion.response.authenticatorData));\n            sigData.pushBytes(new Uint8Array(assertion.response.clientDataJSON));\n\n            const sig = numeric.signatureToString({\n                type: numeric.KeyType.wa,\n                data: sigData.asUint8Array().slice(),\n            });\n            signatures.push(sig);\n        }\n        return { signatures, serializedTransaction, serializedContextFreeData };\n    }\n}\n","import { Api } from './api';\n\nimport * as ApiInterfaces from './api/types';\n\nimport { JsonRpc, RpcError } from './rpc';\nimport * as RpcInterfaces from './rpc/types';\n\nimport * as Numeric from './api/numeric';\nimport * as Serialize from './api/serialize';\n\nimport { JsSignatureProvider, digestFromSerializedData } from './cryptography/jsSignatureProvider';\nimport { WebAuthnSignatureProvider } from './cryptography/webauthn'\n\nimport * as Key from './cryptography/key'\nimport { sha256 } from './cryptography/conversions'\n\nexport {\n  Api,\n  ApiInterfaces,\n  JsonRpc,\n  Numeric,\n  RpcInterfaces,\n  RpcError,\n  Serialize,\n  JsSignatureProvider,\n  WebAuthnSignatureProvider,\n  digestFromSerializedData,\n  Key,\n  sha256,\n};\n\nexport default {\n  Api,\n  ApiInterfaces,\n  JsonRpc,\n  Numeric,\n  RpcInterfaces,\n  RpcError,\n  Serialize,\n  JsSignatureProvider,\n  Key,\n  sha256,\n  WebAuthnSignatureProvider\n};\n"],"names":["KeyType","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","ripemd160","RIPEMD160","hash","base58Chars","base64Chars","base58Map","base58M","Array","fill","charCodeAt","create_base58_map","base64Map","base64M","create_base64_map","isNegative","bignum","negate","carry","x","decimalToBinary","size","s","Uint8Array","srcDigit","j","signedDecimalToBinary","negative","substr","binaryToDecimal","minDigits","String","fromCharCode","signedBinaryToDecimal","base58ToBinary","base58ToBinaryVarSize","binaryToBase58","base64ToBinary","len","groups","bytes","group","digit0","digit1","digit2","digit3","digestSuffixRipemd160","data","suffix","d","stringToKey","whole","buffer","digest","keyToString","prefix","stringToPublicKey","publicKeyDataSize","k1","r1","wa","publicKeyToLegacyString","publicKeyToString","convertLegacyPublicKey","convertLegacyPublicKeys","map","stringToPrivateKey","privateKeyDataSize","privateKeyToLegacyString","byte","sha256","update","privateKeyToString","stringToSignature","signatureToString","signature","SerializerState","options","skippedBinaryExtension","SerialBuffer","array","textEncoder","textDecoder","readPos","TextEncoder","TextDecoder","reserve","l","Math","ceil","newArray","set","haveReadData","restartRead","asUint8Array","byteOffset","pushArray","v","get","pushUint8ArrayChecked","getUint8Array","skip","pushUint16","getUint16","pushUint32","getUint32","pushNumberAsUint64","floor","getUint64AsNumber","low","pushVaruint32","getVaruint32","bit","b","pushVarint32","getVarint32","pushFloat32","Float32Array","getFloat32","pushFloat64","Float64Array","getFloat64","pushName","RegExp","test","charToSymbol","c","a","getName","endsWith","pushBytes","getBytes","pushString","encode","getString","decode","pushSymbolCode","getSymbolCode","pushSymbol","precision","getSymbol","pushAsset","pos","amount","trim","foundDigit","numeric","getAsset","pushPublicKey","getPublicKey","begin","pushPrivateKey","getPrivateKey","pushSignature","getSignature","supportedAbiVersion","version","startsWith","checkDateParse","date","Date","parse","Number","dateToTimePoint","round","timePointToDate","us","toISOString","dateToTimePointSec","timePointSecToDate","sec","dateToBlockTimestamp","blockTimestampToDate","slot","stringToSymbol","m","match","symbolToString","arrayToHex","toUpperCase","hexToUint8Array","hex","parseInt","serializeUnknown","_","__","deserializeUnknown","serializeStruct","allowExtensions","JSON","stringify","base","serialize","fields","field","extensionOf","deserializeStruct","deserialize","serializeVariant","isArray","findIndex","deserializeVariant","serializeArray","arrayOf","deserializeArray","serializeOptional","optionalOf","deserializeOptional","serializeExtension","deserializeExtension","serializeObject","entries","dataType","deserializeObject","serializePair","item","_this","deserializePair","createType","attrs","aliasOfName","baseName","checkRange","orig","converted","createInitialTypes","Map","bool","uint8","int8","uint16","int16","uint32","uint64","int64","int32","varuint32","varint32","uint128","int128","float32","float64","float128","bytesAsUint8Array","string","time_point","time_point_sec","block_timestamp_type","symbol_code","symbol","asset","checksum160","checksum256","checksum512","public_key","private_key","typeName","createAbiTypes","initialTypes","createTransactionExtensionTypes","createTransactionTypes","getType","types","getTypesFromAbi","abi","new_type_name","structs","variants","transactionHeader","refBlock","expireSeconds","h","timestamp","header","id","expiration","ref_block_num","block_num","ref_block_prefix","serializeActionData","contract","account","action","actions","serializeAction","authorization","deserializeActionData","deserializeAction","serializeAnyvar","anyvar","def","anyvarDefs","null_t","any_array","any_object","index","deserializeAnyvar","defIndex","anyvarDefsByIndex","useShortForm","deserializeAnyvarShort","serializeAnyObject","deserializeAnyObject","serializeAnyArray","arr","deserializeAnyArray","additionalTypes","addAdditionalTypes","serializeQuery","query","filter","b64tob64u","replace","constructElliptic","EC","PublicKey","ec","fromString","publicKeyStr","fromElliptic","publicKey","keyType","getPublic","getX","toArray","y","getY","concat","toLegacyString","toElliptic","keyPair","pub","Buffer","from","isValid","validate","BN","require","Signature","sig","ellipticSig","recoveryParam","eosioRecoveryParam","r","sigData","ellipticRecoveryBitField","lengthOfR","toBinary","verify","shouldHash","encoding","ellipticSignature","ellipticPublicKey","recover","recoveredPublicKey","recoverPubKey","ellipticKPub","keyFromPublic","PrivateKey","privKey","getPrivate","toArrayLike","keyString","privateKey","keyFromPrivate","ellipticPrivateKey","sign","tries","constructSignature","canonical","pers","secureEnv","ellipticKeyPair","genKeyPair","ecOptions","defaultEc","digestFromSerializedData","chainId","serializedTransaction","serializedContextFreeData","e","signBuf","JsSignatureProvider","privateKeys","availableKeys","priv","privElliptic","pubStr","getAvailableKeys","requiredKeys","signatures","Api","args","rpc","authorityProvider","abiProvider","signatureProvider","abiTypes","transactionTypes","contracts","cachedAbis","crypto","recoverPersonalSignature","transactionExtensions","ser","window","global","getCrypto","getRecoverPersonalSignature","rawAbiToJson","rawAbi","jsonToRawAbi","jsonAbi","getCachedAbi","accountName","reload","getRawAbi","cachedAbi","message","_context","getAbi","getTransactionAbis","transaction","context_free_actions","accounts","uniqueAccounts","Set","actionPromises","all","getContract","serializeTransaction","max_net_usage_words","max_cpu_usage_ms","delay_sec","transaction_extensions","serializeContextFreeData","contextFreeData","deserializeTransaction","serializeTransactionExtensions","resource_payer","extensionBuffer","deserializeTransactionExtensions","extensionData","transactionExtension","_this2","find","extension","deserializedObj","max_net_bytes","max_cpu_us","max_memory_bytes","deleteTransactionExtensionObjects","serializeActions","_this3","deserializeActions","_this4","deserializeActionsSync","deserializedActions","deserializeTransactionWithActions","deserializedTransaction","deserializedCFActions","deflateSerializedArray","serializedArray","deflate","level","inflateSerializedArray","compressedSerializedArray","inflate","transact","broadcast","readOnlyTrx","returnFailureTraces","compression","blocksBehind","useLastIrreversible","get_info","generateTapos","hasRequiredTaposFields","abis","context_free_data","pushTransactionArgs","getRequiredKeys","chain_id","pushCompressedSignedTransaction","pushSignedTransaction","transactWithDelay","params","delay","wait","ms","setTimeout","success","short","tryRefBlockFromGetInfo","queryBuffer","send_transaction","returnBuffer","processed","action_traces","return_value","push_ro_transaction","push_transaction","compressedSerializedTransaction","compressedSerializedContextFreeData","taposBlockNumber","head_block_num","last_irreversible_block_num","tryGetBlockInfo","tryGetBlockHeaderState","get_block_header_state","blockNumber","get_block_info","get_block","last_irreversible_block_id","last_irreversible_block_time","block","ActionBuilder","buildTransaction","cb","tx","TransactionBuilder","getAccountKeys","actor","permission","get_account","relevantPermission","permissions","perm_name","required_auth","console","log","sha256Digest","byteLength","subtle","matchRsaKeyToSignature","nonce","trx","fetchCredentials","creds","cred","rsaKey","exponentBase64","exponent","modulusBase64","modulus","clientJson","client_json","signedDigest","base64url","toBuffer","challenge","actualDigest","importKey","kty","n","alg","ext","authData","auth_data","clientJsonHash","resultingHash","matchEthKeyToSignature","ethKey","ethSignature","matchWaKeyToSignature","fullSignature","Numeric","r1Signature","authenticatorData","clientDataJSON","whatItReallySigned","recoveredR1Key","waPublicKey","actualR1KeyBuffer","actualR1Key","checkIfKeysMatchTransaction","webauthTransaction","dir","depth","typeOfKey","signatureType","verified","some","_this5","includes","api","contextFreeGroups","actionBuilder","associateContextFree","contextFreeGroup","send","config","contextFreeDataSet","contextFreeActions","serializedData","contextFreeCallback","cfd","cfa","contextFreeAction","as","actorName","ActionSerializer","parent","assign","_this6","RpcError","json","details","except","getValidKycProviders","get_table_rows","code","table","scope","validKycProviders","rows","reduce","acc","provider","blisted","kyc_provider","isLightKYCVerified","lightKyc","users","lower_bound","upper_bound","resultsWithKycStatus","user","levelsResult","kyc","indexOf","kyc_level","split","kycItem","every","lightKycField","key_type","index_position","JsonRpc","endpoints","maxRetries","currentEndpoint","endpoint","nextEndpoint","removed","shift","fetch","path","body","currentRetries","response","isFetchError","ok","head_block_time","headTime","getTime","res","status","abi_bin_to_json","binargs","abi_json_to_bin","get_abi","account_name","get_accounts_by_authorizers","get_activated_protocol_features","limit","search_by_block_num","blockNumOrId","block_num_or_id","blockNum","get_code","code_as_wasm","get_code_hash","get_currency_balance","get_currency_stats","get_producer_schedule","get_producers","lowerBound","get_raw_code_and_abi","get_raw_abi","get_scheduled_transactions","show_payer","get_kv_table_rows","index_name","encode_type","index_value","get_table_by_scope","available_keys","required_keys","packed_context_free_data","packed_trx","_context27","return_failure_traces","push_transactions","transactions","packedTrxs","db_size_get","trace_get_block","history_get_actions","offset","history_get_transaction","blockNumHint","block_num_hint","history_get_key_accounts","history_get_controlled_accounts","controllingAccount","controlling_account","WebAuthnSignatureProvider","navigator","credentials","timeout","allowCredentials","assertion","pubKey","subarray","fixup","unshift","der","recid","getKeyRecoveryParam","ApiInterfaces","RpcInterfaces","Serialize","Key"],"mappings":"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"}