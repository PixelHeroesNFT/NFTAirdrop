{"version":3,"file":"signing-request.cjs.production.min.js","sources":["../src/base64u.ts","../../../node_modules/regenerator-runtime/runtime.js","../src/abi.ts","../src/signing-request.ts"],"sourcesContent":["/**\n * Base64u - URL-Safe Base64 variant no padding.\n * Based on https://gist.github.com/jonleighton/958841\n */\n\nconst charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'\nconst lookup = new Uint8Array(256)\nfor (let i = 0; i < 64; i++) {\n    lookup[charset.charCodeAt(i)] = i\n}\n\nexport function encode(data: Uint8Array): string {\n    const byteLength = data.byteLength\n    const byteRemainder = byteLength % 3\n    const mainLength = byteLength - byteRemainder\n\n    const parts: string[] = []\n\n    let a: number\n    let b: number\n    let c: number\n    let d: number\n    let chunk: number\n\n    // Main loop deals with bytes in chunks of 3\n    for (let i = 0; i < mainLength; i += 3) {\n        // Combine the three bytes into a single integer\n        chunk = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2]\n\n        // Use bitmasks to extract 6-bit segments from the triplet\n        a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18\n        b = (chunk & 258048) >> 12 // 258048   = (2^6 - 1) << 12\n        c = (chunk & 4032) >> 6 // 4032     = (2^6 - 1) << 6\n        d = chunk & 63 // 63       =  2^6 - 1\n\n        // Convert the raw binary segments to the appropriate ASCII encoding\n        parts.push(charset[a] + charset[b] + charset[c] + charset[d])\n    }\n\n    // Deal with the remaining bytes\n    if (byteRemainder === 1) {\n        chunk = data[mainLength]\n\n        a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2\n\n        // Set the 4 least significant bits to zero\n        b = (chunk & 3) << 4 // 3   = 2^2 - 1\n\n        parts.push(charset[a] + charset[b])\n    } else if (byteRemainder === 2) {\n        chunk = (data[mainLength] << 8) | data[mainLength + 1]\n\n        a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10\n        b = (chunk & 1008) >> 4 // 1008  = (2^6 - 1) << 4\n\n        // Set the 2 least significant bits to zero\n        c = (chunk & 15) << 2 // 15    = 2^4 - 1\n\n        parts.push(charset[a] + charset[b] + charset[c])\n    }\n\n    return parts.join('')\n}\n\nexport function decode(input: string): Uint8Array {\n    const byteLength = input.length * 0.75\n    const data = new Uint8Array(byteLength)\n\n    let a: number\n    let b: number\n    let c: number\n    let d: number\n    let p: number = 0\n\n    for (let i = 0; i < input.length; i += 4) {\n        a = lookup[input.charCodeAt(i)]\n        b = lookup[input.charCodeAt(i + 1)]\n        c = lookup[input.charCodeAt(i + 2)]\n        d = lookup[input.charCodeAt(i + 3)]\n\n        data[p++] = (a << 2) | (b >> 4)\n        data[p++] = ((b & 15) << 4) | (c >> 2)\n        data[p++] = ((c & 3) << 6) | (d & 63)\n    }\n\n    return data\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","/** SigningRequest ABI and typedefs. */\n\nexport type AccountName = string /*name*/\nexport type ActionName = string /*name*/\nexport type PermissionName = string /*name*/\nexport type ChainAlias = number /*uint8*/\nexport type ChainId = string /*checksum256*/\nexport type VariantId = ['chain_alias', ChainAlias] | ['chain_id', ChainId]\nexport type VariantReq =\n    | ['action', Action]\n    | ['action[]', Action[]]\n    | ['transaction', Transaction]\n    | ['identity', Identity]\n\nexport interface PermissionLevel {\n    actor: AccountName\n    permission: PermissionName\n}\n\nexport type RequestFlags = number\nexport const RequestFlagsNone = 0\nexport const RequestFlagsBroadcast = 1 << 0\nexport const RequestFlagsBackground = 1 << 1\n\nexport interface Action {\n    account: AccountName\n    name: ActionName\n    authorization: PermissionLevel[]\n    data: string | {[key: string]: any}\n}\n\nexport interface Extension {\n    type: number /*uint16*/\n    data: string /*bytes*/\n}\n\nexport interface TransactionHeader {\n    expiration: string /*time_point_sec*/\n    ref_block_num: number /*uint16*/\n    ref_block_prefix: number /*uint32*/\n    max_net_usage_words: number /*varuint32*/\n    max_cpu_usage_ms: number /*uint8*/\n    delay_sec: number /*varuint32*/\n}\n\nexport interface Transaction extends TransactionHeader {\n    context_free_actions: Action[]\n    actions: Action[]\n    transaction_extensions: Extension[]\n}\n\nexport interface SigningRequest {\n    chain_id: VariantId\n    req: VariantReq\n    flags: RequestFlags\n    callback: string\n    info: InfoPair[]\n}\n\nexport interface InfoPair {\n    key: string\n    value: Uint8Array | string /*bytes*/\n}\n\nexport interface Identity {\n    permission: PermissionLevel | undefined | null\n}\n\nexport interface RequestSignature {\n    signer: AccountName\n    signature: string\n}\n\nexport const data = {\n    version: 'eosio::abi/1.1',\n    types: [\n        {\n            new_type_name: 'account_name',\n            type: 'name',\n        },\n        {\n            new_type_name: 'action_name',\n            type: 'name',\n        },\n        {\n            new_type_name: 'permission_name',\n            type: 'name',\n        },\n        {\n            new_type_name: 'chain_alias',\n            type: 'uint8',\n        },\n        {\n            new_type_name: 'chain_id',\n            type: 'checksum256',\n        },\n        {\n            new_type_name: 'request_flags',\n            type: 'uint8',\n        },\n    ],\n    structs: [\n        {\n            name: 'permission_level',\n            fields: [\n                {\n                    name: 'actor',\n                    type: 'account_name',\n                },\n                {\n                    name: 'permission',\n                    type: 'permission_name',\n                },\n            ],\n        },\n        {\n            name: 'action',\n            fields: [\n                {\n                    name: 'account',\n                    type: 'account_name',\n                },\n                {\n                    name: 'name',\n                    type: 'action_name',\n                },\n                {\n                    name: 'authorization',\n                    type: 'permission_level[]',\n                },\n                {\n                    name: 'data',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'extension',\n            fields: [\n                {\n                    name: 'type',\n                    type: 'uint16',\n                },\n                {\n                    name: 'data',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'transaction_header',\n            fields: [\n                {\n                    name: 'expiration',\n                    type: 'time_point_sec',\n                },\n                {\n                    name: 'ref_block_num',\n                    type: 'uint16',\n                },\n                {\n                    name: 'ref_block_prefix',\n                    type: 'uint32',\n                },\n                {\n                    name: 'max_net_usage_words',\n                    type: 'varuint32',\n                },\n                {\n                    name: 'max_cpu_usage_ms',\n                    type: 'uint8',\n                },\n                {\n                    name: 'delay_sec',\n                    type: 'varuint32',\n                },\n            ],\n        },\n        {\n            name: 'transaction',\n            base: 'transaction_header',\n            fields: [\n                {\n                    name: 'context_free_actions',\n                    type: 'action[]',\n                },\n                {\n                    name: 'actions',\n                    type: 'action[]',\n                },\n                {\n                    name: 'transaction_extensions',\n                    type: 'extension[]',\n                },\n            ],\n        },\n        {\n            name: 'info_pair',\n            fields: [\n                {\n                    name: 'key',\n                    type: 'string',\n                },\n                {\n                    name: 'value',\n                    type: 'bytes',\n                },\n            ],\n        },\n        {\n            name: 'signing_request',\n            fields: [\n                {\n                    name: 'chain_id',\n                    type: 'variant_id',\n                },\n                {\n                    name: 'req',\n                    type: 'variant_req',\n                },\n                {\n                    name: 'flags',\n                    type: 'request_flags',\n                },\n                {\n                    name: 'callback',\n                    type: 'string',\n                },\n                {\n                    name: 'info',\n                    type: 'info_pair[]',\n                },\n            ],\n        },\n        {\n            name: 'identity',\n            fields: [\n                {\n                    name: 'permission',\n                    type: 'permission_level?',\n                },\n            ],\n        },\n        {\n            name: 'request_signature',\n            fields: [\n                {\n                    name: 'signer',\n                    type: 'name',\n                },\n                {\n                    name: 'signature',\n                    type: 'signature',\n                },\n            ],\n        },\n    ],\n    variants: [\n        {\n            name: 'variant_id',\n            types: ['chain_alias', 'chain_id'],\n        },\n        {\n            name: 'variant_req',\n            types: ['action', 'action[]', 'transaction', 'identity'],\n        },\n    ],\n    actions: [\n        {\n            name: 'identity',\n            type: 'identity',\n        },\n    ],\n}\n","/**\n * EOSIO Signing Request (ESR).\n */\n\nimport {Serialize} from '@proton/js'\nimport sha256 from 'fast-sha256'\nrequire('fast-text-encoding');\n\nimport * as abi from './abi'\nimport * as base64u from './base64u'\n\nconst ProtocolVersion = 2\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\nconst AbiTypes = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), abi.data as any)\n\n/** Interface that should be implemented by abi providers. */\nexport interface AbiProvider {\n    /**\n     * Return a promise that resolves to an abi object for the given account name,\n     * e.g. the result of a rpc call to chain/get_abi.\n     */\n    getAbi: (account: string) => Promise<any>\n}\n\n/** Interface that should be implemented by zlib implementations. */\nexport interface ZlibProvider {\n    /** Deflate data w/o adding zlib header. */\n    deflateRaw: (data: Uint8Array) => Uint8Array\n    /** Inflate data w/o requiring zlib header. */\n    inflateRaw: (data: Uint8Array) => Uint8Array\n}\n\n/** Interface that should be implemented by signature providers. */\nexport interface SignatureProvider {\n    /** Sign 32-byte hex-encoded message and return signer name and signature string. */\n    sign: (message: string) => {signer: string; signature: string}\n}\n\n/**\n * The callback payload sent to background callbacks.\n */\nexport interface CallbackPayload {\n    /** The first signature. */\n    sig: string\n    /** Transaction ID as HEX-encoded string. */\n    tx: string\n    /** Block number hint (only present if transaction was broadcast). */\n    bn?: string\n    /** Signer authority, aka account name. */\n    sa: string\n    /** Signer permission, e.g. \"active\". */\n    sp: string\n    /** Reference block num used when resolving request. */\n    rbn: string\n    /** Reference block id used when resolving request. */\n    rid: string\n    /** The originating signing request packed as a uri string. */\n    req: string\n    /** Expiration time used when resolving request. */\n    ex: string\n    /** All signatures 0-indexed as `sig0`, `sig1`, etc. */\n    [sig0: string]: string | undefined\n}\n\n/**\n * Context used to resolve a callback.\n * Compatible with the JSON response from a `push_transaction` call.\n */\nexport interface ResolvedCallback {\n    /** The URL to hit. */\n    url: string\n    /**\n     * Whether to run the request in the background. For a https url this\n     * means POST in the background instead of a GET redirect.\n     */\n    background: boolean\n    /**\n     * The callback payload as a object that should be encoded to JSON\n     * and POSTed to background callbacks.\n     */\n    payload: CallbackPayload\n}\n\n/**\n * Context used to resolve a transaction.\n * Compatible with the JSON response from a `get_block` call.\n */\nexport interface TransactionContext {\n    /** Timestamp expiration will be derived from. */\n    timestamp?: string\n    /**\n     * How many seconds in the future to set expiration when deriving from timestamp.\n     * Defaults to 60 seconds if unset.\n     */\n    expire_seconds?: number\n    /** Block number ref_block_num will be derived from. */\n    block_num?: number\n    /** Reference block number, takes precedence over block_num if both is set. */\n    ref_block_num?: number\n    /** Reference block prefix. */\n    ref_block_prefix?: number\n    /** Expiration timestamp, takes precedence over timestamp and expire_seconds if set. */\n    expiration?: string\n}\n\n/** Chain ID aliases. */\nexport enum ChainName {\n    UNKNOWN = 0, // reserved\n    EOS = 1,\n    TELOS = 2,\n    JUNGLE = 3,\n    KYLIN = 4,\n    WORBLI = 5,\n    BOS = 6,\n    MEETONE = 7,\n    INSIGHTS = 8,\n    BEOS = 9,\n    WAX = 10,\n    PROTON = 11,\n    FIO = 12,\n}\n\nconst ChainIdLookup = new Map<abi.ChainAlias, abi.ChainId>([\n    [ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'],\n    [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'],\n    [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'],\n    [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'],\n    [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'],\n    [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'],\n    [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'],\n    [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'],\n    [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'],\n    [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'],\n    [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'],\n    [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c'],\n])\n\nconst DEFAULT_SCHEME = 'esr'\n\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\nexport const PlaceholderName = '............1' // aka uint64(1)\n\n/** Placeholder that will resolve to signer permission name. */\nexport const PlaceholderPermission = '............2' // aka uint64(2)\n\nexport const PlaceholderAuth: abi.PermissionLevel = {\n    actor: PlaceholderName,\n    permission: PlaceholderPermission,\n}\n\nexport type CallbackType = string | {url: string; background: boolean}\n\nexport interface SigningRequestCreateArguments {\n    /** Single action to create request with. */\n    action?: abi.Action\n    /** Multiple actions to create request with. */\n    actions?: abi.Action[]\n    /**\n     * Full or partial transaction to create request with.\n     * If TAPoS info is omitted it will be filled in when resolving the request.\n     */\n    transaction?: {actions: abi.Action[]; [key: string]: any}\n    /** Create an identity request. */\n    identity?: abi.Identity\n    /** Chain to use, defaults to EOS main-net if omitted. */\n    chainId?: string | number\n    /** Whether wallet should broadcast tx, defaults to true. */\n    broadcast?: boolean\n    /**\n     * Optional callback URL the signer should hit after\n     * broadcasting or signing. Passing a string means background = false.\n     */\n    callback?: CallbackType\n    /** Optional metadata to pass along with the request. */\n    info?: {[key: string]: string | Uint8Array}\n}\n\nexport interface SigningRequestCreateIdentityArguments {\n    /**\n     * Callback where the identity should be delivered.\n     */\n    callback: CallbackType\n    /** Chain to use, defaults to EOS if omitted. */\n    chainId?: string | number\n    /**\n     * Requested account name of identity.\n     * Defaults to placeholder (any identity) if omitted.\n     */\n    account?: string\n    /**\n     * Requested account permission.\n     * Defaults to placeholder (any permission) if omitted.\n     */\n    permission?: string\n    /** Optional metadata to pass along with the request. */\n    info?: {[key: string]: string | Uint8Array}\n}\n\nexport interface SigningRequestEncodingOptions {\n    /** Optional zlib, if provided the request will be compressed when encoding. */\n    zlib?: ZlibProvider\n    /** Abi provider, required if the arguments contain un-encoded actions. */\n    abiProvider?: AbiProvider\n    /** Optional signature provider, will be used to create a request signature if provided. */\n    signatureProvider?: SignatureProvider\n    /** Custom Scheme . */\n    scheme?: string\n}\n\nexport type AbiMap = Map<string, any>\n\nexport class SigningRequest {\n    public static type = AbiTypes.get('signing_request')!\n    public static idType = AbiTypes.get('identity')!\n    public static transactionType = AbiTypes.get('transaction')!\n    public scheme: string = DEFAULT_SCHEME\n\n    /** Create a new signing request. */\n    public static async create(\n        args: SigningRequestCreateArguments,\n        options: SigningRequestEncodingOptions = {}\n    ) {\n        const data: any = {}\n\n        const serialize = (action: abi.Action) => {\n            return serializeAction(action, options.abiProvider)\n        }\n\n        // set the request data\n        if (args.identity !== undefined) {\n            data.req = ['identity', args.identity]\n        } else if (args.action && !args.actions && !args.transaction) {\n            data.req = ['action', await serialize(args.action)]\n        } else if (args.actions && !args.action && !args.transaction) {\n            if (args.actions.length === 1) {\n                data.req = ['action', await serialize(args.actions[0])]\n            } else {\n                data.req = ['action[]', await Promise.all(args.actions.map(serialize))]\n            }\n        } else if (args.transaction && !args.action && !args.actions) {\n            const tx = args.transaction\n            // set default values if missing\n            if (tx.expiration === undefined) {\n                tx.expiration = '1970-01-01T00:00:00.000'\n            }\n            if (tx.ref_block_num === undefined) {\n                tx.ref_block_num = 0\n            }\n            if (tx.ref_block_prefix === undefined) {\n                tx.ref_block_prefix = 0\n            }\n            if (tx.context_free_actions === undefined) {\n                tx.context_free_actions = []\n            }\n            if (tx.transaction_extensions === undefined) {\n                tx.transaction_extensions = []\n            }\n            if (tx.delay_sec === undefined) {\n                tx.delay_sec = 0\n            }\n            if (tx.max_cpu_usage_ms === undefined) {\n                tx.max_cpu_usage_ms = 0\n            }\n            if (tx.max_net_usage_words === undefined) {\n                tx.max_net_usage_words = 0\n            }\n            // encode actions if needed\n            tx.actions = await Promise.all(tx.actions.map(serialize))\n            data.req = ['transaction', tx]\n        } else {\n            throw new TypeError(\n                'Invalid arguments: Must have exactly one of action, actions or transaction'\n            )\n        }\n\n        // set the chain id\n        data.chain_id = variantId(args.chainId)\n        data.flags = abi.RequestFlagsNone\n\n        const broadcast = args.broadcast !== undefined ? args.broadcast : true\n        if (broadcast) {\n            data.flags |= abi.RequestFlagsBroadcast\n        }\n        if (typeof args.callback === 'string') {\n            data.callback = args.callback\n        } else if (typeof args.callback === 'object') {\n            data.callback = args.callback.url\n            if (args.callback.background) {\n                data.flags |= abi.RequestFlagsBackground\n            }\n        } else {\n            data.callback = ''\n        }\n\n        data.info = []\n        if (typeof args.info === 'object') {\n            for (const key in args.info) {\n                if (args.info.hasOwnProperty(key)) {\n                    let value = args.info[key]\n                    if (typeof key !== 'string') {\n                        throw new Error('Invalid info dict, keys must be strings')\n                    }\n                    if (typeof value === 'string') {\n                        value = textEncoder.encode(value)\n                    }\n                    data.info.push({key, value})\n                }\n            }\n        }\n\n        const req = new SigningRequest(\n            ProtocolVersion,\n            data,\n            options.zlib,\n            options.abiProvider,\n            undefined,\n            options.scheme\n        )\n\n        // sign the request if given a signature provider\n        if (options.signatureProvider) {\n            req.sign(options.signatureProvider)\n        }\n\n        return req\n    }\n\n    /** Creates an identity request. */\n    public static identity(\n        args: SigningRequestCreateIdentityArguments,\n        options: SigningRequestEncodingOptions = {}\n    ) {\n        let permission: abi.PermissionLevel | null = {\n            actor: args.account || PlaceholderName,\n            permission: args.permission || PlaceholderPermission,\n        }\n        if (\n            permission.actor === PlaceholderName &&\n            permission.permission === PlaceholderPermission\n        ) {\n            permission = null\n        }\n        return this.create(\n            {\n                identity: {\n                    permission,\n                },\n                broadcast: false,\n                callback: args.callback,\n                info: args.info,\n            },\n            options\n        )\n    }\n\n    /**\n     * Create a request from a chain id and serialized transaction.\n     * @param chainId The chain id where the transaction is valid.\n     * @param serializedTransaction The serialized transaction.\n     * @param options Creation options.\n     */\n    public static fromTransaction(\n        chainId: Uint8Array | string,\n        serializedTransaction: Uint8Array | string,\n        options: SigningRequestEncodingOptions = {}\n    ) {\n        if (typeof chainId !== 'string') {\n            chainId = Serialize.arrayToHex(chainId)\n        }\n        if (typeof serializedTransaction === 'string') {\n            serializedTransaction = Serialize.hexToUint8Array(serializedTransaction)\n        }\n        let buf = new Serialize.SerialBuffer()\n        buf.push(2) // header\n        const id = variantId(chainId as any)\n        if (id[0] === 'chain_alias') {\n            buf.push(0)\n            buf.push(id[1])\n        } else {\n            buf.push(1)\n            buf.pushArray(Serialize.hexToUint8Array(id[1]))\n        }\n        buf.push(2) // transaction variant\n        buf.pushArray(serializedTransaction)\n        buf.push(abi.RequestFlagsBroadcast) // flags\n        buf.push(0) // callback\n        buf.push(0) // info\n        return SigningRequest.fromData(buf.asUint8Array(), options)\n    }\n\n    /** Creates a signing request from encoded `esr:` uri string. */\n    public static from(uri: string, options: SigningRequestEncodingOptions = {}) {\n        if (typeof uri !== 'string') {\n            throw new Error('Invalid request uri')\n        }\n        const [scheme, path] = uri.split(':')\n        if (scheme !== (options.scheme || DEFAULT_SCHEME) && scheme !== `web+${(options.scheme || DEFAULT_SCHEME)}`) {\n            throw new Error('Invalid scheme')\n        }\n        const data = base64u.decode(path.startsWith('//') ? path.slice(2) : path)\n        return SigningRequest.fromData(data, options)\n    }\n\n    public static fromData(data: Uint8Array, options: SigningRequestEncodingOptions = {}) {\n        const header = data[0]\n        const version = header & ~(1 << 7)\n        if (version !== ProtocolVersion) {\n            throw new Error('Unsupported protocol version')\n        }\n        let array = data.slice(1)\n        if ((header & (1 << 7)) !== 0) {\n            if (!options.zlib) {\n                throw new Error('Compressed URI needs zlib')\n            }\n            array = options.zlib.inflateRaw(array)\n        }\n        const buffer = new Serialize.SerialBuffer({\n            array,\n        })\n        const req = SigningRequest.type.deserialize(buffer)\n        let signature: abi.RequestSignature | undefined\n        if (buffer.haveReadData()) {\n            const type = AbiTypes.get('request_signature')!\n            signature = type.deserialize(buffer)\n        }\n        return new SigningRequest(\n            version,\n            req,\n            options.zlib,\n            options.abiProvider,\n            signature,\n            options.scheme\n        )\n    }\n\n    /** The signing request version. */\n    public version: number\n\n    /** The raw signing request data. */\n    public data: abi.SigningRequest\n\n    /** The request signature. */\n    public signature?: abi.RequestSignature\n\n    private zlib?: ZlibProvider\n    private abiProvider?: AbiProvider\n\n    /**\n     * Create a new signing request.\n     * Normally not used directly, see the `create` and `from` class methods.\n     */\n    constructor(\n        version: number,\n        data: abi.SigningRequest,\n        zlib?: ZlibProvider,\n        abiProvider?: AbiProvider,\n        signature?: abi.RequestSignature,\n        scheme?: string\n    ) {\n        if ((data.flags & abi.RequestFlagsBroadcast) !== 0 && data.req[0] === 'identity') {\n            throw new Error('Invalid request (identity request cannot be broadcast)')\n        }\n        if ((data.flags & abi.RequestFlagsBroadcast) === 0 && data.callback.length === 0) {\n            throw new Error('Invalid request (nothing to do, no broadcast or callback set)')\n        }\n        this.version = version\n        this.data = data\n        this.zlib = zlib\n        this.abiProvider = abiProvider\n        this.signature = signature\n        this.scheme = scheme || this.scheme\n    }\n\n    /**\n     * Sign the request, mutating.\n     * @param signatureProvider The signature provider that provides a signature for the signer.\n     */\n    public sign(signatureProvider: SignatureProvider) {\n        const message = this.getSignatureDigest()\n        this.signature = signatureProvider.sign(Serialize.arrayToHex(message))\n    }\n\n    /**\n     * Get the signature digest for this request.\n     */\n    public getSignatureDigest() {\n        const buffer = new Serialize.SerialBuffer()\n        // protocol version + utf8 \"request\"\n        buffer.pushArray([this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74])\n        buffer.pushArray(this.getData())\n        return sha256(buffer.asUint8Array())\n    }\n\n    /**\n     * Set the signature data for this request, mutating.\n     * @param signer Account name of signer.\n     * @param signature The signature string.\n     */\n    public setSignature(signer: string, signature: string) {\n        this.signature = {signer, signature}\n    }\n\n    /**\n     * Set the request callback, mutating.\n     * @param url Where the callback should be sent.\n     * @param background Whether the callback should be sent in the background.\n     */\n    public setCallback(url: string, background: boolean) {\n        this.data.callback = url\n        if (background) {\n            this.data.flags |= abi.RequestFlagsBackground\n        } else {\n            this.data.flags &= ~abi.RequestFlagsBackground\n        }\n    }\n\n    /**\n     * Set broadcast flag.\n     * @param broadcast Whether the transaction should be broadcast by receiver.\n     */\n    public setBroadcast(broadcast: boolean) {\n        if (broadcast) {\n            this.data.flags |= abi.RequestFlagsBroadcast\n        } else {\n            this.data.flags &= ~abi.RequestFlagsBroadcast\n        }\n    }\n\n    /**\n     * Encode this request into an `esr:` uri.\n     * @argument compress Whether to compress the request data using zlib,\n     *                    defaults to true if omitted and zlib is present;\n     *                    otherwise false.\n     * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n     *                   Defaults to true.\n     * @returns An esr uri string.\n     */\n    public encode(compress?: boolean, slashes?: boolean): string {\n        const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined\n        if (shouldCompress && this.zlib === undefined) {\n            throw new Error('Need zlib to compress')\n        }\n        let header = this.version\n        const data = this.getData()\n        const sigData = this.getSignatureData()\n        let array = new Uint8Array(data.byteLength + sigData.byteLength)\n        array.set(data, 0)\n        array.set(sigData, data.byteLength)\n        if (shouldCompress) {\n            const deflated = this.zlib!.deflateRaw(array)\n            if (array.byteLength > deflated.byteLength) {\n                header |= 1 << 7\n                array = deflated\n            }\n        }\n        const out = new Uint8Array(1 + array.byteLength)\n        out[0] = header\n        out.set(array, 1)\n        let scheme = `${this.scheme}:`\n        if (slashes !== false) {\n            scheme += '//'\n        }\n        return scheme + base64u.encode(out)\n    }\n\n    /** Get the request data without header or signature. */\n    public getData(): Uint8Array {\n        const buffer = new Serialize.SerialBuffer()\n        SigningRequest.type.serialize(buffer, this.data)\n        return buffer.asUint8Array()\n    }\n\n    /** Get signature data, returns an empty array if request is not signed. */\n    public getSignatureData(): Uint8Array {\n        if (!this.signature) {\n            return new Uint8Array(0)\n        }\n        const buffer = new Serialize.SerialBuffer()\n        const type = AbiTypes.get('request_signature')!\n        type.serialize(buffer, this.signature)\n        return buffer.asUint8Array()\n    }\n\n    /** ABI definitions required to resolve request. */\n    public getRequiredAbis() {\n        return this.getRawActions()\n            .filter((action) => !isIdentity(action))\n            .map((action) => action.account)\n            .filter((value, index, self) => self.indexOf(value) === index)\n    }\n\n    /** Whether TaPoS values are required to resolve request. */\n    public requiresTapos() {\n        let tx = this.getRawTransaction()\n        return !this.isIdentity() && !hasTapos(tx)\n    }\n\n    /** Resolve required ABI definitions. */\n    public async fetchAbis(abiProvider?: AbiProvider): Promise<AbiMap> {\n        const provider = abiProvider || this.abiProvider\n        if (!provider) {\n            throw new Error('Missing ABI provider')\n        }\n        const abis = new Map<string, any>()\n        await Promise.all(\n            this.getRequiredAbis().map(async (account) => {\n                abis.set(account, await provider.getAbi(account))\n            })\n        )\n        return abis\n    }\n\n    /**\n     * Decode raw actions actions to object representations.\n     * @param abis ABI defenitions required to decode all actions.\n     * @param signer Placeholders in actions will be resolved to signer if set.\n     */\n    public resolveActions(abis: AbiMap, signer?: abi.PermissionLevel): abi.Action[] {\n        return this.getRawActions().map((rawAction) => {\n            let contractAbi: any | undefined\n            if (isIdentity(rawAction)) {\n                contractAbi = abi.data\n            } else {\n                contractAbi = abis.get(rawAction.account)\n            }\n            if (!contractAbi) {\n                throw new Error(`Missing ABI definition for ${rawAction.account}`)\n            }\n            const contract = getContract(contractAbi)\n            if (signer) {\n                // hook into eosjs name decoder and return the signing account if we encounter the placeholder\n                // this is fine because getContract re-creates the initial types each time\n                contract.types.get('name')!.deserialize = (buffer: Serialize.SerialBuffer) => {\n                    const name = buffer.getName()\n                    if (name === PlaceholderName) {\n                        return signer.actor\n                    } else if (name === PlaceholderPermission) {\n                        return signer.permission\n                    } else {\n                        return name\n                    }\n                }\n            }\n            const action = Serialize.deserializeAction(\n                contract,\n                rawAction.account,\n                rawAction.name,\n                rawAction.authorization,\n                rawAction.data as any,\n            )\n            if (signer) {\n                action.authorization = action.authorization.map((auth: any) => {\n                    let {actor, permission} = auth\n                    if (actor === PlaceholderName) {\n                        actor = signer.actor\n                    }\n                    if (permission === PlaceholderPermission) {\n                        permission = signer.permission\n                    }\n                    // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n                    if (permission === PlaceholderName) {\n                        permission = signer.permission\n                    }\n                    return {actor, permission}\n                })\n            }\n            return action\n        })\n    }\n\n    public resolveTransaction(\n        abis: AbiMap,\n        signer: abi.PermissionLevel,\n        ctx: TransactionContext = {}\n    ): abi.Transaction {\n        let tx = this.getRawTransaction()\n        if (!this.isIdentity() && !hasTapos(tx)) {\n            if (\n                ctx.expiration !== undefined &&\n                ctx.ref_block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined\n            ) {\n                tx.expiration = ctx.expiration\n                tx.ref_block_num = ctx.ref_block_num\n                tx.ref_block_prefix = ctx.ref_block_prefix\n            } else if (\n                ctx.block_num !== undefined &&\n                ctx.ref_block_prefix !== undefined &&\n                ctx.timestamp !== undefined\n            ) {\n                const header = Serialize.transactionHeader(\n                    ctx as any,\n                    ctx.expire_seconds !== undefined ? ctx.expire_seconds : 60\n                )\n                tx.expiration = header.expiration\n                tx.ref_block_num = header.ref_block_num\n                tx.ref_block_prefix = header.ref_block_prefix\n            } else {\n                throw new Error(\n                    'Invalid transaction context, need either a reference block or explicit TAPoS values'\n                )\n            }\n        }\n        const actions = this.resolveActions(abis, signer)\n        return {...tx, actions}\n    }\n\n    public resolve(abis: AbiMap, signer: abi.PermissionLevel, ctx: TransactionContext = {}) {\n        const transaction = this.resolveTransaction(abis, signer, ctx)\n        const buf = new Serialize.SerialBuffer()\n        const actions = transaction.actions.map((action) => {\n            let contractAbi: any\n            if (isIdentity(action)) {\n                contractAbi = abi.data\n            } else {\n                contractAbi = abis.get(action.account)\n            }\n            if (!contractAbi) {\n                throw new Error(`Missing ABI definition for ${action.account}`)\n            }\n            const contract = getContract(contractAbi)\n            return Serialize.serializeAction(\n                contract,\n                action.account,\n                action.name,\n                action.authorization,\n                action.data\n            )\n        })\n        SigningRequest.transactionType.serialize(buf, {\n            ...transaction,\n            actions,\n        })\n        const serializedTransaction = buf.asUint8Array()\n        return new ResolvedSigningRequest(this, signer, transaction, serializedTransaction)\n    }\n\n    /**\n     * Get Scheme\n     * @returns scheme like 'esr'\n     */\n    public getScheme(): string {\n        return this.scheme\n    }\n\n    /**\n     * Get the id of the chain where this request is valid.\n     * @returns The 32-byte chain id as hex encoded string.\n     */\n    public getChainId(): abi.ChainId {\n        const id = this.data.chain_id\n        switch (id[0]) {\n            case 'chain_id':\n                return id[1]\n            case 'chain_alias':\n                if (ChainIdLookup.has(id[1])) {\n                    return ChainIdLookup.get(id[1])!\n                } else {\n                    throw new Error('Unknown chain id alias')\n                }\n            default:\n                throw new Error('Invalid signing request data')\n        }\n    }\n\n    /** Return the actions in this request with action data encoded. */\n    public getRawActions() {\n        const req = this.data.req\n        switch (req[0]) {\n            case 'action':\n                return [req[1]]\n            case 'action[]':\n                return req[1]\n            case 'identity':\n                let data: string = '0101000000000000000200000000000000' // placeholder permission\n                let authorization: abi.PermissionLevel[] = [PlaceholderAuth]\n                if (req[1].permission) {\n                    let buf = new Serialize.SerialBuffer()\n                    SigningRequest.idType.serialize(buf, req[1])\n                    data = Serialize.arrayToHex(buf.asUint8Array())\n                    authorization = [req[1].permission]\n                }\n                return [\n                    {\n                        account: '',\n                        name: 'identity',\n                        authorization,\n                        data,\n                    },\n                ]\n            case 'transaction':\n                return req[1].actions\n            default:\n                throw new Error('Invalid signing request data')\n        }\n    }\n\n    /** Unresolved transaction. */\n    public getRawTransaction(): abi.Transaction {\n        const req = this.data.req\n        switch (req[0]) {\n            case 'transaction':\n                return req[1]\n            case 'action':\n            case 'action[]':\n            case 'identity':\n                return {\n                    actions: this.getRawActions(),\n                    context_free_actions: [],\n                    transaction_extensions: [],\n                    expiration: '1970-01-01T00:00:00.000',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_cpu_usage_ms: 0,\n                    max_net_usage_words: 0,\n                    delay_sec: 0,\n                }\n            default:\n                throw new Error('Invalid signing request data')\n        }\n    }\n\n    /** Whether the request is an identity request. */\n    public isIdentity(): boolean {\n        return this.data.req[0] === 'identity'\n    }\n\n    /** Whether the request should be broadcast by signer. */\n    public shouldBroadcast(): boolean {\n        if (this.isIdentity()) {\n            return false\n        }\n        return (this.data.flags & abi.RequestFlagsBroadcast) !== 0\n    }\n\n    /**\n     * Present if the request is an identity request and requests a specific account.\n     * @note This returns `nil` unless a specific identity has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    public getIdentity(): string | null {\n        if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n            const {actor} = this.data.req[1].permission\n            return actor === PlaceholderName ? null : actor\n        }\n        return null\n    }\n\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n    public getIdentityPermission(): string | null {\n        if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n            const {permission} = this.data.req[1].permission\n            return permission === PlaceholderName ? null : permission\n        }\n        return null\n    }\n\n    /** Get raw info dict */\n    public getRawInfo(): {[key: string]: Uint8Array} {\n        let rv: {[key: string]: Uint8Array} = {}\n        for (const {key, value} of this.data.info) {\n            rv[key] = typeof value === 'string' ? Serialize.hexToUint8Array(value) : value\n        }\n        return rv\n    }\n\n    /** Get metadata values as strings. */\n    public getInfo(): {[key: string]: string} {\n        let rv: {[key: string]: string} = {}\n        let raw = this.getRawInfo()\n        for (const key of Object.keys(raw)) {\n            rv[key] = textDecoder.decode(raw[key] as any)\n        }\n        return rv\n    }\n\n    /** Set a metadata key. */\n    public setInfoKey(key: string, value: string | boolean) {\n        let pair = this.data.info.find((pair) => {\n            return pair.key === key\n        })\n        let encodedValue: Uint8Array\n        switch (typeof value) {\n            case 'string':\n                encodedValue = textEncoder.encode(value)\n                break\n            case 'boolean':\n                encodedValue = new Uint8Array([value ? 1 : 0])\n                break\n            default:\n                throw new TypeError('Invalid value type, expected string or boolean.')\n        }\n        if (!pair) {\n            pair = {key, value: encodedValue}\n            this.data.info.push(pair)\n        } else {\n            pair.value = encodedValue\n        }\n    }\n\n    /** Return a deep copy of this request. */\n    public clone(): SigningRequest {\n        let signature: abi.RequestSignature | undefined\n        if (this.signature) {\n            signature = JSON.parse(JSON.stringify(this.signature))\n        }\n        const data = JSON.stringify(this.data, (_, value) => {\n            if (value instanceof Uint8Array) {\n                return Array.from(value)\n            }\n            return value\n        })\n        return new SigningRequest(\n            this.version,\n            JSON.parse(data),\n            this.zlib,\n            this.abiProvider,\n            signature,\n            this.scheme\n        )\n    }\n\n    // Convenience methods.\n\n    public toString() {\n        return this.encode()\n    }\n\n    public toJSON() {\n        return this.encode()\n    }\n}\n\nexport class ResolvedSigningRequest {\n    /** Recreate a resolved request from a callback payload. */\n    static async fromPayload(\n        payload: CallbackPayload,\n        options: SigningRequestEncodingOptions = {}\n    ): Promise<ResolvedSigningRequest> {\n        const request = SigningRequest.from(payload.req, options)\n        const abis = await request.fetchAbis()\n        return request.resolve(\n            abis,\n            {actor: payload.sa, permission: payload.sp},\n            {\n                ref_block_num: Number(payload.rbn),\n                ref_block_prefix: Number(payload.rid),\n                expiration: payload.ex,\n            }\n        )\n    }\n\n    public readonly request: SigningRequest\n    public readonly signer: abi.PermissionLevel\n    public readonly transaction: abi.Transaction\n    public readonly serializedTransaction: Uint8Array\n\n    constructor(\n        request: SigningRequest,\n        signer: abi.PermissionLevel,\n        transaction: abi.Transaction,\n        serializedTransaction: Uint8Array\n    ) {\n        this.request = request\n        this.signer = signer\n        this.transaction = transaction\n        this.serializedTransaction = serializedTransaction\n    }\n\n    public getTransactionId(): string {\n        return Serialize.arrayToHex(sha256(this.serializedTransaction))\n    }\n\n    public getCallback(signatures: string[], blockNum?: number): ResolvedCallback | null {\n        const {callback, flags} = this.request.data\n        if (!callback || callback.length === 0) {\n            return null\n        }\n        if (!signatures || signatures.length === 0) {\n            throw new Error('Must have at least one signature to resolve callback')\n        }\n        const payload: CallbackPayload = {\n            sig: signatures[0],\n            tx: this.getTransactionId(),\n            rbn: String(this.transaction.ref_block_num),\n            rid: String(this.transaction.ref_block_prefix),\n            ex: this.transaction.expiration,\n            req: this.request.encode(),\n            sa: this.signer.actor,\n            sp: this.signer.permission,\n        }\n        for (const [n, sig] of signatures.slice(1).entries() as any) {\n            payload[`sig${n}`] = sig\n        }\n        if (blockNum) {\n            payload.bn = String(blockNum)\n        }\n        const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {\n            return payload[m] || ''\n        })\n        return {\n            background: (flags & abi.RequestFlagsBackground) !== 0,\n            payload,\n            url,\n        }\n    }\n}\n\n/** Internal helper that creates a contract representation from an abi for the eosjs serializer. */\nfunction getContract(contractAbi: any): Serialize.Contract {\n    const types = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), contractAbi)\n    const actions = new Map<string, Serialize.Type>()\n    for (const {name, type} of contractAbi.actions) {\n        actions.set(name, Serialize.getType(types, type))\n    }\n    return {types, actions}\n}\n\nasync function serializeAction(\n    action: abi.Action,\n    abiProvider?: AbiProvider\n) {\n    if (typeof action.data === 'string') {\n        return action\n    }\n    let contractAbi: any\n    if (isIdentity(action)) {\n        contractAbi = abi.data\n    } else if (abiProvider) {\n        contractAbi = await abiProvider.getAbi(action.account)\n    } else {\n        throw new Error('Missing abi provider')\n    }\n    const contract = getContract(contractAbi)\n    return Serialize.serializeAction(\n        contract,\n        action.account,\n        action.name,\n        action.authorization,\n        action.data\n    )\n}\n\nfunction variantId(chainId?: abi.ChainId | abi.ChainAlias): abi.VariantId {\n    if (!chainId) {\n        chainId = ChainName.EOS\n    }\n    if (typeof chainId === 'number') {\n        return ['chain_alias', chainId]\n    } else {\n        // resolve known chain id's to their aliases\n        const name = idToName(chainId)\n        if (name !== ChainName.UNKNOWN) {\n            return ['chain_alias', name]\n        }\n        return ['chain_id', chainId]\n    }\n}\n\nfunction isIdentity(action: abi.Action) {\n    return action.account === '' && action.name === 'identity'\n}\n\nfunction hasTapos(tx: abi.Transaction) {\n    return !(\n        tx.expiration === '1970-01-01T00:00:00.000' &&\n        tx.ref_block_num === 0 &&\n        tx.ref_block_prefix === 0\n    )\n}\n\n/** Resolve a chain id to a chain name alias, returns UNKNOWN (0x00) if the chain id has no alias. */\nexport function idToName(chainId: abi.ChainId): ChainName {\n    chainId = chainId.toLowerCase()\n    for (const [n, id] of ChainIdLookup as any) {\n        if (id === chainId) {\n            n\n        }\n    }\n    return ChainName.UNKNOWN\n}\n\n/** Resolve a chain name alias to a chain id. */\nexport function nameToId(chainName: ChainName): abi.ChainId {\n    return (\n        ChainIdLookup.get(chainName) ||\n        '0000000000000000000000000000000000000000000000000000000000000000'\n    )\n}\n"],"names":["runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","Function","data","version","types","new_type_name","structs","fields","base","variants","actions","charset","lookup","Uint8Array","charCodeAt","require","ChainName","textEncoder","TextEncoder","textDecoder","TextDecoder","AbiTypes","Serialize","getTypesFromAbi","createInitialTypes","abi","ChainIdLookup","Map","EOS","TELOS","JUNGLE","KYLIN","WORBLI","BOS","MEETONE","INSIGHTS","BEOS","WAX","PROTON","FIO","PlaceholderAuth","actor","permission","SigningRequest","zlib","abiProvider","signature","scheme","flags","req","callback","args","options","serialize","action","serializeAction","identity","transaction","all","map","tx","expiration","ref_block_num","ref_block_prefix","context_free_actions","transaction_extensions","delay_sec","max_cpu_usage_ms","max_net_usage_words","chain_id","variantId","chainId","broadcast","url","background","encode","signatureProvider","sign","account","fromTransaction","serializedTransaction","arrayToHex","hexToUint8Array","buf","SerialBuffer","id","pushArray","fromData","asUint8Array","from","uri","split","path","input","a","b","c","d","p","base64u","startsWith","header","array","inflateRaw","buffer","deserialize","haveReadData","get","message","getSignatureDigest","getData","sha256","setSignature","signer","setCallback","setBroadcast","compress","slashes","shouldCompress","sigData","getSignatureData","byteLength","set","deflated","deflateRaw","out","chunk","byteRemainder","mainLength","parts","join","getRequiredAbis","getRawActions","filter","isIdentity","index","indexOf","requiresTapos","getRawTransaction","hasTapos","fetchAbis","provider","abis","getAbi","resolveActions","rawAction","contractAbi","contract","getContract","getName","deserializeAction","authorization","auth","resolveTransaction","ctx","block_num","timestamp","transactionHeader","expire_seconds","transactionType","ResolvedSigningRequest","getScheme","getChainId","has","idType","shouldBroadcast","getIdentity","getIdentityPermission","getRawInfo","rv","getInfo","raw","decode","setInfoKey","encodedValue","pair","find","clone","JSON","parse","stringify","_","Array","toJSON","request","fromPayload","payload","sa","sp","Number","rbn","rid","ex","getTransactionId","getCallback","signatures","blockNum","sig","String","entries","bn","replace","_1","_2","m","getType","idToName","UNKNOWN","toLowerCase","chainName"],"mappings":"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"}