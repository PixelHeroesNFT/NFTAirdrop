import { AbiProvider, ActionSerializerType, AuthorityProvider, BinaryAbi, CachedAbi, ContextFreeGroupCallback, Query, QueryConfig, SignatureProvider, TransactConfig, Transaction, TransactResult } from './types';
import { JsonRpc } from '../rpc';
import { Abi, GetInfoResult, PushTransactionArgs, ReadOnlyTransactResult } from '../rpc/types';
import * as ser from './serialize';
import { ApiInterfaces } from '..';
import type { recoverPersonalSignature as RecoverPersonalSignature } from 'eth-sig-util';
export declare class Api {
    /** Issues RPC calls */
    rpc: JsonRpc;
    /** Get subset of `availableKeys` needed to meet authorities in a `transaction` */
    authorityProvider: AuthorityProvider;
    /** Supplies ABIs in raw form (binary) */
    abiProvider: AbiProvider;
    /** Signs transactions */
    signatureProvider?: SignatureProvider;
    /** Converts abi files between binary and structured form (`abi.abi.json`) */
    abiTypes: Map<string, ser.Type>;
    /** Converts transactions between binary and structured form (`transaction.abi.json`) */
    transactionTypes: Map<string, ser.Type>;
    /** Holds information needed to serialize contract actions */
    contracts: Map<string, ser.Contract>;
    /** Fetched abis */
    cachedAbis: Map<string, CachedAbi>;
    /** Crypto */
    crypto?: Crypto;
    recoverPersonalSignature?: typeof RecoverPersonalSignature;
    /**
     * @param args
     *    * `rpc`: Issues RPC calls
     *    * `authorityProvider`: Get public keys needed to meet authorities in a transaction
     *    * `abiProvider`: Supplies ABIs in raw form (binary)
     *    * `signatureProvider`: Signs transactions
     */
    constructor(args: {
        rpc: JsonRpc;
        authorityProvider?: AuthorityProvider;
        abiProvider?: AbiProvider;
        signatureProvider?: SignatureProvider;
        crypto?: Crypto;
        recoverPersonalSignature?: typeof RecoverPersonalSignature;
    });
    getCrypto(): Crypto;
    getRecoverPersonalSignature(): typeof RecoverPersonalSignature;
    /** Decodes an abi as Uint8Array into json. */
    rawAbiToJson(rawAbi: Uint8Array): Abi;
    /** Encodes a json abi as Uint8Array. */
    jsonToRawAbi(jsonAbi: Abi): Uint8Array;
    /** Get abi in both binary and structured forms. Fetch when needed. */
    getCachedAbi(accountName: string, reload?: boolean): Promise<CachedAbi>;
    /** Get abi in structured form. Fetch when needed. */
    getAbi(accountName: string, reload?: boolean): Promise<Abi>;
    /** Get abis needed by a transaction */
    getTransactionAbis(transaction: any, reload?: boolean): Promise<BinaryAbi[]>;
    /** Get data needed to serialize actions in a contract */
    getContract(accountName: string, reload?: boolean): Promise<ser.Contract>;
    /** Convert `value` to binary form. `type` must be a built-in abi type or in `transaction.abi.json`. */
    serialize(buffer: ser.SerialBuffer, type: string, value: any): void;
    /** Convert data in `buffer` to structured form. `type` must be a built-in abi type or in `transaction.abi.json`. */
    deserialize(buffer: ser.SerialBuffer, type: string): any;
    /** Convert a transaction to binary */
    serializeTransaction(transaction: Transaction): Uint8Array;
    /** Serialize context-free data */
    serializeContextFreeData(contextFreeData?: Uint8Array[]): Uint8Array | undefined;
    /** Convert a transaction from binary. Leaves actions in hex. */
    deserializeTransaction(transaction: Uint8Array): Transaction;
    private transactionExtensions;
    serializeTransactionExtensions(transaction: Transaction): [number, string][];
    deserializeTransactionExtensions(data: [number, string][]): any[];
    deleteTransactionExtensionObjects(transaction: Transaction): Transaction;
    /** Convert actions to hex */
    serializeActions(actions: ser.Action[]): Promise<ser.SerializedAction[]>;
    /** Convert actions from hex */
    deserializeActions(actions: ser.Action[]): Promise<ser.Action[]>;
    deserializeActionsSync(actions?: ser.Action[]): Promise<ser.Action[]>;
    /** Convert a transaction from binary. Also deserializes actions. */
    deserializeTransactionWithActions(transaction: Uint8Array | string): Promise<any>;
    /** Deflate a serialized object */
    deflateSerializedArray(serializedArray: Uint8Array): Uint8Array;
    /** Inflate a compressed serialized object */
    inflateSerializedArray(compressedSerializedArray: Uint8Array): Uint8Array;
    /**
     * Create and optionally broadcast a transaction.
     *
     * Named Parameters:
     * `broadcast`: broadcast this transaction?
     * `sign`: sign this transaction?
     * `compression`: compress this transaction?
     * `readOnlyTrx`: read only transaction?
     * `returnFailureTraces`: return failure traces? (only available for read only transactions currently)
     *
     * If both `blocksBehind` and `expireSeconds` are present,
     * then fetch the block which is `blocksBehind` behind head block,
     * use it as a reference for TAPoS, and expire the transaction `expireSeconds` after that block's time.
     *
     * If both `useLastIrreversible` and `expireSeconds` are present,
     * then fetch the last irreversible block, use it as a reference for TAPoS,
     * and expire the transaction `expireSeconds` after that block's time.
     *
     * @returns node response if `broadcast`, `{signatures, serializedTransaction}` if `!broadcast`
     */
    transact(transaction: Transaction, { broadcast, sign, readOnlyTrx, returnFailureTraces, requiredKeys, // When you will sign later
    compression, blocksBehind, useLastIrreversible, expireSeconds, transactionHeader }?: TransactConfig): Promise<TransactResult | ReadOnlyTransactResult | PushTransactionArgs>;
    transactWithDelay(transaction: any, params: TransactConfig | undefined, delay: number): Promise<any>;
    query(account: string, short: boolean, query: Query, { sign, requiredKeys, authorization }: QueryConfig): Promise<any>;
    /** Broadcast a signed transaction */
    pushSignedTransaction({ signatures, serializedTransaction, serializedContextFreeData }: PushTransactionArgs, readOnlyTrx?: boolean, returnFailureTraces?: boolean): Promise<TransactResult | ReadOnlyTransactResult>;
    pushCompressedSignedTransaction({ signatures, serializedTransaction, serializedContextFreeData }: PushTransactionArgs, readOnlyTrx?: boolean, returnFailureTraces?: boolean): Promise<TransactResult | ReadOnlyTransactResult>;
    generateTapos(info: GetInfoResult | undefined, transaction: Transaction, blocksBehind: number | undefined, useLastIrreversible: boolean | undefined, expireSeconds: number): Promise<{
        expiration: string;
        ref_block_num: number;
        ref_block_prefix: number;
        max_net_usage_words?: number | undefined;
        max_cpu_usage_ms?: number | undefined;
        delay_sec?: number | undefined;
        context_free_actions?: ser.Action[] | undefined;
        context_free_data?: Uint8Array[] | undefined;
        actions: ser.Action[];
        transaction_extensions?: [number, string][] | undefined;
        resource_payer?: ApiInterfaces.ResourcePayer | undefined;
    }>;
    private hasRequiredTaposFields;
    private tryGetBlockHeaderState;
    private tryGetBlockInfo;
    private tryRefBlockFromGetInfo;
    with(accountName: string): ActionBuilder;
    buildTransaction(cb?: (tx: TransactionBuilder) => void): TransactionBuilder | void;
    getAccountKeys(actor: string, permission: string): Promise<string[]>;
    sha256Digest(array: Uint8Array | ArrayBuffer): Promise<Uint8Array>;
    matchRsaKeyToSignature({ actor, transaction }: {
        actor: string;
        transaction: Transaction;
    }): Promise<boolean>;
    matchEthKeyToSignature({ actor, transaction }: {
        actor: string;
        transaction: Transaction;
    }): Promise<boolean>;
    matchWaKeyToSignature({ signature, key, digest }: {
        signature: string;
        key: string;
        digest: string;
    }): Promise<boolean>;
    checkIfKeysMatchTransaction({ actor, permission, transaction, signatures, chainId }: {
        actor: string;
        permission: string;
        transaction: any;
        signatures: string[];
        chainId?: string;
    }): Promise<boolean>;
}
export declare class TransactionBuilder {
    private api;
    private actions;
    private contextFreeGroups;
    constructor(api: Api);
    with(accountName: string): ActionBuilder;
    associateContextFree(contextFreeGroup: ContextFreeGroupCallback): TransactionBuilder;
    send(config?: TransactConfig): Promise<PushTransactionArgs | ReadOnlyTransactResult | TransactResult>;
}
export declare class ActionBuilder {
    private api;
    private readonly accountName;
    serializedData: ser.SerializedAction | undefined;
    constructor(api: Api, accountName: string);
    as(actorName?: string | ser.Authorization[]): ActionSerializerType;
}
