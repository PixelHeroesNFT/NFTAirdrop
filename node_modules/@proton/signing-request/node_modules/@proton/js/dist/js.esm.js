import { deflate, inflate } from 'pako';
import { sha256 as sha256$1 } from 'hash.js';
import RIPEMD160 from 'ripemd-ts';
import { decode, encode } from 'bs58';
import 'fast-text-encoding';
import { ec } from 'elliptic';
import { constants } from '@bloks/constants';
import { array, object, string, number } from 'zod';
import fetch from 'cross-fetch';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var ripemd160 = RIPEMD160.hash;
var base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
var base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

var create_base58_map = function create_base58_map() {
  var base58M = Array(256).fill(-1);

  for (var i = 0; i < base58Chars.length; ++i) {
    base58M[base58Chars.charCodeAt(i)] = i;
  }

  return base58M;
};

var base58Map = /*#__PURE__*/create_base58_map();

var create_base64_map = function create_base64_map() {
  var base64M = Array(256).fill(-1);

  for (var i = 0; i < base64Chars.length; ++i) {
    base64M[base64Chars.charCodeAt(i)] = i;
  }

  base64M['='.charCodeAt(0)] = 0;
  return base64M;
};

var base64Map = /*#__PURE__*/create_base64_map();
/** Is `bignum` a negative number? */

var isNegative = function isNegative(bignum) {
  return (bignum[bignum.length - 1] & 0x80) !== 0;
};
/** Negate `bignum` */

var negate = function negate(bignum) {
  var carry = 1;

  for (var i = 0; i < bignum.length; ++i) {
    var x = (~bignum[i] & 0xff) + carry;
    bignum[i] = x;
    carry = x >> 8;
  }
};
/**
 * Convert an unsigned decimal number in `s` to a bignum
 *
 * @param size bignum size (bytes)
 */

var decimalToBinary = function decimalToBinary(size, s) {
  var result = new Uint8Array(size);

  for (var i = 0; i < s.length; ++i) {
    var srcDigit = s.charCodeAt(i);

    if (srcDigit < '0'.charCodeAt(0) || srcDigit > '9'.charCodeAt(0)) {
      throw new Error('invalid number');
    }

    var carry = srcDigit - '0'.charCodeAt(0);

    for (var j = 0; j < size; ++j) {
      var x = result[j] * 10 + carry;
      result[j] = x;
      carry = x >> 8;
    }

    if (carry) {
      throw new Error('number is out of range');
    }
  }

  return result;
};
/**
 * Convert a signed decimal number in `s` to a bignum
 *
 * @param size bignum size (bytes)
 */

var signedDecimalToBinary = function signedDecimalToBinary(size, s) {
  var negative = s[0] === '-';

  if (negative) {
    s = s.substr(1);
  }

  var result = decimalToBinary(size, s);

  if (negative) {
    negate(result);

    if (!isNegative(result)) {
      throw new Error('number is out of range');
    }
  } else if (isNegative(result)) {
    throw new Error('number is out of range');
  }

  return result;
};
/**
 * Convert `bignum` to an unsigned decimal number
 *
 * @param minDigits 0-pad result to this many digits
 */

var binaryToDecimal = function binaryToDecimal(bignum, minDigits) {
  if (minDigits === void 0) {
    minDigits = 1;
  }

  var result = Array(minDigits).fill('0'.charCodeAt(0));

  for (var i = bignum.length - 1; i >= 0; --i) {
    var carry = bignum[i];

    for (var j = 0; j < result.length; ++j) {
      var x = (result[j] - '0'.charCodeAt(0) << 8) + carry;
      result[j] = '0'.charCodeAt(0) + x % 10;
      carry = x / 10 | 0;
    }

    while (carry) {
      result.push('0'.charCodeAt(0) + carry % 10);
      carry = carry / 10 | 0;
    }
  }

  result.reverse();
  return String.fromCharCode.apply(String, result);
};
/**
 * Convert `bignum` to a signed decimal number
 *
 * @param minDigits 0-pad result to this many digits
 */

var signedBinaryToDecimal = function signedBinaryToDecimal(bignum, minDigits) {
  if (minDigits === void 0) {
    minDigits = 1;
  }

  if (isNegative(bignum)) {
    var x = bignum.slice();
    negate(x);
    return '-' + binaryToDecimal(x, minDigits);
  }

  return binaryToDecimal(bignum, minDigits);
};

var base58ToBinaryVarSize = function base58ToBinaryVarSize(s) {
  var result = [];

  for (var i = 0; i < s.length; ++i) {
    var carry = base58Map[s.charCodeAt(i)];

    if (carry < 0) {
      throw new Error('invalid base-58 value');
    }

    for (var j = 0; j < result.length; ++j) {
      var x = result[j] * 58 + carry;
      result[j] = x & 0xff;
      carry = x >> 8;
    }

    if (carry) {
      result.push(carry);
    }
  }

  for (var _iterator = _createForOfIteratorHelperLoose(s), _step; !(_step = _iterator()).done;) {
    var ch = _step.value;

    if (ch === '1') {
      result.push(0);
    } else {
      break;
    }
  }

  result.reverse();
  return new Uint8Array(result);
};
/**
 * Convert an unsigned base-58 number in `s` to a bignum
 *
 * @param size bignum size (bytes)
 */


var base58ToBinary = function base58ToBinary(size, s) {
  if (!size) {
    return base58ToBinaryVarSize(s);
  }

  var result = new Uint8Array(size);

  for (var i = 0; i < s.length; ++i) {
    var carry = base58Map[s.charCodeAt(i)];

    if (carry < 0) {
      throw new Error('invalid base-58 value');
    }

    for (var j = 0; j < size; ++j) {
      var x = result[j] * 58 + carry;
      result[j] = x;
      carry = x >> 8;
    }

    if (carry) {
      throw new Error('base-58 value is out of range');
    }
  }

  result.reverse();
  return result;
};
/**
 * Convert `bignum` to a base-58 number
 *
 * @param minDigits 0-pad result to this many digits
 */

var binaryToBase58 = function binaryToBase58(bignum) {
  var result = [];

  for (var _iterator2 = _createForOfIteratorHelperLoose(bignum), _step2; !(_step2 = _iterator2()).done;) {
    var _byte = _step2.value;
    var carry = _byte;

    for (var j = 0; j < result.length; ++j) {
      var x = (base58Map[result[j]] << 8) + carry;
      result[j] = base58Chars.charCodeAt(x % 58);
      carry = x / 58 | 0;
    }

    while (carry) {
      result.push(base58Chars.charCodeAt(carry % 58));
      carry = carry / 58 | 0;
    }
  }

  for (var _iterator3 = _createForOfIteratorHelperLoose(bignum), _step3; !(_step3 = _iterator3()).done;) {
    var _byte2 = _step3.value;

    if (_byte2) {
      break;
    } else {
      result.push('1'.charCodeAt(0));
    }
  }

  result.reverse();
  return String.fromCharCode.apply(String, result);
};
/** Convert an unsigned base-64 number in `s` to a bignum */

var base64ToBinary = function base64ToBinary(s) {
  var len = s.length;

  if ((len & 3) === 1 && s[len - 1] === '=') {
    len -= 1;
  } // fc appends an extra '='


  if ((len & 3) !== 0) {
    throw new Error('base-64 value is not padded correctly');
  }

  var groups = len >> 2;
  var bytes = groups * 3;

  if (len > 0 && s[len - 1] === '=') {
    if (s[len - 2] === '=') {
      bytes -= 2;
    } else {
      bytes -= 1;
    }
  }

  var result = new Uint8Array(bytes);

  for (var group = 0; group < groups; ++group) {
    var digit0 = base64Map[s.charCodeAt(group * 4 + 0)];
    var digit1 = base64Map[s.charCodeAt(group * 4 + 1)];
    var digit2 = base64Map[s.charCodeAt(group * 4 + 2)];
    var digit3 = base64Map[s.charCodeAt(group * 4 + 3)];
    result[group * 3 + 0] = digit0 << 2 | digit1 >> 4;

    if (group * 3 + 1 < bytes) {
      result[group * 3 + 1] = (digit1 & 15) << 4 | digit2 >> 2;
    }

    if (group * 3 + 2 < bytes) {
      result[group * 3 + 2] = (digit2 & 3) << 6 | digit3;
    }
  }

  return result;
};
/** Key types this library supports */

var KeyType;

(function (KeyType) {
  KeyType[KeyType["k1"] = 0] = "k1";
  KeyType[KeyType["r1"] = 1] = "r1";
  KeyType[KeyType["wa"] = 2] = "wa";
})(KeyType || (KeyType = {}));
/** Public key data size, excluding type field */


var publicKeyDataSize = 33;
/** Private key data size, excluding type field */

var privateKeyDataSize = 32;
/** Signature data size, excluding type field */

var signatureDataSize = 65;

var digestSuffixRipemd160 = function digestSuffixRipemd160(data, suffix) {
  var d = new Uint8Array(data.length + suffix.length);

  for (var i = 0; i < data.length; ++i) {
    d[i] = data[i];
  }

  for (var _i = 0; _i < suffix.length; ++_i) {
    d[data.length + _i] = suffix.charCodeAt(_i);
  }

  return ripemd160(d);
};

var stringToKey = function stringToKey(s, type, size, suffix) {
  var whole = base58ToBinary(size ? size + 4 : 0, s);
  var result = {
    type: type,
    data: new Uint8Array(whole.buffer, 0, whole.length - 4)
  };
  var digest = new Uint8Array(digestSuffixRipemd160(result.data, suffix));

  if (digest[0] !== whole[whole.length - 4] || digest[1] !== whole[whole.length - 3] || digest[2] !== whole[whole.length - 2] || digest[3] !== whole[whole.length - 1]) {
    throw new Error('checksum doesn\'t match');
  }

  return result;
};

var keyToString = function keyToString(key, suffix, prefix) {
  var digest = new Uint8Array(digestSuffixRipemd160(key.data, suffix));
  var whole = new Uint8Array(key.data.length + 4);

  for (var i = 0; i < key.data.length; ++i) {
    whole[i] = key.data[i];
  }

  for (var _i2 = 0; _i2 < 4; ++_i2) {
    whole[_i2 + key.data.length] = digest[_i2];
  }

  return prefix + binaryToBase58(whole);
};
/** Convert key in `s` to binary form */


var stringToPublicKey = function stringToPublicKey(s, prefix) {
  if (prefix === void 0) {
    prefix = 'EOS';
  }

  if (typeof s !== 'string') {
    throw new Error('expected string containing public key');
  }

  if (s.substr(0, 3) === prefix) {
    var whole = base58ToBinary(publicKeyDataSize + 4, s.substr(3));
    var key = {
      type: KeyType.k1,
      data: new Uint8Array(publicKeyDataSize)
    };

    for (var i = 0; i < publicKeyDataSize; ++i) {
      key.data[i] = whole[i];
    }

    var digest = new Uint8Array(ripemd160(key.data));

    if (digest[0] !== whole[publicKeyDataSize] || digest[1] !== whole[34] || digest[2] !== whole[35] || digest[3] !== whole[36]) {
      throw new Error('checksum doesn\'t match');
    }

    return key;
  } else if (s.substr(0, 7) === 'PUB_K1_') {
    return stringToKey(s.substr(7), KeyType.k1, publicKeyDataSize, 'K1');
  } else if (s.substr(0, 7) === 'PUB_R1_') {
    return stringToKey(s.substr(7), KeyType.r1, publicKeyDataSize, 'R1');
  } else if (s.substr(0, 7) === 'PUB_WA_') {
    return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');
  } else {
    throw new Error('unrecognized public key format');
  }
};
/** Convert public `key` to legacy string (base-58) form */

var publicKeyToLegacyString = function publicKeyToLegacyString(key, prefix) {
  if (prefix === void 0) {
    prefix = 'EOS';
  }

  if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {
    return keyToString(key, '', prefix);
  } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {
    throw new Error('Key format not supported in legacy conversion');
  } else {
    throw new Error('unrecognized public key format');
  }
};
/** Convert `key` to string (base-58) form */

var publicKeyToString = function publicKeyToString(key) {
  if (key.type === KeyType.k1 && key.data.length === publicKeyDataSize) {
    return keyToString(key, 'K1', 'PUB_K1_');
  } else if (key.type === KeyType.r1 && key.data.length === publicKeyDataSize) {
    return keyToString(key, 'R1', 'PUB_R1_');
  } else if (key.type === KeyType.wa) {
    return keyToString(key, 'WA', 'PUB_WA_');
  } else {
    throw new Error('unrecognized public key format');
  }
};
/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).
 * Leaves other formats untouched
 */

var convertLegacyPublicKey = function convertLegacyPublicKey(s, prefix) {
  if (prefix === void 0) {
    prefix = 'EOS';
  }

  if (s.substr(0, 3) === prefix) {
    return publicKeyToString(stringToPublicKey(s, prefix));
  }

  return s;
};
var convertK1ToLegacyPublicKey = function convertK1ToLegacyPublicKey(publicKey, prefix) {
  if (prefix === void 0) {
    prefix = 'EOS';
  }

  var K1_PREFIX = 'PUB_K1_';

  if (publicKey.substr(0, K1_PREFIX.length) !== K1_PREFIX) {
    return publicKey;
  }

  var nonPrefixPublicKey = publicKey.substr(K1_PREFIX.length);
  var bytesWithChecksum = decode(nonPrefixPublicKey);
  var bytes = bytesWithChecksum.slice(0, bytesWithChecksum.length - 4);
  var suffixBytes = Buffer.from(ripemd160(bytes)).slice(0, 4);
  var binaryPublicKey = Buffer.from([].concat(bytes, suffixBytes));
  return "" + prefix + encode(binaryPublicKey);
};
/** If a key is in the legacy format (`EOS` prefix), then convert it to the new format (`PUB_K1_`).
 * Leaves other formats untouched
 */

var convertLegacyPublicKeys = function convertLegacyPublicKeys(keys, prefix) {
  if (prefix === void 0) {
    prefix = 'EOS';
  }

  return keys.map(function (key) {
    return convertLegacyPublicKey(key, prefix);
  });
};
/** Convert key in `s` to binary form */

var stringToPrivateKey = function stringToPrivateKey(s) {
  if (typeof s !== 'string') {
    throw new Error('expected string containing private key');
  }

  if (s.substr(0, 7) === 'PVT_R1_') {
    return stringToKey(s.substr(7), KeyType.r1, privateKeyDataSize, 'R1');
  } else if (s.substr(0, 7) === 'PVT_K1_') {
    return stringToKey(s.substr(7), KeyType.k1, privateKeyDataSize, 'K1');
  } else {
    // todo: Verify checksum: sha256(sha256(key.data)).
    //       Not critical since a bad key will fail to produce a
    //       valid signature anyway.
    var whole = base58ToBinary(privateKeyDataSize + 5, s);
    var key = {
      type: KeyType.k1,
      data: new Uint8Array(privateKeyDataSize)
    };

    if (whole[0] !== 0x80) {
      throw new Error('unrecognized private key type');
    }

    for (var i = 0; i < privateKeyDataSize; ++i) {
      key.data[i] = whole[i + 1];
    }

    return key;
  }
};
/** Convert private `key` to legacy string (base-58) form */

var privateKeyToLegacyString = function privateKeyToLegacyString(key) {
  if (key.type === KeyType.k1 && key.data.length === privateKeyDataSize) {
    var whole = [];
    whole.push(128);
    key.data.forEach(function (_byte3) {
      return whole.push(_byte3);
    });
    var digest = new Uint8Array(sha256$1().update(sha256$1().update(whole).digest()).digest());
    var result = new Uint8Array(privateKeyDataSize + 5);

    for (var i = 0; i < whole.length; i++) {
      result[i] = whole[i];
    }

    for (var _i3 = 0; _i3 < 4; _i3++) {
      result[_i3 + whole.length] = digest[_i3];
    }

    return binaryToBase58(result);
  } else if (key.type === KeyType.r1 || key.type === KeyType.wa) {
    throw new Error('Key format not supported in legacy conversion');
  } else {
    throw new Error('unrecognized public key format');
  }
};
/** Convert `key` to string (base-58) form */

var privateKeyToString = function privateKeyToString(key) {
  if (key.type === KeyType.r1) {
    return keyToString(key, 'R1', 'PVT_R1_');
  } else if (key.type === KeyType.k1) {
    return keyToString(key, 'K1', 'PVT_K1_');
  } else {
    throw new Error('unrecognized private key format');
  }
};
/** Convert key in `s` to binary form */

var stringToSignature = function stringToSignature(s) {
  if (typeof s !== 'string') {
    throw new Error('expected string containing signature');
  }

  if (s.substr(0, 7) === 'SIG_K1_') {
    return stringToKey(s.substr(7), KeyType.k1, signatureDataSize, 'K1');
  } else if (s.substr(0, 7) === 'SIG_R1_') {
    return stringToKey(s.substr(7), KeyType.r1, signatureDataSize, 'R1');
  } else if (s.substr(0, 7) === 'SIG_WA_') {
    return stringToKey(s.substr(7), KeyType.wa, 0, 'WA');
  } else {
    throw new Error('unrecognized signature format');
  }
};
/** Convert `signature` to string (base-58) form */

var signatureToString = function signatureToString(signature) {
  if (signature.type === KeyType.k1) {
    return keyToString(signature, 'K1', 'SIG_K1_');
  } else if (signature.type === KeyType.r1) {
    return keyToString(signature, 'R1', 'SIG_R1_');
  } else if (signature.type === KeyType.wa) {
    return keyToString(signature, 'WA', 'SIG_WA_');
  } else {
    throw new Error('unrecognized signature format');
  }
};

var Numeric = {
  __proto__: null,
  isNegative: isNegative,
  negate: negate,
  decimalToBinary: decimalToBinary,
  signedDecimalToBinary: signedDecimalToBinary,
  binaryToDecimal: binaryToDecimal,
  signedBinaryToDecimal: signedBinaryToDecimal,
  base58ToBinary: base58ToBinary,
  binaryToBase58: binaryToBase58,
  base64ToBinary: base64ToBinary,
  get KeyType () { return KeyType; },
  publicKeyDataSize: publicKeyDataSize,
  privateKeyDataSize: privateKeyDataSize,
  signatureDataSize: signatureDataSize,
  stringToPublicKey: stringToPublicKey,
  publicKeyToLegacyString: publicKeyToLegacyString,
  publicKeyToString: publicKeyToString,
  convertLegacyPublicKey: convertLegacyPublicKey,
  convertK1ToLegacyPublicKey: convertK1ToLegacyPublicKey,
  convertLegacyPublicKeys: convertLegacyPublicKeys,
  stringToPrivateKey: stringToPrivateKey,
  privateKeyToLegacyString: privateKeyToLegacyString,
  privateKeyToString: privateKeyToString,
  stringToSignature: stringToSignature,
  signatureToString: signatureToString
};

/** State for serialize() and deserialize() */

var SerializerState = function SerializerState(options) {
  if (options === void 0) {
    options = {};
  }

  /** Have any binary extensions been skipped? */
  this.skippedBinaryExtension = false;
  this.options = options;
};
/** Serialize and deserialize data */

var SerialBuffer = /*#__PURE__*/function () {
  /**
   * @param __namedParameters
   * `array`: `null` if serializing, or binary data to deserialize
   * `textEncoder`: `TextEncoder` instance to use. Pass in `null` if running in a browser
   * `textDecoder`: `TextDecider` instance to use. Pass in `null` if running in a browser
   */
  function SerialBuffer(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        array = _ref.array,
        textEncoder = _ref.textEncoder,
        textDecoder = _ref.textDecoder;

    /** Current position while reading (deserializing) */
    this.readPos = 0;
    this.array = array || new Uint8Array(1024);
    this.length = array ? array.length : 0;
    this.textEncoder = textEncoder || new TextEncoder();
    this.textDecoder = textDecoder || new TextDecoder('utf-8');
  }
  /** Resize `array` if needed to have at least `size` bytes free */


  var _proto = SerialBuffer.prototype;

  _proto.reserve = function reserve(size) {
    if (this.length + size <= this.array.length) {
      return;
    }

    var l = this.array.length;

    while (this.length + size > l) {
      l = Math.ceil(l * 1.5);
    }

    var newArray = new Uint8Array(l);
    newArray.set(this.array);
    this.array = newArray;
  }
  /** Is there data available to read? */
  ;

  _proto.haveReadData = function haveReadData() {
    return this.readPos < this.length;
  }
  /** Restart reading from the beginning */
  ;

  _proto.restartRead = function restartRead() {
    this.readPos = 0;
  }
  /** Return data with excess storage trimmed away */
  ;

  _proto.asUint8Array = function asUint8Array() {
    return new Uint8Array(this.array.buffer, this.array.byteOffset, this.length);
  }
  /** Append bytes */
  ;

  _proto.pushArray = function pushArray(v) {
    this.reserve(v.length);
    this.array.set(v, this.length);
    this.length += v.length;
  }
  /** Append bytes */
  ;

  _proto.push = function push() {
    for (var _len = arguments.length, v = new Array(_len), _key = 0; _key < _len; _key++) {
      v[_key] = arguments[_key];
    }

    this.pushArray(v);
  }
  /** Get a single byte */
  ;

  _proto.get = function get() {
    if (this.readPos < this.length) {
      return this.array[this.readPos++];
    }

    throw new Error('Read past end of buffer');
  }
  /** Append bytes in `v`. Throws if `len` doesn't match `v.length` */
  ;

  _proto.pushUint8ArrayChecked = function pushUint8ArrayChecked(v, len) {
    if (v.length !== len) {
      throw new Error('Binary data has incorrect size');
    }

    this.pushArray(v);
  }
  /** Get `len` bytes */
  ;

  _proto.getUint8Array = function getUint8Array(len) {
    if (this.readPos + len > this.length) {
      throw new Error('Read past end of buffer');
    }

    var result = new Uint8Array(this.array.buffer, this.array.byteOffset + this.readPos, len);
    this.readPos += len;
    return result;
  }
  /** Skip `len` bytes */
  ;

  _proto.skip = function skip(len) {
    if (this.readPos + len > this.length) {
      throw new Error('Read past end of buffer');
    }

    this.readPos += len;
  }
  /** Append a `uint16` */
  ;

  _proto.pushUint16 = function pushUint16(v) {
    this.push(v >> 0 & 0xff, v >> 8 & 0xff);
  }
  /** Get a `uint16` */
  ;

  _proto.getUint16 = function getUint16() {
    var v = 0;
    v |= this.get() << 0;
    v |= this.get() << 8;
    return v;
  }
  /** Append a `uint32` */
  ;

  _proto.pushUint32 = function pushUint32(v) {
    this.push(v >> 0 & 0xff, v >> 8 & 0xff, v >> 16 & 0xff, v >> 24 & 0xff);
  }
  /** Get a `uint32` */
  ;

  _proto.getUint32 = function getUint32() {
    var v = 0;
    v |= this.get() << 0;
    v |= this.get() << 8;
    v |= this.get() << 16;
    v |= this.get() << 24;
    return v >>> 0;
  }
  /** Append a `uint64`. *Caution*: `number` only has 53 bits of precision */
  ;

  _proto.pushNumberAsUint64 = function pushNumberAsUint64(v) {
    this.pushUint32(v >>> 0);
    this.pushUint32(Math.floor(v / 4294967296) >>> 0);
  }
  /**
   * Get a `uint64` as a `number`. *Caution*: `number` only has 53 bits of precision; some values will change.
   * `numeric.binaryToDecimal(serialBuffer.getUint8Array(8))` recommended instead
   */
  ;

  _proto.getUint64AsNumber = function getUint64AsNumber() {
    var low = this.getUint32();
    var high = this.getUint32();
    return (high >>> 0) * 4294967296 + (low >>> 0);
  }
  /** Append a `varuint32` */
  ;

  _proto.pushVaruint32 = function pushVaruint32(v) {
    while (true) {
      if (v >>> 7) {
        this.push(0x80 | v & 0x7f);
        v = v >>> 7;
      } else {
        this.push(v);
        break;
      }
    }
  }
  /** Get a `varuint32` */
  ;

  _proto.getVaruint32 = function getVaruint32() {
    var v = 0;
    var bit = 0;

    while (true) {
      var b = this.get();
      v |= (b & 0x7f) << bit;
      bit += 7;

      if (!(b & 0x80)) {
        break;
      }
    }

    return v >>> 0;
  }
  /** Append a `varint32` */
  ;

  _proto.pushVarint32 = function pushVarint32(v) {
    this.pushVaruint32(v << 1 ^ v >> 31);
  }
  /** Get a `varint32` */
  ;

  _proto.getVarint32 = function getVarint32() {
    var v = this.getVaruint32();

    if (v & 1) {
      return ~v >> 1 | 2147483648;
    } else {
      return v >>> 1;
    }
  }
  /** Append a `float32` */
  ;

  _proto.pushFloat32 = function pushFloat32(v) {
    this.pushArray(new Uint8Array(new Float32Array([v]).buffer));
  }
  /** Get a `float32` */
  ;

  _proto.getFloat32 = function getFloat32() {
    return new Float32Array(this.getUint8Array(4).slice().buffer)[0];
  }
  /** Append a `float64` */
  ;

  _proto.pushFloat64 = function pushFloat64(v) {
    this.pushArray(new Uint8Array(new Float64Array([v]).buffer));
  }
  /** Get a `float64` */
  ;

  _proto.getFloat64 = function getFloat64() {
    return new Float64Array(this.getUint8Array(8).slice().buffer)[0];
  }
  /** Append a `name` */
  ;

  _proto.pushName = function pushName(s) {
    if (typeof s !== 'string') {
      throw new Error('Expected string containing name');
    }

    var regex = new RegExp(/^[.1-5a-z]{0,12}[.1-5a-j]?$/);

    if (!regex.test(s)) {
      throw new Error('Name should be less than 13 characters, or less than 14 if last character is between 1-5 or a-j, and only contain the following symbols .12345abcdefghijklmnopqrstuvwxyz'); // eslint-disable-line
    }

    var charToSymbol = function charToSymbol(c) {
      if (c >= 'a'.charCodeAt(0) && c <= 'z'.charCodeAt(0)) {
        return c - 'a'.charCodeAt(0) + 6;
      }

      if (c >= '1'.charCodeAt(0) && c <= '5'.charCodeAt(0)) {
        return c - '1'.charCodeAt(0) + 1;
      }

      return 0;
    };

    var a = new Uint8Array(8);
    var bit = 63;

    for (var i = 0; i < s.length; ++i) {
      var c = charToSymbol(s.charCodeAt(i));

      if (bit < 5) {
        c = c << 1;
      }

      for (var j = 4; j >= 0; --j) {
        if (bit >= 0) {
          a[Math.floor(bit / 8)] |= (c >> j & 1) << bit % 8;
          --bit;
        }
      }
    }

    this.pushArray(a);
  }
  /** Get a `name` */
  ;

  _proto.getName = function getName() {
    var a = this.getUint8Array(8);
    var result = '';

    for (var bit = 63; bit >= 0;) {
      var c = 0;

      for (var i = 0; i < 5; ++i) {
        if (bit >= 0) {
          c = c << 1 | a[Math.floor(bit / 8)] >> bit % 8 & 1;
          --bit;
        }
      }

      if (c >= 6) {
        result += String.fromCharCode(c + 'a'.charCodeAt(0) - 6);
      } else if (c >= 1) {
        result += String.fromCharCode(c + '1'.charCodeAt(0) - 1);
      } else {
        result += '.';
      }
    }

    while (result.endsWith('.')) {
      result = result.substr(0, result.length - 1);
    }

    return result;
  }
  /** Append length-prefixed binary data */
  ;

  _proto.pushBytes = function pushBytes(v) {
    this.pushVaruint32(v.length);
    this.pushArray(v);
  }
  /** Get length-prefixed binary data */
  ;

  _proto.getBytes = function getBytes() {
    return this.getUint8Array(this.getVaruint32());
  }
  /** Append a string */
  ;

  _proto.pushString = function pushString(v) {
    this.pushBytes(this.textEncoder.encode(v));
  }
  /** Get a string */
  ;

  _proto.getString = function getString() {
    return this.textDecoder.decode(this.getBytes());
  }
  /** Append a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */
  ;

  _proto.pushSymbolCode = function pushSymbolCode(name) {
    if (typeof name !== 'string') {
      throw new Error('Expected string containing symbol_code');
    }

    var a = [];
    a.push.apply(a, this.textEncoder.encode(name));

    while (a.length < 8) {
      a.push(0);
    }

    this.pushArray(a.slice(0, 8));
  }
  /** Get a `symbol_code`. Unlike `symbol`, `symbol_code` doesn't include a precision. */
  ;

  _proto.getSymbolCode = function getSymbolCode() {
    var a = this.getUint8Array(8);
    var len;

    for (len = 0; len < a.length; ++len) {
      if (!a[len]) {
        break;
      }
    }

    var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
    return name;
  }
  /** Append a `symbol` */
  ;

  _proto.pushSymbol = function pushSymbol(_ref2) {
    var name = _ref2.name,
        precision = _ref2.precision;

    if (!/^[A-Z]{1,7}$/.test(name)) {
      throw new Error('Expected symbol to be A-Z and between one and seven characters');
    }

    var a = [precision & 0xff];
    a.push.apply(a, this.textEncoder.encode(name));

    while (a.length < 8) {
      a.push(0);
    }

    this.pushArray(a.slice(0, 8));
  }
  /** Get a `symbol` */
  ;

  _proto.getSymbol = function getSymbol() {
    var precision = this.get();
    var a = this.getUint8Array(7);
    var len;

    for (len = 0; len < a.length; ++len) {
      if (!a[len]) {
        break;
      }
    }

    var name = this.textDecoder.decode(new Uint8Array(a.buffer, a.byteOffset, len));
    return {
      name: name,
      precision: precision
    };
  }
  /** Append an asset */
  ;

  _proto.pushAsset = function pushAsset(s) {
    if (typeof s !== 'string') {
      throw new Error('Expected string containing asset');
    }

    s = s.trim();
    var pos = 0;
    var amount = '';
    var precision = 0;

    if (s[pos] === '-') {
      amount += '-';
      ++pos;
    }

    var foundDigit = false;

    while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
      foundDigit = true;
      amount += s[pos];
      ++pos;
    }

    if (!foundDigit) {
      throw new Error('Asset must begin with a number');
    }

    if (s[pos] === '.') {
      ++pos;

      while (pos < s.length && s.charCodeAt(pos) >= '0'.charCodeAt(0) && s.charCodeAt(pos) <= '9'.charCodeAt(0)) {
        amount += s[pos];
        ++precision;
        ++pos;
      }
    }

    var name = s.substr(pos).trim();
    this.pushArray(signedDecimalToBinary(8, amount));
    this.pushSymbol({
      name: name,
      precision: precision
    });
  }
  /** Get an asset */
  ;

  _proto.getAsset = function getAsset() {
    var amount = this.getUint8Array(8);

    var _this$getSymbol = this.getSymbol(),
        name = _this$getSymbol.name,
        precision = _this$getSymbol.precision;

    var s = signedBinaryToDecimal(amount, precision + 1);

    if (precision) {
      s = s.substr(0, s.length - precision) + '.' + s.substr(s.length - precision);
    }

    return s + ' ' + name;
  }
  /** Append a public key */
  ;

  _proto.pushPublicKey = function pushPublicKey(s) {
    var key = stringToPublicKey(s);
    this.push(key.type);
    this.pushArray(key.data);
  }
  /** Get a public key */
  ;

  _proto.getPublicKey = function getPublicKey() {
    var type = this.get();
    var data;

    if (type === KeyType.wa) {
      var begin = this.readPos;
      this.skip(34);
      this.skip(this.getVaruint32());
      data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
    } else {
      data = this.getUint8Array(publicKeyDataSize);
    }

    return publicKeyToString({
      type: type,
      data: data
    });
  }
  /** Append a private key */
  ;

  _proto.pushPrivateKey = function pushPrivateKey(s) {
    var key = stringToPrivateKey(s);
    this.push(key.type);
    this.pushArray(key.data);
  }
  /** Get a private key */
  ;

  _proto.getPrivateKey = function getPrivateKey() {
    var type = this.get();
    var data = this.getUint8Array(privateKeyDataSize);
    return privateKeyToString({
      type: type,
      data: data
    });
  }
  /** Append a signature */
  ;

  _proto.pushSignature = function pushSignature(s) {
    var key = stringToSignature(s);
    this.push(key.type);
    this.pushArray(key.data);
  }
  /** Get a signature */
  ;

  _proto.getSignature = function getSignature() {
    var type = this.get();
    var data;

    if (type === KeyType.wa) {
      var begin = this.readPos;
      this.skip(65);
      this.skip(this.getVaruint32());
      this.skip(this.getVaruint32());
      data = new Uint8Array(this.array.buffer, this.array.byteOffset + begin, this.readPos - begin);
    } else {
      data = this.getUint8Array(signatureDataSize);
    }

    return signatureToString({
      type: type,
      data: data
    });
  };

  return SerialBuffer;
}(); // SerialBuffer

/** Is this a supported ABI version? */

var supportedAbiVersion = function supportedAbiVersion(version) {
  return version.startsWith('eosio::abi/1.');
};

var checkDateParse = function checkDateParse(date) {
  var result = Date.parse(date);

  if (Number.isNaN(result)) {
    throw new Error('Invalid time format');
  }

  return result;
};
/** Convert date in ISO format to `time_point` (miliseconds since epoch) */


var dateToTimePoint = function dateToTimePoint(date) {
  return Math.round(checkDateParse(date + 'Z') * 1000);
};
/** Convert `time_point` (miliseconds since epoch) to date in ISO format */

var timePointToDate = function timePointToDate(us) {
  var s = new Date(us / 1000).toISOString();
  return s.substr(0, s.length - 1);
};
/** Convert date in ISO format to `time_point_sec` (seconds since epoch) */

var dateToTimePointSec = function dateToTimePointSec(date) {
  return Math.round(checkDateParse(date + 'Z') / 1000);
};
/** Convert `time_point_sec` (seconds since epoch) to to date in ISO format */

var timePointSecToDate = function timePointSecToDate(sec) {
  var s = new Date(sec * 1000).toISOString();
  return s.substr(0, s.length - 1);
};
/** Convert date in ISO format to `block_timestamp_type` (half-seconds since a different epoch) */

var dateToBlockTimestamp = function dateToBlockTimestamp(date) {
  return Math.round((checkDateParse(date + 'Z') - 946684800000) / 500);
};
/** Convert `block_timestamp_type` (half-seconds since a different epoch) to to date in ISO format */

var blockTimestampToDate = function blockTimestampToDate(slot) {
  var s = new Date(slot * 500 + 946684800000).toISOString();
  return s.substr(0, s.length - 1);
};
/** Convert `string` to `Symbol`. format: `precision,NAME`. */

var stringToSymbol = function stringToSymbol(s) {
  if (typeof s !== 'string') {
    throw new Error('Expected string containing symbol');
  }

  var m = s.match(/^([0-9]+),([A-Z]+)$/);

  if (!m) {
    throw new Error('Invalid symbol');
  }

  return {
    name: m[2],
    precision: +m[1]
  };
};
/** Convert `Symbol` to `string`. format: `precision,NAME`. */

var symbolToString = function symbolToString(_ref3) {
  var name = _ref3.name,
      precision = _ref3.precision;
  return precision + ',' + name;
};
/** Convert binary data to hex */

var arrayToHex = function arrayToHex(data) {
  var result = '';

  for (var _iterator = _createForOfIteratorHelperLoose(data), _step; !(_step = _iterator()).done;) {
    var x = _step.value;
    result += ('00' + x.toString(16)).slice(-2);
  }

  return result.toUpperCase();
};
/** Convert hex to binary data */

var hexToUint8Array = function hexToUint8Array(hex) {
  if (typeof hex !== 'string') {
    throw new Error('Expected string containing hex digits');
  }

  if (hex.length % 2) {
    throw new Error('Odd number of hex digits');
  }

  var l = hex.length / 2;
  var result = new Uint8Array(l);

  for (var i = 0; i < l; ++i) {
    var x = parseInt(hex.substr(i * 2, 2), 16);

    if (Number.isNaN(x)) {
      throw new Error('Expected hex string');
    }

    result[i] = x;
  }

  return result;
};

function serializeUnknown(_, __) {
  throw new Error('Don\'t know how to serialize ' + this.name);
}

function deserializeUnknown(_) {
  throw new Error('Don\'t know how to deserialize ' + this.name);
}

function serializeStruct(buffer, data, state, allowExtensions) {
  if (state === void 0) {
    state = new SerializerState();
  }

  if (allowExtensions === void 0) {
    allowExtensions = true;
  }

  if (typeof data !== 'object') {
    throw new Error('expected object containing data: ' + JSON.stringify(data));
  }

  if (this.base) {
    this.base.serialize(buffer, data, state, allowExtensions);
  }

  for (var _iterator2 = _createForOfIteratorHelperLoose(this.fields), _step2; !(_step2 = _iterator2()).done;) {
    var field = _step2.value;

    if (field.name in data) {
      if (state.skippedBinaryExtension) {
        throw new Error('unexpected ' + this.name + '.' + field.name);
      }

      field.type.serialize(buffer, data[field.name], state, allowExtensions && field === this.fields[this.fields.length - 1]);
    } else {
      if (allowExtensions && field.type.extensionOf) {
        state.skippedBinaryExtension = true;
      } else {
        throw new Error('missing ' + this.name + '.' + field.name + ' (type=' + field.type.name + ')');
      }
    }
  }
}

function deserializeStruct(buffer, state, allowExtensions) {
  if (state === void 0) {
    state = new SerializerState();
  }

  if (allowExtensions === void 0) {
    allowExtensions = true;
  }

  var result;

  if (this.base) {
    result = this.base.deserialize(buffer, state, allowExtensions);
  } else {
    result = {};
  }

  for (var _iterator3 = _createForOfIteratorHelperLoose(this.fields), _step3; !(_step3 = _iterator3()).done;) {
    var field = _step3.value;

    if (allowExtensions && field.type.extensionOf && !buffer.haveReadData()) {
      state.skippedBinaryExtension = true;
    } else {
      result[field.name] = field.type.deserialize(buffer, state, allowExtensions);
    }
  }

  return result;
}

function serializeVariant(buffer, data, state, allowExtensions) {
  if (!Array.isArray(data) || data.length !== 2 || typeof data[0] !== 'string') {
    throw new Error('expected variant: ["type", value]');
  }

  var i = this.fields.findIndex(function (field) {
    return field.name === data[0];
  });

  if (i < 0) {
    throw new Error("type \"" + data[0] + "\" is not valid for variant");
  }

  buffer.pushVaruint32(i);
  this.fields[i].type.serialize(buffer, data[1], state, allowExtensions);
}

function deserializeVariant(buffer, state, allowExtensions) {
  var i = buffer.getVaruint32();

  if (i >= this.fields.length) {
    throw new Error("type index " + i + " is not valid for variant");
  }

  var field = this.fields[i];
  return [field.name, field.type.deserialize(buffer, state, allowExtensions)];
}

function serializeArray(buffer, data, state
/*, allowExtensions?: boolean */
) {
  buffer.pushVaruint32(data.length);

  for (var _iterator4 = _createForOfIteratorHelperLoose(data), _step4; !(_step4 = _iterator4()).done;) {
    var item = _step4.value;
    this.arrayOf.serialize(buffer, item, state, false);
  }
}

function deserializeArray(buffer, state
/*, allowExtensions?: boolean */
) {
  var len = buffer.getVaruint32();
  var result = [];

  for (var i = 0; i < len; ++i) {
    result.push(this.arrayOf.deserialize(buffer, state, false));
  }

  return result;
}

function serializeOptional(buffer, data, state, allowExtensions) {
  if (data === null || data === undefined) {
    buffer.push(0);
  } else {
    buffer.push(1);
    this.optionalOf.serialize(buffer, data, state, allowExtensions);
  }
}

function deserializeOptional(buffer, state, allowExtensions) {
  if (buffer.get()) {
    return this.optionalOf.deserialize(buffer, state, allowExtensions);
  } else {
    return null;
  }
}

function serializeExtension(buffer, data, state, allowExtensions) {
  this.extensionOf.serialize(buffer, data, state, allowExtensions);
}

function deserializeExtension(buffer, state, allowExtensions) {
  return this.extensionOf.deserialize(buffer, state, allowExtensions);
}

function serializeObject(buffer, data, state, allowExtensions) {
  var entries = Object.entries(data);
  buffer.pushVaruint32(entries.length);

  for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {
    var _entries$_i = _entries[_i],
        key = _entries$_i[0],
        value = _entries$_i[1];
    var keyType = this.fields[0].type;
    var dataType = this.fields[1].type;
    keyType.serialize(buffer, key, state, allowExtensions);
    dataType.serialize(buffer, value, state, allowExtensions);
  }
}

function deserializeObject(buffer, state, allowExtensions) {
  var len = buffer.getVaruint32();
  var result = {};

  for (var i = 0; i < len; ++i) {
    var keyType = this.fields[0].type;
    var dataType = this.fields[1].type;
    var key = keyType.deserialize(buffer, state, allowExtensions);
    result[key] = dataType.deserialize(buffer, state, allowExtensions);
  }

  return result;
}

var createType = function createType(attrs) {
  return Object.assign({
    name: '<missing name>',
    aliasOfName: '',
    arrayOf: undefined,
    optionalOf: undefined,
    extensionOf: undefined,
    baseName: '',
    base: undefined,
    fields: [],
    serialize: serializeUnknown,
    deserialize: deserializeUnknown
  }, attrs);
};

var checkRange = function checkRange(orig, converted) {
  if (Number.isNaN(+orig) || Number.isNaN(+converted) || typeof orig !== 'number' && typeof orig !== 'string') {
    throw new Error('Expected number');
  }

  if (+orig !== +converted) {
    throw new Error('Number is out of range');
  }

  return +orig;
};
/** Create the set of types built-in to the abi format */


var createInitialTypes = function createInitialTypes() {
  var result = new Map(Object.entries({
    bool: createType({
      name: 'bool',
      serialize: function serialize(buffer, data) {
        if (!(typeof data === 'boolean' || typeof data === 'number' && (data === 1 || data === 0))) {
          throw new Error('Expected boolean or number equal to 1 or 0');
        }

        buffer.push(data ? 1 : 0);
      },
      deserialize: function deserialize(buffer) {
        return !!buffer.get();
      }
    }),
    uint8: createType({
      name: 'uint8',
      serialize: function serialize(buffer, data) {
        buffer.push(checkRange(data, data & 0xff));
      },
      deserialize: function deserialize(buffer) {
        return buffer.get();
      }
    }),
    int8: createType({
      name: 'int8',
      serialize: function serialize(buffer, data) {
        buffer.push(checkRange(data, data << 24 >> 24));
      },
      deserialize: function deserialize(buffer) {
        return buffer.get() << 24 >> 24;
      }
    }),
    uint16: createType({
      name: 'uint16',
      serialize: function serialize(buffer, data) {
        buffer.pushUint16(checkRange(data, data & 0xffff));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getUint16();
      }
    }),
    int16: createType({
      name: 'int16',
      serialize: function serialize(buffer, data) {
        buffer.pushUint16(checkRange(data, data << 16 >> 16));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getUint16() << 16 >> 16;
      }
    }),
    uint32: createType({
      name: 'uint32',
      serialize: function serialize(buffer, data) {
        buffer.pushUint32(checkRange(data, data >>> 0));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getUint32();
      }
    }),
    uint64: createType({
      name: 'uint64',
      serialize: function serialize(buffer, data) {
        buffer.pushArray(decimalToBinary(8, '' + data));
      },
      deserialize: function deserialize(buffer) {
        return binaryToDecimal(buffer.getUint8Array(8));
      }
    }),
    int64: createType({
      name: 'int64',
      serialize: function serialize(buffer, data) {
        buffer.pushArray(signedDecimalToBinary(8, '' + data));
      },
      deserialize: function deserialize(buffer) {
        return signedBinaryToDecimal(buffer.getUint8Array(8));
      }
    }),
    int32: createType({
      name: 'int32',
      serialize: function serialize(buffer, data) {
        buffer.pushUint32(checkRange(data, data | 0));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getUint32() | 0;
      }
    }),
    varuint32: createType({
      name: 'varuint32',
      serialize: function serialize(buffer, data) {
        buffer.pushVaruint32(checkRange(data, data >>> 0));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getVaruint32();
      }
    }),
    varint32: createType({
      name: 'varint32',
      serialize: function serialize(buffer, data) {
        buffer.pushVarint32(checkRange(data, data | 0));
      },
      deserialize: function deserialize(buffer) {
        return buffer.getVarint32();
      }
    }),
    uint128: createType({
      name: 'uint128',
      serialize: function serialize(buffer, data) {
        buffer.pushArray(decimalToBinary(16, '' + data));
      },
      deserialize: function deserialize(buffer) {
        return binaryToDecimal(buffer.getUint8Array(16));
      }
    }),
    int128: createType({
      name: 'int128',
      serialize: function serialize(buffer, data) {
        buffer.pushArray(signedDecimalToBinary(16, '' + data));
      },
      deserialize: function deserialize(buffer) {
        return signedBinaryToDecimal(buffer.getUint8Array(16));
      }
    }),
    float32: createType({
      name: 'float32',
      serialize: function serialize(buffer, data) {
        buffer.pushFloat32(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getFloat32();
      }
    }),
    float64: createType({
      name: 'float64',
      serialize: function serialize(buffer, data) {
        buffer.pushFloat64(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getFloat64();
      }
    }),
    float128: createType({
      name: 'float128',
      serialize: function serialize(buffer, data) {
        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 16);
      },
      deserialize: function deserialize(buffer) {
        return arrayToHex(buffer.getUint8Array(16));
      }
    }),
    bytes: createType({
      name: 'bytes',
      serialize: function serialize(buffer, data) {
        if (data instanceof Uint8Array || Array.isArray(data)) {
          buffer.pushBytes(data);
        } else {
          buffer.pushBytes(hexToUint8Array(data));
        }
      },
      deserialize: function deserialize(buffer, state) {
        if (state && state.options.bytesAsUint8Array) {
          return buffer.getBytes();
        } else {
          return arrayToHex(buffer.getBytes());
        }
      }
    }),
    string: createType({
      name: 'string',
      serialize: function serialize(buffer, data) {
        buffer.pushString(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getString();
      }
    }),
    name: createType({
      name: 'name',
      serialize: function serialize(buffer, data) {
        buffer.pushName(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getName();
      }
    }),
    time_point: createType({
      name: 'time_point',
      serialize: function serialize(buffer, data) {
        buffer.pushNumberAsUint64(dateToTimePoint(data));
      },
      deserialize: function deserialize(buffer) {
        return timePointToDate(buffer.getUint64AsNumber());
      }
    }),
    time_point_sec: createType({
      name: 'time_point_sec',
      serialize: function serialize(buffer, data) {
        buffer.pushUint32(dateToTimePointSec(data));
      },
      deserialize: function deserialize(buffer) {
        return timePointSecToDate(buffer.getUint32());
      }
    }),
    block_timestamp_type: createType({
      name: 'block_timestamp_type',
      serialize: function serialize(buffer, data) {
        buffer.pushUint32(dateToBlockTimestamp(data));
      },
      deserialize: function deserialize(buffer) {
        return blockTimestampToDate(buffer.getUint32());
      }
    }),
    symbol_code: createType({
      name: 'symbol_code',
      serialize: function serialize(buffer, data) {
        buffer.pushSymbolCode(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getSymbolCode();
      }
    }),
    symbol: createType({
      name: 'symbol',
      serialize: function serialize(buffer, data) {
        buffer.pushSymbol(stringToSymbol(data));
      },
      deserialize: function deserialize(buffer) {
        return symbolToString(buffer.getSymbol());
      }
    }),
    asset: createType({
      name: 'asset',
      serialize: function serialize(buffer, data) {
        buffer.pushAsset(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getAsset();
      }
    }),
    checksum160: createType({
      name: 'checksum160',
      serialize: function serialize(buffer, data) {
        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 20);
      },
      deserialize: function deserialize(buffer) {
        return arrayToHex(buffer.getUint8Array(20));
      }
    }),
    checksum256: createType({
      name: 'checksum256',
      serialize: function serialize(buffer, data) {
        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 32);
      },
      deserialize: function deserialize(buffer) {
        return arrayToHex(buffer.getUint8Array(32));
      }
    }),
    checksum512: createType({
      name: 'checksum512',
      serialize: function serialize(buffer, data) {
        buffer.pushUint8ArrayChecked(hexToUint8Array(data), 64);
      },
      deserialize: function deserialize(buffer) {
        return arrayToHex(buffer.getUint8Array(64));
      }
    }),
    public_key: createType({
      name: 'public_key',
      serialize: function serialize(buffer, data) {
        buffer.pushPublicKey(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getPublicKey();
      }
    }),
    private_key: createType({
      name: 'private_key',
      serialize: function serialize(buffer, data) {
        buffer.pushPrivateKey(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getPrivateKey();
      }
    }),
    signature: createType({
      name: 'signature',
      serialize: function serialize(buffer, data) {
        buffer.pushSignature(data);
      },
      deserialize: function deserialize(buffer) {
        return buffer.getSignature();
      }
    })
  }));
  result.set('extended_asset', createType({
    name: 'extended_asset',
    baseName: '',
    fields: [{
      name: 'quantity',
      typeName: 'asset',
      type: result.get('asset')
    }, {
      name: 'contract',
      typeName: 'name',
      type: result.get('name')
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  return result;
}; // createInitialTypes()

var createAbiTypes = function createAbiTypes() {
  var initialTypes = createInitialTypes();
  initialTypes.set('extensions_entry', createType({
    name: 'extensions_entry',
    baseName: '',
    fields: [{
      name: 'tag',
      typeName: 'uint16',
      type: undefined
    }, {
      name: 'value',
      typeName: 'bytes',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('type_def', createType({
    name: 'type_def',
    baseName: '',
    fields: [{
      name: 'new_type_name',
      typeName: 'string',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('field_def', createType({
    name: 'field_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'string',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('struct_def', createType({
    name: 'struct_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'string',
      type: undefined
    }, {
      name: 'base',
      typeName: 'string',
      type: undefined
    }, {
      name: 'fields',
      typeName: 'field_def[]',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('action_def', createType({
    name: 'action_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }, {
      name: 'ricardian_contract',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('table_def', createType({
    name: 'table_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'index_type',
      typeName: 'string',
      type: undefined
    }, {
      name: 'key_names',
      typeName: 'string[]',
      type: undefined
    }, {
      name: 'key_types',
      typeName: 'string[]',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('clause_pair', createType({
    name: 'clause_pair',
    baseName: '',
    fields: [{
      name: 'id',
      typeName: 'string',
      type: undefined
    }, {
      name: 'body',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('error_message', createType({
    name: 'error_message',
    baseName: '',
    fields: [{
      name: 'error_code',
      typeName: 'uint64',
      type: undefined
    }, {
      name: 'error_msg',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('variant_def', createType({
    name: 'variant_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'string',
      type: undefined
    }, {
      name: 'types',
      typeName: 'string[]',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('action_result', createType({
    name: 'action_result',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'result_type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('primary_key_index_def', createType({
    name: 'primary_key_index_def',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('secondary_index_def', createType({
    name: 'secondary_index_def',
    baseName: '',
    fields: [{
      name: 'type',
      typeName: 'string',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('secondary_indices', createType({
    name: 'secondary_indices',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'secondary_index_def',
      typeName: 'secondary_index_def',
      type: undefined
    }],
    serialize: serializeObject,
    deserialize: deserializeObject
  }));
  initialTypes.set('kv_table_entry_def', createType({
    name: 'kv_table_entry_def',
    baseName: '',
    fields: [{
      name: 'type',
      typeName: 'string',
      type: undefined
    }, {
      name: 'primary_index',
      typeName: 'primary_key_index_def',
      type: undefined
    }, {
      name: 'secondary_indices',
      typeName: 'secondary_indices',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  initialTypes.set('kv_table', createType({
    name: 'kv_table',
    baseName: '',
    fields: [{
      name: 'name',
      typeName: 'name',
      type: undefined
    }, {
      name: 'kv_table_entry_def',
      typeName: 'kv_table_entry_def',
      type: undefined
    }],
    serialize: serializeObject,
    deserialize: deserializeObject
  }));
  initialTypes.set('abi_def', createType({
    name: 'abi_def',
    baseName: '',
    fields: [{
      name: 'version',
      typeName: 'string',
      type: undefined
    }, {
      name: 'types',
      typeName: 'type_def[]',
      type: undefined
    }, {
      name: 'structs',
      typeName: 'struct_def[]',
      type: undefined
    }, {
      name: 'actions',
      typeName: 'action_def[]',
      type: undefined
    }, {
      name: 'tables',
      typeName: 'table_def[]',
      type: undefined
    }, {
      name: 'ricardian_clauses',
      typeName: 'clause_pair[]',
      type: undefined
    }, {
      name: 'error_messages',
      typeName: 'error_message[]',
      type: undefined
    }, {
      name: 'abi_extensions',
      typeName: 'extensions_entry[]',
      type: undefined
    }, {
      name: 'variants',
      typeName: 'variant_def[]$',
      type: undefined
    }, {
      name: 'action_results',
      typeName: 'action_result[]$',
      type: undefined
    }, {
      name: 'kv_tables',
      typeName: 'kv_table$',
      type: undefined
    }],
    serialize: serializeStruct,
    deserialize: deserializeStruct
  }));
  return initialTypes;
};
/** Get type from `types` */

var getType = function getType(types, name) {
  var type = types.get(name);

  if (type && type.aliasOfName) {
    return getType(types, type.aliasOfName);
  }

  if (type) {
    return type;
  }

  if (name.endsWith('[]')) {
    return createType({
      name: name,
      arrayOf: getType(types, name.substr(0, name.length - 2)),
      serialize: serializeArray,
      deserialize: deserializeArray
    });
  }

  if (name.endsWith('?')) {
    return createType({
      name: name,
      optionalOf: getType(types, name.substr(0, name.length - 1)),
      serialize: serializeOptional,
      deserialize: deserializeOptional
    });
  }

  if (name.endsWith('$')) {
    return createType({
      name: name,
      extensionOf: getType(types, name.substr(0, name.length - 1)),
      serialize: serializeExtension,
      deserialize: deserializeExtension
    });
  }

  throw new Error('Unknown type: ' + name);
};
/**
 * Get types from abi
 *
 * @param initialTypes Set of types to build on.
 * In most cases, it's best to fill this from a fresh call to `getTypesFromAbi()`.
 */

var getTypesFromAbi = function getTypesFromAbi(initialTypes, abi) {
  var types = new Map(initialTypes);

  if (abi && abi.types) {
    for (var _iterator5 = _createForOfIteratorHelperLoose(abi.types), _step5; !(_step5 = _iterator5()).done;) {
      var _step5$value = _step5.value,
          new_type_name = _step5$value.new_type_name,
          type = _step5$value.type;
      types.set(new_type_name, createType({
        name: new_type_name,
        aliasOfName: type
      }));
    }
  }

  if (abi && abi.structs) {
    for (var _iterator6 = _createForOfIteratorHelperLoose(abi.structs), _step6; !(_step6 = _iterator6()).done;) {
      var _step6$value = _step6.value,
          name = _step6$value.name,
          base = _step6$value.base,
          fields = _step6$value.fields;
      types.set(name, createType({
        name: name,
        baseName: base,
        fields: fields.map(function (_ref4) {
          var n = _ref4.name,
              type = _ref4.type;
          return {
            name: n,
            typeName: type,
            type: undefined
          };
        }),
        serialize: serializeStruct,
        deserialize: deserializeStruct
      }));
    }
  }

  if (abi && abi.variants) {
    for (var _iterator7 = _createForOfIteratorHelperLoose(abi.variants), _step7; !(_step7 = _iterator7()).done;) {
      var _step7$value = _step7.value,
          _name = _step7$value.name,
          t = _step7$value.types;
      types.set(_name, createType({
        name: _name,
        fields: t.map(function (s) {
          return {
            name: s,
            typeName: s,
            type: undefined
          };
        }),
        serialize: serializeVariant,
        deserialize: deserializeVariant
      }));
    }
  }

  for (var _iterator8 = _createForOfIteratorHelperLoose(types), _step8; !(_step8 = _iterator8()).done;) {
    var _step8$value = _step8.value,

    _type = _step8$value[1];

    if (_type.baseName) {
      _type.base = getType(types, _type.baseName);
    }

    for (var _iterator9 = _createForOfIteratorHelperLoose(_type.fields), _step9; !(_step9 = _iterator9()).done;) {
      var field = _step9.value;
      field.type = getType(types, field.typeName);
    }
  }

  return types;
}; // getTypesFromAbi

var reverseHex = function reverseHex(h) {
  return h.substr(6, 2) + h.substr(4, 2) + h.substr(2, 2) + h.substr(0, 2);
};
/** TAPoS: Return transaction fields which reference `refBlock` and expire `expireSeconds` after `timestamp` */


var transactionHeader = function transactionHeader(refBlock, expireSeconds) {
  var timestamp = refBlock.header ? refBlock.header.timestamp : refBlock.timestamp;
  var prefix = parseInt(reverseHex(refBlock.id.substr(16, 8)), 16);
  return {
    expiration: timePointSecToDate(dateToTimePointSec(timestamp) + expireSeconds),
    ref_block_num: refBlock.block_num & 0xffff,
    ref_block_prefix: prefix
  };
};
/** Convert action data to serialized form (hex) */

var serializeActionData = function serializeActionData(contract, account, name, data) {
  var action = contract.actions.get(name);

  if (!action) {
    throw new Error("Unknown action " + name + " in contract " + account);
  }

  var buffer = new SerialBuffer();
  action.serialize(buffer, data);
  return arrayToHex(buffer.asUint8Array());
};
/** Return action in serialized form */

var serializeAction = function serializeAction(contract, account, name, authorization, data) {
  return {
    account: account,
    name: name,
    authorization: authorization,
    data: serializeActionData(contract, account, name, data)
  };
};
/** Deserialize action data. If `data` is a `string`, then it's assumed to be in hex. */

var deserializeActionData = function deserializeActionData(contract, account, name, data) {
  var action = contract.actions.get(name);

  if (typeof data === 'string') {
    data = hexToUint8Array(data);
  }

  if (!action) {
    throw new Error("Unknown action " + name + " in contract " + account);
  }

  var buffer = new SerialBuffer();
  buffer.pushArray(data);
  return action.deserialize(buffer);
};
/** Deserialize action. If `data` is a `string`, then it's assumed to be in hex. */

var deserializeAction = function deserializeAction(contract, account, name, authorization, data) {
  return {
    account: account,
    name: name,
    authorization: authorization,
    data: deserializeActionData(contract, account, name, data)
  };
};
var serializeAnyvar = function serializeAnyvar(buffer, anyvar) {
  var def;
  var value;

  if (anyvar === null) {
    var _ref5 = [anyvarDefs.null_t, anyvar];
    def = _ref5[0];
    value = _ref5[1];
  } else if (typeof anyvar === 'string') {
    var _ref6 = [anyvarDefs.string, anyvar];
    def = _ref6[0];
    value = _ref6[1];
  } else if (typeof anyvar === 'number') {
    var _ref7 = [anyvarDefs.int32, anyvar];
    def = _ref7[0];
    value = _ref7[1];
  } else if (anyvar instanceof Uint8Array) {
    var _ref8 = [anyvarDefs.bytes, anyvar];
    def = _ref8[0];
    value = _ref8[1];
  } else if (Array.isArray(anyvar)) {
    var _ref9 = [anyvarDefs.any_array, anyvar];
    def = _ref9[0];
    value = _ref9[1];
  } else if (Object.keys(anyvar).length === 2 && anyvar.hasOwnProperty('type') && anyvar.hasOwnProperty('value')) {
    var _ref10 = [anyvarDefs[anyvar.type], anyvar.value];
    def = _ref10[0];
    value = _ref10[1];
  } else {
    var _ref11 = [anyvarDefs.any_object, anyvar];
    def = _ref11[0];
    value = _ref11[1];
  }

  buffer.pushVaruint32(def.index);
  def.type.serialize(buffer, value);
};
var deserializeAnyvar = function deserializeAnyvar(buffer, state) {
  var defIndex = buffer.getVaruint32();

  if (defIndex >= anyvarDefsByIndex.length) {
    throw new Error('Tried to deserialize unknown anyvar type');
  }

  var def = anyvarDefsByIndex[defIndex];
  var value = def.type.deserialize(buffer, state);

  if (state && state.options.useShortForm || def.useShortForm) {
    return value;
  } else {
    return {
      type: def.type.name,
      value: value
    };
  }
};
var deserializeAnyvarShort = function deserializeAnyvarShort(buffer) {
  return deserializeAnyvar(buffer, new SerializerState({
    useShortForm: true
  }));
};
var serializeAnyObject = function serializeAnyObject(buffer, obj) {
  var entries = Object.entries(obj);
  buffer.pushVaruint32(entries.length);

  for (var _i2 = 0, _entries2 = entries; _i2 < _entries2.length; _i2++) {
    var _entries2$_i = _entries2[_i2],
        key = _entries2$_i[0],
        value = _entries2$_i[1];
    buffer.pushString(key);
    serializeAnyvar(buffer, value);
  }
};
var deserializeAnyObject = function deserializeAnyObject(buffer, state) {
  var len = buffer.getVaruint32();
  var result = {};

  for (var i = 0; i < len; ++i) {
    var key = buffer.getString();

    if (key in result) {
      var j = 1;

      while (key + '_' + j in result) {
        ++j;
      }

      key = key + '_' + j;
    }

    result[key] = deserializeAnyvar(buffer, state);
  }

  return result;
};
var serializeAnyArray = function serializeAnyArray(buffer, arr) {
  buffer.pushVaruint32(arr.length);

  for (var _iterator10 = _createForOfIteratorHelperLoose(arr), _step10; !(_step10 = _iterator10()).done;) {
    var x = _step10.value;
    serializeAnyvar(buffer, x);
  }
};
var deserializeAnyArray = function deserializeAnyArray(buffer, state) {
  var len = buffer.getVaruint32();
  var result = [];

  for (var i = 0; i < len; ++i) {
    result.push(deserializeAnyvar(buffer, state));
  }

  return result;
};

var addAdditionalTypes = function addAdditionalTypes() {
  var initialTypes = createInitialTypes();
  initialTypes.set('null_t', createType({
    name: 'null_t',
    serialize: function serialize(_, __) {},
    deserialize: function deserialize(_, __) {}
  }));
  initialTypes.set('any_object', createType({
    name: 'any_object',
    serialize: serializeAnyObject,
    deserialize: deserializeAnyObject
  }));
  initialTypes.set('any_array', createType({
    name: 'any_array',
    serialize: serializeAnyArray,
    deserialize: deserializeAnyArray
  }));
  return initialTypes;
};

var additionalTypes = /*#__PURE__*/addAdditionalTypes();
var anyvarDefs = {
  null_t: {
    index: 0,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('null_t')
  },
  int64: {
    index: 1,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('int64')
  },
  uint64: {
    index: 2,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('uint64')
  },
  int32: {
    index: 3,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('int32')
  },
  uint32: {
    index: 4,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('uint32')
  },
  int16: {
    index: 5,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('int16')
  },
  uint16: {
    index: 6,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('uint16')
  },
  int8: {
    index: 7,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('int8')
  },
  uint8: {
    index: 8,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('uint8')
  },
  time_point: {
    index: 9,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('time_point')
  },
  checksum256: {
    index: 10,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('checksum256')
  },
  float64: {
    index: 11,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('float64')
  },
  string: {
    index: 12,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('string')
  },
  any_object: {
    index: 13,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('any_object')
  },
  any_array: {
    index: 14,
    useShortForm: true,
    type: /*#__PURE__*/additionalTypes.get('any_array')
  },
  bytes: {
    index: 15,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('bytes')
  },
  symbol: {
    index: 16,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('symbol')
  },
  symbol_code: {
    index: 17,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('symbol_code')
  },
  asset: {
    index: 18,
    useShortForm: false,
    type: /*#__PURE__*/additionalTypes.get('asset')
  }
};
var anyvarDefsByIndex = [anyvarDefs.null_t, anyvarDefs.int64, anyvarDefs.uint64, anyvarDefs.int32, anyvarDefs.uint32, anyvarDefs.int16, anyvarDefs.uint16, anyvarDefs.int8, anyvarDefs.uint8, anyvarDefs.time_point, anyvarDefs.checksum256, anyvarDefs.float64, anyvarDefs.string, anyvarDefs.any_object, anyvarDefs.any_array, anyvarDefs.bytes, anyvarDefs.symbol, anyvarDefs.symbol_code, anyvarDefs.asset];
var serializeQuery = function serializeQuery(buffer, query) {
  var method;
  var arg;
  var filter;

  if (typeof query === 'string') {
    method = query;
  } else if (Array.isArray(query) && query.length === 2) {
    method = query[0];
    filter = query[1];
  } else if (Array.isArray(query) && query.length === 3) {
    method = query[0];
    arg = query[1];
    filter = query[2];
  } else {
    var _ref12 = [query.method, query.arg, query.filter];
    method = _ref12[0];
    arg = _ref12[1];
    filter = _ref12[2];
  }

  buffer.pushString(method); // @ts-ignore

  if (arg === undefined) {
    buffer.push(0);
  } else {
    buffer.push(1);
    serializeAnyvar(buffer, arg);
  } // @ts-ignore


  if (filter === undefined) {
    buffer.push(0);
  } else {
    buffer.pushVaruint32(filter.length);

    for (var _iterator11 = _createForOfIteratorHelperLoose(filter), _step11; !(_step11 = _iterator11()).done;) {
      var q = _step11.value;
      serializeQuery(buffer, q);
    }
  }
};

var Serialize = {
  __proto__: null,
  SerializerState: SerializerState,
  SerialBuffer: SerialBuffer,
  supportedAbiVersion: supportedAbiVersion,
  dateToTimePoint: dateToTimePoint,
  timePointToDate: timePointToDate,
  dateToTimePointSec: dateToTimePointSec,
  timePointSecToDate: timePointSecToDate,
  dateToBlockTimestamp: dateToBlockTimestamp,
  blockTimestampToDate: blockTimestampToDate,
  stringToSymbol: stringToSymbol,
  symbolToString: symbolToString,
  arrayToHex: arrayToHex,
  hexToUint8Array: hexToUint8Array,
  createInitialTypes: createInitialTypes,
  createAbiTypes: createAbiTypes,
  getType: getType,
  getTypesFromAbi: getTypesFromAbi,
  transactionHeader: transactionHeader,
  serializeActionData: serializeActionData,
  serializeAction: serializeAction,
  deserializeActionData: deserializeActionData,
  deserializeAction: deserializeAction,
  serializeAnyvar: serializeAnyvar,
  deserializeAnyvar: deserializeAnyvar,
  deserializeAnyvarShort: deserializeAnyvarShort,
  serializeAnyObject: serializeAnyObject,
  deserializeAnyObject: deserializeAnyObject,
  serializeAnyArray: serializeAnyArray,
  deserializeAnyArray: deserializeAnyArray,
  serializeQuery: serializeQuery
};

/** Construct the elliptic curve object based on key type */

var constructElliptic = function constructElliptic(type) {
  if (type === KeyType.k1) {
    return new ec('secp256k1');
  }

  return new ec('p256');
};
var sha256 = function sha256(data) {
  return sha256$1().update(data).digest('hex');
};

/** Represents/stores a public key and provides easy conversion for use with `elliptic` lib */

var PublicKey = /*#__PURE__*/function () {
  function PublicKey(key, ec) {
    this.key = key;
    this.ec = ec;
  }
  /** Instantiate public key from an EOSIO-format public key */


  PublicKey.fromString = function fromString(publicKeyStr, ec) {
    var key = stringToPublicKey(publicKeyStr);

    if (!ec) {
      ec = constructElliptic(key.type);
    }

    return new PublicKey(key, ec);
  }
  /** Instantiate public key from an `elliptic`-format public key */
  ;

  PublicKey.fromElliptic = function fromElliptic(publicKey, keyType, ec) {
    var x = publicKey.getPublic().getX().toArray('be', 32);
    var y = publicKey.getPublic().getY().toArray('be', 32);

    if (!ec) {
      ec = constructElliptic(keyType);
    }

    return new PublicKey({
      type: keyType,
      data: new Uint8Array([y[31] & 1 ? 3 : 2].concat(x))
    }, ec);
  }
  /** Export public key as EOSIO-format public key */
  ;

  var _proto = PublicKey.prototype;

  _proto.toString = function toString() {
    return publicKeyToString(this.key);
  }
  /** Export public key as Legacy EOSIO-format public key */
  ;

  _proto.toLegacyString = function toLegacyString(prefix) {
    return publicKeyToLegacyString(this.key, prefix);
  }
  /** Export public key as `elliptic`-format public key */
  ;

  _proto.toElliptic = function toElliptic() {
    return this.ec.keyPair({
      pub: Buffer.from(this.key.data)
    });
  }
  /** Get key type from key */
  ;

  _proto.getType = function getType() {
    return this.key.type;
  }
  /** Validate a public key */
  ;

  _proto.isValid = function isValid() {
    try {
      var ellipticPublicKey = this.toElliptic();
      var validationObj = ellipticPublicKey.validate();
      return validationObj.result;
    } catch (_unused) {
      return false;
    }
  };

  return PublicKey;
}();

var BN = /*#__PURE__*/require('bn.js');
/** Represents/stores a Signature and provides easy conversion for use with `elliptic` lib */

var Signature = /*#__PURE__*/function () {
  function Signature(signature, ec) {
    this.signature = signature;
    this.ec = ec;
  }
  /** Instantiate Signature from an EOSIO-format Signature */


  Signature.fromString = function fromString(sig, ec) {
    var signature = stringToSignature(sig);

    if (!ec) {
      ec = constructElliptic(signature.type);
    }

    return new Signature(signature, ec);
  }
  /** Instantiate Signature from an `elliptic`-format Signature */
  ;

  Signature.fromElliptic = function fromElliptic(ellipticSig, keyType, ec) {
    if (!ellipticSig.recoveryParam) {
      ellipticSig.recoveryParam = 0;
    }

    var r = ellipticSig.r.toArray('be', 32);
    var s = ellipticSig.s.toArray('be', 32);
    var eosioRecoveryParam;

    if (keyType === KeyType.k1 || keyType === KeyType.r1) {
      eosioRecoveryParam = ellipticSig.recoveryParam + 27;

      if (ellipticSig.recoveryParam <= 3) {
        eosioRecoveryParam += 4;
      }
    } else if (keyType === KeyType.wa) {
      eosioRecoveryParam = ellipticSig.recoveryParam;
    }

    var sigData = new Uint8Array([eosioRecoveryParam].concat(r, s));

    if (!ec) {
      ec = constructElliptic(keyType);
    }

    return new Signature({
      type: keyType,
      data: sigData
    }, ec);
  }
  /** Export Signature as `elliptic`-format Signature
   * NOTE: This isn't an actual elliptic-format Signature, as ec.Signature is not exported by the library.
   * That's also why the return type is `any`.  We're *actually* returning an object with the 3 params
   * not an ec.Signature.
   * Further NOTE: @types/elliptic shows ec.Signature as exported; it is *not*.  Hence the `any`.
   */
  ;

  var _proto = Signature.prototype;

  _proto.toElliptic = function toElliptic() {
    var lengthOfR = 32;
    var lengthOfS = 32;
    var r = new BN(this.signature.data.slice(1, lengthOfR + 1));
    var s = new BN(this.signature.data.slice(lengthOfR + 1, lengthOfR + lengthOfS + 1));
    var ellipticRecoveryBitField;

    if (this.signature.type === KeyType.k1 || this.signature.type === KeyType.r1) {
      ellipticRecoveryBitField = this.signature.data[0] - 27;

      if (ellipticRecoveryBitField > 3) {
        ellipticRecoveryBitField -= 4;
      }
    } else if (this.signature.type === KeyType.wa) {
      ellipticRecoveryBitField = this.signature.data[0];
    } else {
      ellipticRecoveryBitField = 0;
    }

    var recoveryParam = ellipticRecoveryBitField & 3;
    return {
      r: r,
      s: s,
      recoveryParam: recoveryParam
    };
  }
  /** Export Signature as EOSIO-format Signature */
  ;

  _proto.toString = function toString() {
    return signatureToString(this.signature);
  }
  /** Export Signature in binary format */
  ;

  _proto.toBinary = function toBinary() {
    return this.signature.data;
  }
  /** Get key type from signature */
  ;

  _proto.getType = function getType() {
    return this.signature.type;
  }
  /** Verify a signature with a message or hashed message digest and public key */
  ;

  _proto.verify = function verify(data, publicKey, shouldHash, encoding) {
    if (shouldHash === void 0) {
      shouldHash = true;
    }

    if (encoding === void 0) {
      encoding = 'utf8';
    }

    if (shouldHash) {
      if (typeof data === 'string') {
        data = Buffer.from(data, encoding);
      }

      data = this.ec.hash().update(data).digest();
    }

    var ellipticSignature = this.toElliptic();
    var ellipticPublicKey = publicKey.toElliptic();
    return this.ec.verify(data, ellipticSignature, ellipticPublicKey, encoding);
  }
  /** Recover a public key from a message or hashed message digest and signature */
  ;

  _proto.recover = function recover(data, shouldHash, encoding) {
    if (shouldHash === void 0) {
      shouldHash = true;
    }

    if (encoding === void 0) {
      encoding = 'utf8';
    }

    if (shouldHash) {
      if (typeof data === 'string') {
        data = Buffer.from(data, encoding);
      }

      data = this.ec.hash().update(data).digest();
    }

    var ellipticSignature = this.toElliptic();
    var recoveredPublicKey = this.ec.recoverPubKey(data, ellipticSignature, ellipticSignature.recoveryParam, encoding);
    var ellipticKPub = this.ec.keyFromPublic(recoveredPublicKey);
    return PublicKey.fromElliptic(ellipticKPub, this.getType(), this.ec);
  };

  return Signature;
}();

/** Represents/stores a private key and provides easy conversion for use with `elliptic` lib */

var PrivateKey = /*#__PURE__*/function () {
  function PrivateKey(key, ec) {
    this.key = key;
    this.ec = ec;
  }
  /** Instantiate private key from an `elliptic`-format private key */


  PrivateKey.fromElliptic = function fromElliptic(privKey, keyType, ec) {
    if (!ec) {
      ec = constructElliptic(keyType);
    }

    return new PrivateKey({
      type: keyType,
      data: privKey.getPrivate().toArrayLike(Buffer, 'be', 32)
    }, ec);
  }
  /** Instantiate private key from an EOSIO-format private key */
  ;

  PrivateKey.fromString = function fromString(keyString, ec) {
    var privateKey = stringToPrivateKey(keyString);

    if (!ec) {
      ec = constructElliptic(privateKey.type);
    }

    return new PrivateKey(privateKey, ec);
  }
  /** Export private key as `elliptic`-format private key */
  ;

  var _proto = PrivateKey.prototype;

  _proto.toElliptic = function toElliptic() {
    return this.ec.keyFromPrivate(this.key.data);
  };

  _proto.toLegacyString = function toLegacyString() {
    return privateKeyToLegacyString(this.key);
  }
  /** Export private key as EOSIO-format private key */
  ;

  _proto.toString = function toString() {
    return privateKeyToString(this.key);
  }
  /** Get key type from key */
  ;

  _proto.getType = function getType() {
    return this.key.type;
  }
  /** Retrieve the public key from a private key */
  ;

  _proto.getPublicKey = function getPublicKey() {
    var ellipticPrivateKey = this.toElliptic();
    return PublicKey.fromElliptic(ellipticPrivateKey, this.getType(), this.ec);
  }
  /** Sign a message or hashed message digest with private key */
  ;

  _proto.sign = function sign(data, shouldHash, encoding) {
    var _this = this;

    if (shouldHash === void 0) {
      shouldHash = true;
    }

    if (encoding === void 0) {
      encoding = 'utf8';
    }

    if (shouldHash) {
      if (typeof data === 'string') {
        data = Buffer.from(data, encoding);
      }

      data = this.ec.hash().update(data).digest();
    }

    var tries = 0;
    var signature;

    var isCanonical = function isCanonical(sigData) {
      return !(sigData[1] & 0x80) && !(sigData[1] === 0 && !(sigData[2] & 0x80)) && !(sigData[33] & 0x80) && !(sigData[33] === 0 && !(sigData[34] & 0x80));
    };

    var constructSignature = function constructSignature(options) {
      var ellipticPrivateKey = _this.toElliptic();

      var ellipticSignature = ellipticPrivateKey.sign(data, options);
      return Signature.fromElliptic(ellipticSignature, _this.getType(), _this.ec);
    };

    if (this.key.type === KeyType.k1) {
      do {
        signature = constructSignature({
          canonical: true,
          pers: [++tries]
        });
      } while (!isCanonical(signature.toBinary()));
    } else {
      signature = constructSignature({
        canonical: true
      });
    }

    return signature;
  }
  /** Validate a private key */
  ;

  _proto.isValid = function isValid() {
    try {
      var ellipticPrivateKey = this.toElliptic();
      var validationObj = ellipticPrivateKey.validate();
      return validationObj.result;
    } catch (_unused) {
      return false;
    }
  };

  return PrivateKey;
}();

var generateKeyPair = function generateKeyPair(type, options) {
  if (options === void 0) {
    options = {};
  }

  if (!options.secureEnv) {
    throw new Error('Key generation is completely INSECURE in production environments in the browser. ' + 'If you are absolutely certain this does NOT describe your environment, set `secureEnv` in your ' + 'options to `true`.  If this does describe your environment and you set `secureEnv` to `true`, ' + 'YOU DO SO AT YOUR OWN RISK AND THE RISK OF YOUR USERS.');
  }

  var ec$1;

  if (type === KeyType.k1) {
    ec$1 = new ec('secp256k1');
  } else {
    ec$1 = new ec('p256');
  }

  var ellipticKeyPair = ec$1.genKeyPair(options.ecOptions);
  var publicKey = PublicKey.fromElliptic(ellipticKeyPair, type, ec$1);
  var privateKey = PrivateKey.fromElliptic(ellipticKeyPair, type, ec$1);
  return {
    publicKey: publicKey,
    privateKey: privateKey
  };
};

var Key = {
  __proto__: null,
  generateKeyPair: generateKeyPair,
  PrivateKey: PrivateKey,
  PublicKey: PublicKey,
  Signature: Signature,
  constructElliptic: constructElliptic
};

/** expensive to construct; so we do it once and reuse it */

var defaultEc = /*#__PURE__*/new ec('secp256k1');
/** Construct the digest from transaction details */

var digestFromSerializedData = function digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData, e) {
  if (e === void 0) {
    e = defaultEc;
  }

  var signBuf = Buffer.concat([Buffer.from(chainId, 'hex'), Buffer.from(serializedTransaction), Buffer.from(serializedContextFreeData ? new Uint8Array(e.hash().update(serializedContextFreeData).digest()) : new Uint8Array(32))]);
  return e.hash().update(signBuf).digest();
};
/** Signs transactions using in-process private keys */


var JsSignatureProvider = /*#__PURE__*/function () {
  /** @param privateKeys private keys to sign with */
  function JsSignatureProvider(privateKeys) {
    /** map public to private keys */
    this.keys = new Map();
    /** public keys */

    this.availableKeys = [];

    for (var _iterator = _createForOfIteratorHelperLoose(privateKeys), _step; !(_step = _iterator()).done;) {
      var k = _step.value;
      var priv = PrivateKey.fromString(k);
      var privElliptic = priv.toElliptic();
      var pubStr = priv.getPublicKey().toString();
      this.keys.set(pubStr, privElliptic);
      this.availableKeys.push(pubStr);
    }
  }
  /** Public keys associated with the private keys that the `SignatureProvider` holds */


  var _proto = JsSignatureProvider.prototype;

  _proto.getAvailableKeys =
  /*#__PURE__*/
  function () {
    var _getAvailableKeys = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.availableKeys);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getAvailableKeys() {
      return _getAvailableKeys.apply(this, arguments);
    }

    return getAvailableKeys;
  }()
  /** Sign a transaction */
  ;

  _proto.sign =
  /*#__PURE__*/
  function () {
    var _sign = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref) {
      var chainId, requiredKeys, serializedTransaction, serializedContextFreeData, digest, signatures, _iterator2, _step2, key, publicKey, ellipticPrivateKey, privateKey, signature;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              chainId = _ref.chainId, requiredKeys = _ref.requiredKeys, serializedTransaction = _ref.serializedTransaction, serializedContextFreeData = _ref.serializedContextFreeData;
              digest = digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData, defaultEc);
              signatures = [];

              for (_iterator2 = _createForOfIteratorHelperLoose(requiredKeys); !(_step2 = _iterator2()).done;) {
                key = _step2.value;
                publicKey = PublicKey.fromString(key);
                ellipticPrivateKey = this.keys.get(convertLegacyPublicKey(key));

                if (ellipticPrivateKey) {
                  privateKey = PrivateKey.fromElliptic(ellipticPrivateKey, publicKey.getType());
                  signature = privateKey.sign(digest, false);
                  signatures.push(signature.toString());
                }
              }

              return _context2.abrupt("return", {
                signatures: signatures,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData
              });

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function sign(_x) {
      return _sign.apply(this, arguments);
    }

    return sign;
  }();

  return JsSignatureProvider;
}();

var abi = {
  "version": "eosio::abi/1.0",
  "types": [{
    "new_type_name": "account_name",
    "type": "name"
  }, {
    "new_type_name": "action_name",
    "type": "name"
  }, {
    "new_type_name": "permission_name",
    "type": "name"
  }],
  "structs": [{
    "name": "permission_level",
    "base": "",
    "fields": [{
      "name": "actor",
      "type": "account_name"
    }, {
      "name": "permission",
      "type": "permission_name"
    }]
  }, {
    "name": "action",
    "base": "",
    "fields": [{
      "name": "account",
      "type": "account_name"
    }, {
      "name": "name",
      "type": "action_name"
    }, {
      "name": "authorization",
      "type": "permission_level[]"
    }, {
      "name": "data",
      "type": "bytes"
    }]
  }, {
    "name": "extension",
    "base": "",
    "fields": [{
      "name": "type",
      "type": "uint16"
    }, {
      "name": "data",
      "type": "bytes"
    }]
  }, {
    "name": "transaction_header",
    "base": "",
    "fields": [{
      "name": "expiration",
      "type": "time_point_sec"
    }, {
      "name": "ref_block_num",
      "type": "uint16"
    }, {
      "name": "ref_block_prefix",
      "type": "uint32"
    }, {
      "name": "max_net_usage_words",
      "type": "varuint32"
    }, {
      "name": "max_cpu_usage_ms",
      "type": "uint8"
    }, {
      "name": "delay_sec",
      "type": "varuint32"
    }]
  }, {
    "name": "transaction",
    "base": "transaction_header",
    "fields": [{
      "name": "context_free_actions",
      "type": "action[]"
    }, {
      "name": "actions",
      "type": "action[]"
    }, {
      "name": "transaction_extensions",
      "type": "extension[]"
    }]
  }],
  actions: [],
  tables: [],
  ricardian_clauses: [],
  error_messages: [],
  abi_extensions: []
};

var Api = /*#__PURE__*/function () {
  /**
   * @param args
   *    * `rpc`: Issues RPC calls
   *    * `authorityProvider`: Get public keys needed to meet authorities in a transaction
   *    * `abiProvider`: Supplies ABIs in raw form (binary)
   *    * `signatureProvider`: Signs transactions
   */
  function Api(args) {
    /** Holds information needed to serialize contract actions */
    this.contracts = new Map();
    /** Fetched abis */

    this.cachedAbis = new Map();
    this.rpc = args.rpc;
    this.authorityProvider = args.authorityProvider || args.rpc;
    this.abiProvider = args.abiProvider || args.rpc;

    if (args.signatureProvider) {
      this.signatureProvider = args.signatureProvider;
    }

    this.abiTypes = getTypesFromAbi(createAbiTypes());
    this.transactionTypes = getTypesFromAbi(createInitialTypes(), abi);
  }
  /** Decodes an abi as Uint8Array into json. */


  var _proto = Api.prototype;

  _proto.rawAbiToJson = function rawAbiToJson(rawAbi) {
    var buffer = new SerialBuffer({
      array: rawAbi
    });

    if (!supportedAbiVersion(buffer.getString())) {
      throw new Error('Unsupported abi version');
    }

    buffer.restartRead();
    return this.abiTypes.get('abi_def').deserialize(buffer);
  }
  /** Encodes a json abi as Uint8Array. */
  ;

  _proto.jsonToRawAbi = function jsonToRawAbi(jsonAbi) {
    var buffer = new SerialBuffer();
    this.abiTypes.get('abi_def').serialize(buffer, jsonAbi);

    if (!supportedAbiVersion(buffer.getString())) {
      throw new Error('Unsupported abi version');
    }

    return buffer.asUint8Array();
  }
  /** Get abi in both binary and structured forms. Fetch when needed. */
  ;

  _proto.getCachedAbi =
  /*#__PURE__*/
  function () {
    var _getCachedAbi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(accountName, reload) {
      var cachedAbi, rawAbi, abi;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (reload === void 0) {
                reload = false;
              }

              if (!(!reload && this.cachedAbis.get(accountName))) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return", this.cachedAbis.get(accountName));

            case 3:
              _context.prev = 3;
              _context.next = 6;
              return this.abiProvider.getRawAbi(accountName);

            case 6:
              rawAbi = _context.sent.abi;
              abi = this.rawAbiToJson(rawAbi);
              cachedAbi = {
                rawAbi: rawAbi,
                abi: abi
              };
              _context.next = 15;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](3);
              _context.t0.message = "fetching abi for " + accountName + ": " + _context.t0.message;
              throw _context.t0;

            case 15:
              if (cachedAbi) {
                _context.next = 17;
                break;
              }

              throw new Error("Missing abi for " + accountName);

            case 17:
              this.cachedAbis.set(accountName, cachedAbi);
              return _context.abrupt("return", cachedAbi);

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[3, 11]]);
    }));

    function getCachedAbi(_x, _x2) {
      return _getCachedAbi.apply(this, arguments);
    }

    return getCachedAbi;
  }()
  /** Get abi in structured form. Fetch when needed. */
  ;

  _proto.getAbi =
  /*#__PURE__*/
  function () {
    var _getAbi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(accountName, reload) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (reload === void 0) {
                reload = false;
              }

              _context2.next = 3;
              return this.getCachedAbi(accountName, reload);

            case 3:
              return _context2.abrupt("return", _context2.sent.abi);

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getAbi(_x3, _x4) {
      return _getAbi.apply(this, arguments);
    }

    return getAbi;
  }()
  /** Get abis needed by a transaction */
  ;

  _proto.getTransactionAbis =
  /*#__PURE__*/
  function () {
    var _getTransactionAbis = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(transaction, reload) {
      var _this = this;

      var actions, accounts, uniqueAccounts, actionPromises;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (reload === void 0) {
                reload = false;
              }

              actions = (transaction.context_free_actions || []).concat(transaction.actions);
              accounts = actions.map(function (action) {
                return action.account;
              });
              uniqueAccounts = new Set(accounts);
              actionPromises = Array.from(uniqueAccounts).map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(account) {
                  var _yield$_this$getCache, rawAbi;

                  return runtime_1.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return _this.getCachedAbi(account, reload);

                        case 2:
                          _yield$_this$getCache = _context3.sent;
                          rawAbi = _yield$_this$getCache.rawAbi;
                          return _context3.abrupt("return", {
                            accountName: account,
                            abi: rawAbi
                          });

                        case 5:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));

                return function (_x7) {
                  return _ref.apply(this, arguments);
                };
              }());
              return _context4.abrupt("return", Promise.all(actionPromises));

            case 6:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function getTransactionAbis(_x5, _x6) {
      return _getTransactionAbis.apply(this, arguments);
    }

    return getTransactionAbis;
  }()
  /** Get data needed to serialize actions in a contract */
  ;

  _proto.getContract =
  /*#__PURE__*/
  function () {
    var _getContract = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(accountName, reload) {
      var abi, types, actions, _iterator, _step, _step$value, name, type, result;

      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (reload === void 0) {
                reload = false;
              }

              if (!(!reload && this.contracts.get(accountName))) {
                _context5.next = 3;
                break;
              }

              return _context5.abrupt("return", this.contracts.get(accountName));

            case 3:
              _context5.next = 5;
              return this.getAbi(accountName, reload);

            case 5:
              abi = _context5.sent;
              types = getTypesFromAbi(createInitialTypes(), abi);
              actions = new Map();

              for (_iterator = _createForOfIteratorHelperLoose(abi.actions); !(_step = _iterator()).done;) {
                _step$value = _step.value, name = _step$value.name, type = _step$value.type;
                actions.set(name, getType(types, type));
              }

              result = {
                types: types,
                actions: actions
              };
              this.contracts.set(accountName, result);
              return _context5.abrupt("return", result);

            case 12:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function getContract(_x8, _x9) {
      return _getContract.apply(this, arguments);
    }

    return getContract;
  }()
  /** Convert `value` to binary form. `type` must be a built-in abi type or in `transaction.abi.json`. */
  ;

  _proto.serialize = function serialize(buffer, type, value) {
    this.transactionTypes.get(type).serialize(buffer, value);
  }
  /** Convert data in `buffer` to structured form. `type` must be a built-in abi type or in `transaction.abi.json`. */
  ;

  _proto.deserialize = function deserialize(buffer, type) {
    return this.transactionTypes.get(type).deserialize(buffer);
  }
  /** Convert a transaction to binary */
  ;

  _proto.serializeTransaction = function serializeTransaction(transaction) {
    var buffer = new SerialBuffer();
    this.serialize(buffer, 'transaction', Object.assign({
      max_net_usage_words: 0,
      max_cpu_usage_ms: 0,
      delay_sec: 0,
      context_free_actions: [],
      actions: [],
      transaction_extensions: []
    }, transaction));
    return buffer.asUint8Array();
  }
  /** Serialize context-free data */
  ;

  _proto.serializeContextFreeData = function serializeContextFreeData(contextFreeData) {
    if (!contextFreeData || !contextFreeData.length) {
      return undefined;
    }

    var buffer = new SerialBuffer();
    buffer.pushVaruint32(contextFreeData.length);

    for (var _iterator2 = _createForOfIteratorHelperLoose(contextFreeData), _step2; !(_step2 = _iterator2()).done;) {
      var data = _step2.value;
      buffer.pushBytes(data);
    }

    return buffer.asUint8Array();
  }
  /** Convert a transaction from binary. Leaves actions in hex. */
  ;

  _proto.deserializeTransaction = function deserializeTransaction(transaction) {
    var buffer = new SerialBuffer();
    buffer.pushArray(transaction);
    return this.deserialize(buffer, 'transaction');
  }
  /** Convert actions to hex */
  ;

  _proto.serializeActions =
  /*#__PURE__*/
  function () {
    var _serializeActions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(actions) {
      var _this2 = this;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return Promise.all(actions.map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(action) {
                  var account, name, authorization, data, contract;
                  return runtime_1.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          account = action.account, name = action.name, authorization = action.authorization, data = action.data;
                          _context6.next = 3;
                          return _this2.getContract(account);

                        case 3:
                          contract = _context6.sent;

                          if (!(typeof data !== 'object')) {
                            _context6.next = 6;
                            break;
                          }

                          return _context6.abrupt("return", action);

                        case 6:
                          return _context6.abrupt("return", serializeAction(contract, account, name, authorization, data));

                        case 7:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6);
                }));

                return function (_x11) {
                  return _ref2.apply(this, arguments);
                };
              }()));

            case 2:
              return _context7.abrupt("return", _context7.sent);

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    function serializeActions(_x10) {
      return _serializeActions.apply(this, arguments);
    }

    return serializeActions;
  }()
  /** Convert actions from hex */
  ;

  _proto.deserializeActions =
  /*#__PURE__*/
  function () {
    var _deserializeActions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(actions) {
      var _this3 = this;

      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return Promise.all(actions.map( /*#__PURE__*/function () {
                var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(_ref3) {
                  var account, name, authorization, data, contract;
                  return runtime_1.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          account = _ref3.account, name = _ref3.name, authorization = _ref3.authorization, data = _ref3.data;
                          _context8.next = 3;
                          return _this3.getContract(account);

                        case 3:
                          contract = _context8.sent;
                          return _context8.abrupt("return", deserializeAction(contract, account, name, authorization, data));

                        case 5:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8);
                }));

                return function (_x13) {
                  return _ref4.apply(this, arguments);
                };
              }()));

            case 2:
              return _context9.abrupt("return", _context9.sent);

            case 3:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));

    function deserializeActions(_x12) {
      return _deserializeActions.apply(this, arguments);
    }

    return deserializeActions;
  }();

  _proto.deserializeActionsSync = /*#__PURE__*/function () {
    var _deserializeActionsSync = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(actions) {
      var deserializedActions, _iterator3, _step3, _step3$value, account, name, authorization, data, contract;

      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              deserializedActions = [];
              _iterator3 = _createForOfIteratorHelperLoose(actions);

            case 2:
              if ((_step3 = _iterator3()).done) {
                _context10.next = 10;
                break;
              }

              _step3$value = _step3.value, account = _step3$value.account, name = _step3$value.name, authorization = _step3$value.authorization, data = _step3$value.data;
              _context10.next = 6;
              return this.getContract(account);

            case 6:
              contract = _context10.sent;
              deserializedActions.push(deserializeAction(contract, account, name, authorization, data));

            case 8:
              _context10.next = 2;
              break;

            case 10:
              return _context10.abrupt("return", deserializedActions);

            case 11:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function deserializeActionsSync(_x14) {
      return _deserializeActionsSync.apply(this, arguments);
    }

    return deserializeActionsSync;
  }()
  /** Convert a transaction from binary. Also deserializes actions. */
  ;

  _proto.deserializeTransactionWithActions =
  /*#__PURE__*/
  function () {
    var _deserializeTransactionWithActions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(transaction) {
      var deserializedTransaction, deserializedCFActions, deserializedActions;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (typeof transaction === 'string') {
                transaction = hexToUint8Array(transaction);
              }

              deserializedTransaction = this.deserializeTransaction(transaction);
              _context11.next = 4;
              return this.deserializeActionsSync(deserializedTransaction.context_free_actions);

            case 4:
              deserializedCFActions = _context11.sent;
              _context11.next = 7;
              return this.deserializeActionsSync(deserializedTransaction.actions);

            case 7:
              deserializedActions = _context11.sent;
              return _context11.abrupt("return", Object.assign({}, deserializedTransaction, {
                context_free_actions: deserializedCFActions,
                actions: deserializedActions
              }));

            case 9:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function deserializeTransactionWithActions(_x15) {
      return _deserializeTransactionWithActions.apply(this, arguments);
    }

    return deserializeTransactionWithActions;
  }()
  /** Deflate a serialized object */
  ;

  _proto.deflateSerializedArray = function deflateSerializedArray(serializedArray) {
    return deflate(serializedArray, {
      level: 9
    });
  }
  /** Inflate a compressed serialized object */
  ;

  _proto.inflateSerializedArray = function inflateSerializedArray(compressedSerializedArray) {
    return inflate(compressedSerializedArray);
  }
  /**
   * Create and optionally broadcast a transaction.
   *
   * Named Parameters:
   *    * `broadcast`: broadcast this transaction?
   *    * `sign`: sign this transaction?
   *    * `compression`: compress this transaction?
   *    * If both `blocksBehind` and `expireSeconds` are present,
   *      then fetch the block which is `blocksBehind` behind head block,
   *      use it as a reference for TAPoS, and expire the transaction
   *      `expireSeconds` after that block's time.
   *    * If both `useLastIrreversible` and `expireSeconds` are present,
   *      then fetch the last irreversible block, use it as a reference for TAPoS,
   *      and expire the transaction `expireSeconds` after that block's time.
   *
   * @returns node response if `broadcast`, `{signatures, serializedTransaction}` if `!broadcast`
   */
  ;

  _proto.transact =
  /*#__PURE__*/
  function () {
    var _transact = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(transaction, _temp) {
      var _ref5, _ref5$broadcast, broadcast, _ref5$sign, sign, compression, blocksBehind, useLastIrreversible, expireSeconds, requiredKeys, transactionHeader, info, abis, serializedTransaction, serializedContextFreeData, pushTransactionArgs, availableKeys;

      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _ref5 = _temp === void 0 ? {} : _temp, _ref5$broadcast = _ref5.broadcast, broadcast = _ref5$broadcast === void 0 ? true : _ref5$broadcast, _ref5$sign = _ref5.sign, sign = _ref5$sign === void 0 ? true : _ref5$sign, compression = _ref5.compression, blocksBehind = _ref5.blocksBehind, useLastIrreversible = _ref5.useLastIrreversible, expireSeconds = _ref5.expireSeconds, requiredKeys = _ref5.requiredKeys, transactionHeader = _ref5.transactionHeader;
              _context12.next = 3;
              return this.rpc.get_info();

            case 3:
              info = _context12.sent;

              if (transactionHeader) {
                _context12.next = 24;
                break;
              }

              if (!(typeof blocksBehind === 'number' && useLastIrreversible)) {
                _context12.next = 10;
                break;
              }

              throw new Error('Use either blocksBehind or useLastIrreversible');

            case 10:
              if (!(typeof blocksBehind !== 'number' && !useLastIrreversible)) {
                _context12.next = 14;
                break;
              }

              throw new Error('Must provide one blocksBehind or useLastIrreversible');

            case 14:
              if (expireSeconds) {
                _context12.next = 18;
                break;
              }

              throw new Error('Must provide expireSeconds');

            case 18:
              _context12.next = 20;
              return this.generateTapos(info, transaction, blocksBehind, useLastIrreversible, expireSeconds);

            case 20:
              transactionHeader = _context12.sent;

            case 22:
              if (this.hasRequiredTaposFields(transactionHeader)) {
                _context12.next = 24;
                break;
              }

              throw new Error('Required configuration or TAPOS fields are not present');

            case 24:
              _context12.next = 26;
              return this.getTransactionAbis(transaction);

            case 26:
              abis = _context12.sent;
              _context12.t0 = Object;
              _context12.t1 = {};
              _context12.t2 = transactionHeader;
              _context12.next = 32;
              return this.serializeActions(transaction.context_free_actions || []);

            case 32:
              _context12.t3 = _context12.sent;
              _context12.next = 35;
              return this.serializeActions(transaction.actions);

            case 35:
              _context12.t4 = _context12.sent;
              _context12.t5 = {
                context_free_actions: _context12.t3,
                actions: _context12.t4
              };
              transaction = _context12.t0.assign.call(_context12.t0, _context12.t1, _context12.t2, _context12.t5);
              serializedTransaction = this.serializeTransaction(transaction);
              serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);
              pushTransactionArgs = {
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData,
                signatures: []
              };

              if (!sign) {
                _context12.next = 54;
                break;
              }

              if (this.signatureProvider) {
                _context12.next = 44;
                break;
              }

              throw new Error('No signature provider available');

            case 44:
              if (requiredKeys) {
                _context12.next = 51;
                break;
              }

              _context12.next = 47;
              return this.signatureProvider.getAvailableKeys();

            case 47:
              availableKeys = _context12.sent;
              _context12.next = 50;
              return this.authorityProvider.getRequiredKeys({
                transaction: transaction,
                availableKeys: availableKeys
              });

            case 50:
              requiredKeys = _context12.sent;

            case 51:
              _context12.next = 53;
              return this.signatureProvider.sign({
                chainId: info.chain_id,
                requiredKeys: requiredKeys,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData,
                abis: abis
              });

            case 53:
              pushTransactionArgs = _context12.sent;

            case 54:
              if (!broadcast) {
                _context12.next = 58;
                break;
              }

              if (!compression) {
                _context12.next = 57;
                break;
              }

              return _context12.abrupt("return", this.pushCompressedSignedTransaction(pushTransactionArgs));

            case 57:
              return _context12.abrupt("return", this.pushSignedTransaction(pushTransactionArgs));

            case 58:
              return _context12.abrupt("return", Object.assign({}, pushTransactionArgs, {
                transactionHeader: transactionHeader //

              }));

            case 59:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function transact(_x16, _x17) {
      return _transact.apply(this, arguments);
    }

    return transact;
  }();

  _proto.transactWithDelay = /*#__PURE__*/function () {
    var _transactWithDelay = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(transaction, params, delay) {
      var wait, _wait, success;

      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _wait = function _wait3() {
                _wait = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(ms) {
                  return runtime_1.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          return _context13.abrupt("return", new Promise(function (resolve) {
                            setTimeout(resolve, ms);
                          }));

                        case 1:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13);
                }));
                return _wait.apply(this, arguments);
              };

              wait = function _wait2(_x21) {
                return _wait.apply(this, arguments);
              };

              if (params === void 0) {
                params = {};
              }

              _context14.next = 5;
              return this.transact(transaction, params);

            case 5:
              success = _context14.sent;
              _context14.next = 8;
              return wait(delay);

            case 8:
              return _context14.abrupt("return", success);

            case 9:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function transactWithDelay(_x18, _x19, _x20) {
      return _transactWithDelay.apply(this, arguments);
    }

    return transactWithDelay;
  }();

  _proto.query = /*#__PURE__*/function () {
    var _query2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(account, _short, _query, _ref6) {
      var sign, requiredKeys, _ref6$authorization, authorization, info, refBlock, queryBuffer, transaction, serializedTransaction, signatures, abis, availableKeys, signResponse, response, returnBuffer;

      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              sign = _ref6.sign, requiredKeys = _ref6.requiredKeys, _ref6$authorization = _ref6.authorization, authorization = _ref6$authorization === void 0 ? [] : _ref6$authorization;
              _context15.next = 3;
              return this.rpc.get_info();

            case 3:
              info = _context15.sent;
              _context15.next = 6;
              return this.tryRefBlockFromGetInfo(info);

            case 6:
              refBlock = _context15.sent;
              queryBuffer = new SerialBuffer();
              serializeQuery(queryBuffer, _query);
              transaction = Object.assign({}, transactionHeader(refBlock, 60 * 30), {
                context_free_actions: [],
                actions: [{
                  account: account,
                  name: 'queryit',
                  authorization: authorization,
                  data: arrayToHex(queryBuffer.asUint8Array())
                }]
              });
              serializedTransaction = this.serializeTransaction(transaction);
              signatures = [];

              if (!sign) {
                _context15.next = 29;
                break;
              }

              if (this.signatureProvider) {
                _context15.next = 15;
                break;
              }

              throw new Error('No signature provider available');

            case 15:
              _context15.next = 17;
              return this.getTransactionAbis(transaction);

            case 17:
              abis = _context15.sent;

              if (requiredKeys) {
                _context15.next = 25;
                break;
              }

              _context15.next = 21;
              return this.signatureProvider.getAvailableKeys();

            case 21:
              availableKeys = _context15.sent;
              _context15.next = 24;
              return this.authorityProvider.getRequiredKeys({
                transaction: transaction,
                availableKeys: availableKeys
              });

            case 24:
              requiredKeys = _context15.sent;

            case 25:
              _context15.next = 27;
              return this.signatureProvider.sign({
                chainId: info.chain_id,
                requiredKeys: requiredKeys,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: undefined,
                abis: abis
              });

            case 27:
              signResponse = _context15.sent;
              signatures = signResponse.signatures;

            case 29:
              _context15.next = 31;
              return this.rpc.send_transaction({
                signatures: signatures,
                compression: 0,
                serializedTransaction: serializedTransaction
              });

            case 31:
              response = _context15.sent;
              returnBuffer = new SerialBuffer({
                array: hexToUint8Array(response.processed.action_traces[0][1].return_value)
              });

              if (!_short) {
                _context15.next = 37;
                break;
              }

              return _context15.abrupt("return", deserializeAnyvarShort(returnBuffer));

            case 37:
              return _context15.abrupt("return", deserializeAnyvar(returnBuffer));

            case 38:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function query(_x22, _x23, _x24, _x25) {
      return _query2.apply(this, arguments);
    }

    return query;
  }()
  /** Broadcast a signed transaction */
  ;

  _proto.pushSignedTransaction =
  /*#__PURE__*/
  function () {
    var _pushSignedTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(_ref7) {
      var signatures, serializedTransaction, serializedContextFreeData;
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              signatures = _ref7.signatures, serializedTransaction = _ref7.serializedTransaction, serializedContextFreeData = _ref7.serializedContextFreeData;
              return _context16.abrupt("return", this.rpc.push_transaction({
                signatures: signatures,
                serializedTransaction: serializedTransaction,
                serializedContextFreeData: serializedContextFreeData
              }));

            case 2:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function pushSignedTransaction(_x26) {
      return _pushSignedTransaction.apply(this, arguments);
    }

    return pushSignedTransaction;
  }();

  _proto.pushCompressedSignedTransaction = /*#__PURE__*/function () {
    var _pushCompressedSignedTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(_ref8) {
      var signatures, serializedTransaction, serializedContextFreeData, compressedSerializedTransaction, compressedSerializedContextFreeData;
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              signatures = _ref8.signatures, serializedTransaction = _ref8.serializedTransaction, serializedContextFreeData = _ref8.serializedContextFreeData;
              compressedSerializedTransaction = this.deflateSerializedArray(serializedTransaction);
              compressedSerializedContextFreeData = this.deflateSerializedArray(serializedContextFreeData || new Uint8Array(0));
              return _context17.abrupt("return", this.rpc.push_transaction({
                signatures: signatures,
                compression: 1,
                serializedTransaction: compressedSerializedTransaction,
                serializedContextFreeData: compressedSerializedContextFreeData
              }));

            case 4:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function pushCompressedSignedTransaction(_x27) {
      return _pushCompressedSignedTransaction.apply(this, arguments);
    }

    return pushCompressedSignedTransaction;
  }();

  _proto.generateTapos = /*#__PURE__*/function () {
    var _generateTapos = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(info, transaction, blocksBehind, useLastIrreversible, expireSeconds) {
      var block, taposBlockNumber, refBlock;
      return runtime_1.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              if (blocksBehind === void 0) {
                blocksBehind = 3;
              }

              if (info) {
                _context18.next = 5;
                break;
              }

              _context18.next = 4;
              return this.rpc.get_info();

            case 4:
              info = _context18.sent;

            case 5:
              if (!useLastIrreversible) {
                _context18.next = 10;
                break;
              }

              _context18.next = 8;
              return this.tryRefBlockFromGetInfo(info);

            case 8:
              block = _context18.sent;
              return _context18.abrupt("return", Object.assign({}, transactionHeader(block, expireSeconds), transaction));

            case 10:
              taposBlockNumber = info.head_block_num - blocksBehind;

              if (!(taposBlockNumber <= info.last_irreversible_block_num)) {
                _context18.next = 17;
                break;
              }

              _context18.next = 14;
              return this.tryGetBlockInfo(taposBlockNumber);

            case 14:
              _context18.t0 = _context18.sent;
              _context18.next = 20;
              break;

            case 17:
              _context18.next = 19;
              return this.tryGetBlockHeaderState(taposBlockNumber);

            case 19:
              _context18.t0 = _context18.sent;

            case 20:
              refBlock = _context18.t0;
              return _context18.abrupt("return", Object.assign({}, transactionHeader(refBlock, expireSeconds), transaction));

            case 22:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this);
    }));

    function generateTapos(_x28, _x29, _x30, _x31, _x32) {
      return _generateTapos.apply(this, arguments);
    }

    return generateTapos;
  }() // eventually break out into TransactionValidator class
  ;

  _proto.hasRequiredTaposFields = function hasRequiredTaposFields(_ref9) {
    var expiration = _ref9.expiration,
        ref_block_num = _ref9.ref_block_num,
        ref_block_prefix = _ref9.ref_block_prefix;
    return !!(expiration && typeof ref_block_num === 'number' && typeof ref_block_prefix === 'number');
  };

  _proto.tryGetBlockHeaderState = /*#__PURE__*/function () {
    var _tryGetBlockHeaderState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(taposBlockNumber) {
      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              _context19.prev = 0;
              _context19.next = 3;
              return this.rpc.get_block_header_state(taposBlockNumber);

            case 3:
              return _context19.abrupt("return", _context19.sent);

            case 6:
              _context19.prev = 6;
              _context19.t0 = _context19["catch"](0);
              _context19.next = 10;
              return this.tryGetBlockInfo(taposBlockNumber);

            case 10:
              return _context19.abrupt("return", _context19.sent);

            case 11:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this, [[0, 6]]);
    }));

    function tryGetBlockHeaderState(_x33) {
      return _tryGetBlockHeaderState.apply(this, arguments);
    }

    return tryGetBlockHeaderState;
  }();

  _proto.tryGetBlockInfo = /*#__PURE__*/function () {
    var _tryGetBlockInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(blockNumber) {
      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              _context20.prev = 0;
              _context20.next = 3;
              return this.rpc.get_block_info(blockNumber);

            case 3:
              return _context20.abrupt("return", _context20.sent);

            case 6:
              _context20.prev = 6;
              _context20.t0 = _context20["catch"](0);
              _context20.next = 10;
              return this.rpc.get_block(blockNumber);

            case 10:
              return _context20.abrupt("return", _context20.sent);

            case 11:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this, [[0, 6]]);
    }));

    function tryGetBlockInfo(_x34) {
      return _tryGetBlockInfo.apply(this, arguments);
    }

    return tryGetBlockInfo;
  }();

  _proto.tryRefBlockFromGetInfo = /*#__PURE__*/function () {
    var _tryRefBlockFromGetInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(info) {
      var block;
      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              if (!(info.hasOwnProperty('last_irreversible_block_id') && info.hasOwnProperty('last_irreversible_block_num') && info.hasOwnProperty('last_irreversible_block_time'))) {
                _context21.next = 4;
                break;
              }

              return _context21.abrupt("return", {
                block_num: info.last_irreversible_block_num,
                id: info.last_irreversible_block_id,
                timestamp: info.last_irreversible_block_time
              });

            case 4:
              _context21.next = 6;
              return this.tryGetBlockInfo(info.last_irreversible_block_num);

            case 6:
              block = _context21.sent;
              return _context21.abrupt("return", {
                block_num: block.block_num,
                id: block.id,
                timestamp: block.timestamp
              });

            case 8:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function tryRefBlockFromGetInfo(_x35) {
      return _tryRefBlockFromGetInfo.apply(this, arguments);
    }

    return tryRefBlockFromGetInfo;
  }();

  _proto["with"] = function _with(accountName) {
    return new ActionBuilder(this, accountName);
  };

  _proto.buildTransaction = function buildTransaction(cb) {
    var tx = new TransactionBuilder(this);

    if (cb) {
      return cb(tx);
    }

    return tx;
  };

  _proto.getAccountKeys = /*#__PURE__*/function () {
    var _getAccountKeys = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(actor, permission) {
      var _yield$this$rpc$get_a, permissions, relevantPermission;

      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              _context22.prev = 0;
              _context22.next = 3;
              return this.rpc.get_account(actor);

            case 3:
              _yield$this$rpc$get_a = _context22.sent;
              permissions = _yield$this$rpc$get_a.permissions;
              relevantPermission = permissions.find(function (_ref10) {
                var perm_name = _ref10.perm_name;
                return perm_name === permission;
              });

              if (!relevantPermission) {
                _context22.next = 8;
                break;
              }

              return _context22.abrupt("return", relevantPermission.required_auth.keys.map(function (_ref11) {
                var key = _ref11.key;
                return PublicKey.fromString(key).toString();
              }));

            case 8:
              _context22.next = 13;
              break;

            case 10:
              _context22.prev = 10;
              _context22.t0 = _context22["catch"](0);
              console.log(_context22.t0);

            case 13:
              return _context22.abrupt("return", []);

            case 14:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, this, [[0, 10]]);
    }));

    function getAccountKeys(_x36, _x37) {
      return _getAccountKeys.apply(this, arguments);
    }

    return getAccountKeys;
  }();

  _proto.checkIfKeysMatchTransaction = /*#__PURE__*/function () {
    var _checkIfKeysMatchTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23(_ref12) {
      var actor, permission, transaction, signatures, chainId, info, keys, serializedTransaction, serializedContextFreeData, digest, verified;
      return runtime_1.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              actor = _ref12.actor, permission = _ref12.permission, transaction = _ref12.transaction, signatures = _ref12.signatures, chainId = _ref12.chainId;

              if (chainId) {
                _context23.next = 6;
                break;
              }

              _context23.next = 4;
              return this.rpc.get_info();

            case 4:
              info = _context23.sent;
              chainId = info.chain_id;

            case 6:
              _context23.next = 8;
              return this.getAccountKeys(actor, permission);

            case 8:
              keys = _context23.sent;
              _context23.next = 11;
              return this.serializeActions(transaction.context_free_actions || []);

            case 11:
              transaction.context_free_actions = _context23.sent;
              _context23.next = 14;
              return this.serializeActions(transaction.actions);

            case 14:
              transaction.actions = _context23.sent;
              serializedTransaction = this.serializeTransaction(transaction);
              serializedContextFreeData = this.serializeContextFreeData(transaction.context_free_data);
              digest = digestFromSerializedData(chainId, serializedTransaction, serializedContextFreeData);
              verified = keys.some(function (key) {
                return Signature.fromString(signatures[0]).verify(digest, PublicKey.fromString(key), false);
              });
              return _context23.abrupt("return", verified);

            case 20:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23, this);
    }));

    function checkIfKeysMatchTransaction(_x38) {
      return _checkIfKeysMatchTransaction.apply(this, arguments);
    }

    return checkIfKeysMatchTransaction;
  }();

  return Api;
}(); // Api

var TransactionBuilder = /*#__PURE__*/function () {
  function TransactionBuilder(api) {
    this.actions = [];
    this.contextFreeGroups = [];
    this.api = api;
  }

  var _proto2 = TransactionBuilder.prototype;

  _proto2["with"] = function _with(accountName) {
    var actionBuilder = new ActionBuilder(this.api, accountName);
    this.actions.push(actionBuilder);
    return actionBuilder;
  };

  _proto2.associateContextFree = function associateContextFree(contextFreeGroup) {
    this.contextFreeGroups.push(contextFreeGroup);
    return this;
  };

  _proto2.send = /*#__PURE__*/function () {
    var _send = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee25(config) {
      var contextFreeDataSet, contextFreeActions, actions;
      return runtime_1.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              contextFreeDataSet = [];
              contextFreeActions = [];
              actions = this.actions.map(function (actionBuilder) {
                return actionBuilder.serializedData;
              });
              _context25.next = 5;
              return Promise.all(this.contextFreeGroups.map( /*#__PURE__*/function () {
                var _ref13 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee24(contextFreeCallback) {
                  var _contextFreeCallback, action, contextFreeAction, contextFreeData;

                  return runtime_1.wrap(function _callee24$(_context24) {
                    while (1) {
                      switch (_context24.prev = _context24.next) {
                        case 0:
                          _contextFreeCallback = contextFreeCallback({
                            cfd: contextFreeDataSet.length,
                            cfa: contextFreeActions.length
                          }), action = _contextFreeCallback.action, contextFreeAction = _contextFreeCallback.contextFreeAction, contextFreeData = _contextFreeCallback.contextFreeData;

                          if (action) {
                            actions.push(action);
                          }

                          if (contextFreeAction) {
                            contextFreeActions.push(contextFreeAction);
                          }

                          if (contextFreeData) {
                            contextFreeDataSet.push(contextFreeData);
                          }

                        case 4:
                        case "end":
                          return _context24.stop();
                      }
                    }
                  }, _callee24);
                }));

                return function (_x40) {
                  return _ref13.apply(this, arguments);
                };
              }()));

            case 5:
              this.contextFreeGroups = [];
              this.actions = [];
              _context25.next = 9;
              return this.api.transact({
                context_free_data: contextFreeDataSet,
                context_free_actions: contextFreeActions,
                actions: actions
              }, config);

            case 9:
              return _context25.abrupt("return", _context25.sent);

            case 10:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25, this);
    }));

    function send(_x39) {
      return _send.apply(this, arguments);
    }

    return send;
  }();

  return TransactionBuilder;
}();
var ActionBuilder = /*#__PURE__*/function () {
  function ActionBuilder(api, accountName) {
    this.api = api;
    this.accountName = accountName;
  }

  var _proto3 = ActionBuilder.prototype;

  _proto3.as = function as(actorName) {
    if (actorName === void 0) {
      actorName = [];
    }

    var authorization = [];

    if (actorName && typeof actorName === 'string') {
      authorization = [{
        actor: actorName,
        permission: 'active'
      }];
    } else {
      authorization = actorName;
    }

    return new ActionSerializer(this, this.api, this.accountName, authorization);
  };

  return ActionBuilder;
}();

var ActionSerializer = function ActionSerializer(parent, api, accountName, authorization) {
  var _this4 = this;

  var jsonAbi = api.cachedAbis.get(accountName);

  if (!jsonAbi) {
    throw new Error('ABI must be cached before using ActionBuilder, run api.getAbi()');
  }

  var types = getTypesFromAbi(createInitialTypes(), jsonAbi.abi);
  var actions = new Map();

  for (var _iterator4 = _createForOfIteratorHelperLoose(jsonAbi.abi.actions), _step4; !(_step4 = _iterator4()).done;) {
    var _step4$value = _step4.value,
        name = _step4$value.name,
        type = _step4$value.type;
    actions.set(name, getType(types, type));
  }

  actions.forEach(function (type, name) {
    var _Object$assign;

    Object.assign(_this4, (_Object$assign = {}, _Object$assign[name] = function () {
      var data = {};

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args.forEach(function (arg, index) {
        var field = type.fields[index];
        data[field.name] = arg;
      });
      var serializedData = serializeAction({
        types: types,
        actions: actions
      }, accountName, name, authorization, data);
      parent.serializedData = serializedData;
      return serializedData;
    }, _Object$assign));
  });
};

/**
 * @module Javascript-API
 */

var ApiInterfaces = {
  __proto__: null
};

/** Raw call to `/v1/chain/get_account` */

function get_account(_x) {
  return _get_account.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_block_header_state` */

function _get_account() {
  _get_account = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(accountName) {
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.post('/v1/chain/get_account', {
              account_name: accountName
            });

          case 2:
            return _context.abrupt("return", _context.sent);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _get_account.apply(this, arguments);
}

function get_block_header_state(_x2) {
  return _get_block_header_state.apply(this, arguments);
}

function _get_block_header_state() {
  _get_block_header_state = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(blockNumOrId) {
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.post('/v1/chain/get_block_header_state', {
              block_num_or_id: blockNumOrId
            });

          case 2:
            return _context2.abrupt("return", _context2.sent);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _get_block_header_state.apply(this, arguments);
}

function get_block_info(_x3) {
  return _get_block_info.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_block` */

function _get_block_info() {
  _get_block_info = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(blockNum) {
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this.post('/v1/chain/get_block_info', {
              block_num: blockNum
            });

          case 2:
            return _context3.abrupt("return", _context3.sent);

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _get_block_info.apply(this, arguments);
}

function get_block(_x4) {
  return _get_block.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_currency_balance` */

function _get_block() {
  _get_block = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(blockNumOrId) {
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.post('/v1/chain/get_block', {
              block_num_or_id: blockNumOrId
            });

          case 2:
            return _context4.abrupt("return", _context4.sent);

          case 3:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _get_block.apply(this, arguments);
}

function get_currency_balance(_x5, _x6, _x7) {
  return _get_currency_balance.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_currency_stats` */

function _get_currency_balance() {
  _get_currency_balance = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(code, account, symbol) {
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (symbol === void 0) {
              symbol = null;
            }

            _context5.next = 3;
            return this.post('/v1/chain/get_currency_balance', {
              code: code,
              account: account,
              symbol: symbol
            });

          case 3:
            return _context5.abrupt("return", _context5.sent);

          case 4:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _get_currency_balance.apply(this, arguments);
}

function get_currency_stats(_x8, _x9) {
  return _get_currency_stats.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_info` */

function _get_currency_stats() {
  _get_currency_stats = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(code, symbol) {
    return runtime_1.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.post('/v1/chain/get_currency_stats', {
              code: code,
              symbol: symbol
            });

          case 2:
            return _context6.abrupt("return", _context6.sent);

          case 3:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, this);
  }));
  return _get_currency_stats.apply(this, arguments);
}

function get_info() {
  return _get_info.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_producer_schedule` */

function _get_info() {
  _get_info = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7() {
    return runtime_1.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return this.post('/v1/chain/get_info', {});

          case 2:
            return _context7.abrupt("return", _context7.sent);

          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _get_info.apply(this, arguments);
}

function get_producer_schedule() {
  return _get_producer_schedule.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_producers` */

function _get_producer_schedule() {
  _get_producer_schedule = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8() {
    return runtime_1.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return this.post('/v1/chain/get_producer_schedule', {});

          case 2:
            return _context8.abrupt("return", _context8.sent);

          case 3:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));
  return _get_producer_schedule.apply(this, arguments);
}

function get_producers(_x10, _x11, _x12) {
  return _get_producers.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_scheduled_transactions` */

function _get_producers() {
  _get_producers = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(json, lowerBound, limit) {
    return runtime_1.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (json === void 0) {
              json = true;
            }

            if (lowerBound === void 0) {
              lowerBound = '';
            }

            if (limit === void 0) {
              limit = 50;
            }

            _context9.next = 5;
            return this.post('/v1/chain/get_producers', {
              json: json,
              lower_bound: lowerBound,
              limit: limit
            });

          case 5:
            return _context9.abrupt("return", _context9.sent);

          case 6:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9, this);
  }));
  return _get_producers.apply(this, arguments);
}

function get_scheduled_transactions(_x13, _x14, _x15) {
  return _get_scheduled_transactions.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_activated_protocol_features` */

function _get_scheduled_transactions() {
  _get_scheduled_transactions = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(json, lowerBound, limit) {
    return runtime_1.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            if (json === void 0) {
              json = true;
            }

            if (lowerBound === void 0) {
              lowerBound = '';
            }

            if (limit === void 0) {
              limit = 50;
            }

            _context10.next = 5;
            return this.post('/v1/chain/get_scheduled_transactions', {
              json: json,
              lower_bound: lowerBound,
              limit: limit
            });

          case 5:
            return _context10.abrupt("return", _context10.sent);

          case 6:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, this);
  }));
  return _get_scheduled_transactions.apply(this, arguments);
}

function get_activated_protocol_features(_x16) {
  return _get_activated_protocol_features.apply(this, arguments);
}
/** Get subset of `availableKeys` needed to meet authorities in `transaction`. Implements `AuthorityProvider` */

function _get_activated_protocol_features() {
  _get_activated_protocol_features = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(limit) {
    return runtime_1.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            if (limit === void 0) {
              limit = 100;
            }

            _context11.next = 3;
            return this.post('/v1/chain/get_activated_protocol_features', {
              limit: limit
            });

          case 3:
            return _context11.abrupt("return", _context11.sent);

          case 4:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11, this);
  }));
  return _get_activated_protocol_features.apply(this, arguments);
}

function getRequiredKeys(_x17) {
  return _getRequiredKeys.apply(this, arguments);
}

function _getRequiredKeys() {
  _getRequiredKeys = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(args) {
    var requiredKeys;
    return runtime_1.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return this.post('/v1/chain/get_required_keys', {
              transaction: args.transaction,
              available_keys: args.availableKeys
            });

          case 2:
            requiredKeys = _context12.sent;
            return _context12.abrupt("return", convertLegacyPublicKeys(requiredKeys.required_keys));

          case 4:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12, this);
  }));
  return _getRequiredKeys.apply(this, arguments);
}

/** Raw call to `/v1/history/get_actions` */
function history_get_actions(_x, _x2, _x3) {
  return _history_get_actions.apply(this, arguments);
}
/** Raw call to `/v1/history/get_transaction` */

function _history_get_actions() {
  _history_get_actions = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(accountName, pos, offset) {
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (pos === void 0) {
              pos = null;
            }

            if (offset === void 0) {
              offset = null;
            }

            _context.next = 4;
            return this.post('/v1/history/get_actions', {
              account_name: accountName,
              pos: pos,
              offset: offset
            });

          case 4:
            return _context.abrupt("return", _context.sent);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _history_get_actions.apply(this, arguments);
}

function history_get_transaction(_x4, _x5) {
  return _history_get_transaction.apply(this, arguments);
}
/** Raw call to `/v1/history/get_key_accounts` */

function _history_get_transaction() {
  _history_get_transaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(id, blockNumHint) {
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (blockNumHint === void 0) {
              blockNumHint = null;
            }

            _context2.next = 3;
            return this.post('/v1/history/get_transaction', {
              id: id,
              block_num_hint: blockNumHint
            });

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _history_get_transaction.apply(this, arguments);
}

function history_get_key_accounts(_x6) {
  return _history_get_key_accounts.apply(this, arguments);
}
/** Raw call to `/v1/history/get_controlled_accounts` */

function _history_get_key_accounts() {
  _history_get_key_accounts = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(publicKey) {
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this.post('/v1/history/get_key_accounts', {
              public_key: publicKey
            });

          case 2:
            return _context3.abrupt("return", _context3.sent);

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _history_get_key_accounts.apply(this, arguments);
}

function history_get_controlled_accounts(_x7) {
  return _history_get_controlled_accounts.apply(this, arguments);
}

function _history_get_controlled_accounts() {
  _history_get_controlled_accounts = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(controllingAccount) {
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.post('/v1/history/get_controlled_accounts', {
              controlling_account: controllingAccount
            });

          case 2:
            return _context4.abrupt("return", _context4.sent);

          case 3:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _history_get_controlled_accounts.apply(this, arguments);
}

/** Raw call to `/v1/db_size/get` */
function db_size_get() {
  return _db_size_get.apply(this, arguments);
}

function _db_size_get() {
  _db_size_get = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.post('/v1/db_size/get', {});

          case 2:
            return _context.abrupt("return", _context.sent);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _db_size_get.apply(this, arguments);
}

/**
 * @module RPC-API-Methods
 * copyright defined in eosjs/LICENSE.txt
 */
var KycStatus;

(function (KycStatus) {
  KycStatus["FAILED"] = "FAILED";
  KycStatus["UNSUBMITTED"] = "UNSUBMITTED";
  KycStatus["PENDING"] = "PENDING";
  KycStatus["PASSED"] = "PASSED";
})(KycStatus || (KycStatus = {}));

var RpcInterfaces = {
  __proto__: null,
  get KycStatus () { return KycStatus; }
};

var countryOptions = [{
  key: 'AF',
  value: 'AF',
  flag: 'af',
  text: 'Afghanistan'
}, {
  key: 'AX',
  value: 'AX',
  flag: 'ax',
  text: 'Aland Islands'
}, {
  key: 'AL',
  value: 'AL',
  flag: 'al',
  text: 'Albania'
}, {
  key: 'DZ',
  value: 'DZ',
  flag: 'dz',
  text: 'Algeria'
}, {
  key: 'AS',
  value: 'AS',
  flag: 'as',
  text: 'American Samoa'
}, {
  key: 'AD',
  value: 'AD',
  flag: 'ad',
  text: 'Andorra'
}, {
  key: 'AO',
  value: 'AO',
  flag: 'ao',
  text: 'Angola'
}, {
  key: 'AI',
  value: 'AI',
  flag: 'ai',
  text: 'Anguilla'
}, {
  key: 'AG',
  value: 'AG',
  flag: 'ag',
  text: 'Antigua'
}, {
  key: 'AR',
  value: 'AR',
  flag: 'ar',
  text: 'Argentina'
}, {
  key: 'AM',
  value: 'AM',
  flag: 'am',
  text: 'Armenia'
}, {
  key: 'AW',
  value: 'AW',
  flag: 'aw',
  text: 'Aruba'
}, {
  key: 'AU',
  value: 'AU',
  flag: 'au',
  text: 'Australia'
}, {
  key: 'AT',
  value: 'AT',
  flag: 'at',
  text: 'Austria'
}, {
  key: 'AZ',
  value: 'AZ',
  flag: 'az',
  text: 'Azerbaijan'
}, {
  key: 'BS',
  value: 'BS',
  flag: 'bs',
  text: 'Bahamas'
}, {
  key: 'BH',
  value: 'BH',
  flag: 'bh',
  text: 'Bahrain'
}, {
  key: 'BD',
  value: 'BD',
  flag: 'bd',
  text: 'Bangladesh'
}, {
  key: 'BB',
  value: 'BB',
  flag: 'bb',
  text: 'Barbados'
}, {
  key: 'BY',
  value: 'BY',
  flag: 'by',
  text: 'Belarus'
}, {
  key: 'BE',
  value: 'BE',
  flag: 'be',
  text: 'Belgium'
}, {
  key: 'BZ',
  value: 'BZ',
  flag: 'bz',
  text: 'Belize'
}, {
  key: 'BJ',
  value: 'BJ',
  flag: 'bj',
  text: 'Benin'
}, {
  key: 'BM',
  value: 'BM',
  flag: 'bm',
  text: 'Bermuda'
}, {
  key: 'BT',
  value: 'BT',
  flag: 'bt',
  text: 'Bhutan'
}, {
  key: 'BO',
  value: 'BO',
  flag: 'bo',
  text: 'Bolivia'
}, {
  key: 'BA',
  value: 'BA',
  flag: 'ba',
  text: 'Bosnia'
}, {
  key: 'BW',
  value: 'BW',
  flag: 'bw',
  text: 'Botswana'
}, {
  key: 'BV',
  value: 'BV',
  flag: 'bv',
  text: 'Bouvet Island'
}, {
  key: 'BR',
  value: 'BR',
  flag: 'br',
  text: 'Brazil'
}, {
  key: 'VG',
  value: 'VG',
  flag: 'vg',
  text: 'British Virgin Islands'
}, {
  key: 'BN',
  value: 'BN',
  flag: 'bn',
  text: 'Brunei'
}, {
  key: 'BG',
  value: 'BG',
  flag: 'bg',
  text: 'Bulgaria'
}, {
  key: 'BF',
  value: 'BF',
  flag: 'bf',
  text: 'Burkina Faso'
}, {
  key: 'BI',
  value: 'BI',
  flag: 'bi',
  text: 'Burundi'
}, {
  key: 'TC',
  value: 'TC',
  flag: 'tc',
  text: 'Caicos Islands'
}, {
  key: 'KH',
  value: 'KH',
  flag: 'kh',
  text: 'Cambodia'
}, {
  key: 'CM',
  value: 'CM',
  flag: 'cm',
  text: 'Cameroon'
}, {
  key: 'CA',
  value: 'CA',
  flag: 'ca',
  text: 'Canada'
}, {
  key: 'CV',
  value: 'CV',
  flag: 'cv',
  text: 'Cape Verde'
}, {
  key: 'KY',
  value: 'KY',
  flag: 'ky',
  text: 'Cayman Islands'
}, {
  key: 'CF',
  value: 'CF',
  flag: 'cf',
  text: 'Central African Republic'
}, {
  key: 'TD',
  value: 'TD',
  flag: 'td',
  text: 'Chad'
}, {
  key: 'CL',
  value: 'CL',
  flag: 'cl',
  text: 'Chile'
}, {
  key: 'CN',
  value: 'CN',
  flag: 'cn',
  text: 'China'
}, {
  key: 'CX',
  value: 'CX',
  flag: 'cx',
  text: 'Christmas Island'
}, {
  key: 'CC',
  value: 'CC',
  flag: 'cc',
  text: 'Cocos Islands'
}, {
  key: 'CO',
  value: 'CO',
  flag: 'co',
  text: 'Colombia'
}, {
  key: 'KM',
  value: 'KM',
  flag: 'km',
  text: 'Comoros'
}, {
  key: 'CG',
  value: 'CG',
  flag: 'cg',
  text: 'Congo Brazzaville'
}, {
  key: 'CD',
  value: 'CD',
  flag: 'cd',
  text: 'Congo'
}, {
  key: 'CK',
  value: 'CK',
  flag: 'ck',
  text: 'Cook Islands'
}, {
  key: 'CR',
  value: 'CR',
  flag: 'cr',
  text: 'Costa Rica'
}, {
  key: 'CI',
  value: 'CI',
  flag: 'ci',
  text: 'Cote Divoire'
}, {
  key: 'HR',
  value: 'HR',
  flag: 'hr',
  text: 'Croatia'
}, {
  key: 'CU',
  value: 'CU',
  flag: 'cu',
  text: 'Cuba'
}, {
  key: 'CY',
  value: 'CY',
  flag: 'cy',
  text: 'Cyprus'
}, {
  key: 'CZ',
  value: 'CZ',
  flag: 'cz',
  text: 'Czech Republic'
}, {
  key: 'DK',
  value: 'DK',
  flag: 'dk',
  text: 'Denmark'
}, {
  key: 'DJ',
  value: 'DJ',
  flag: 'dj',
  text: 'Djibouti'
}, {
  key: 'DM',
  value: 'DM',
  flag: 'dm',
  text: 'Dominica'
}, {
  key: 'DO',
  value: 'DO',
  flag: 'do',
  text: 'Dominican Republic'
}, {
  key: 'EC',
  value: 'EC',
  flag: 'ec',
  text: 'Ecuador'
}, {
  key: 'EG',
  value: 'EG',
  flag: 'eg',
  text: 'Egypt'
}, {
  key: 'SV',
  value: 'SV',
  flag: 'sv',
  text: 'El Salvador'
}, {
  key: 'GB',
  value: 'GB',
  flag: 'gb',
  text: 'England'
}, {
  key: 'GQ',
  value: 'GQ',
  flag: 'gq',
  text: 'Equatorial Guinea'
}, {
  key: 'ER',
  value: 'ER',
  flag: 'er',
  text: 'Eritrea'
}, {
  key: 'EE',
  value: 'EE',
  flag: 'ee',
  text: 'Estonia'
}, {
  key: 'ET',
  value: 'ET',
  flag: 'et',
  text: 'Ethiopia'
}, {
  key: 'EU',
  value: 'EU',
  flag: 'eu',
  text: 'European Union'
}, {
  key: 'FK',
  value: 'FK',
  flag: 'fk',
  text: 'Falkland Islands'
}, {
  key: 'FO',
  value: 'FO',
  flag: 'fo',
  text: 'Faroe Islands'
}, {
  key: 'FJ',
  value: 'FJ',
  flag: 'fj',
  text: 'Fiji'
}, {
  key: 'FI',
  value: 'FI',
  flag: 'fi',
  text: 'Finland'
}, {
  key: 'FR',
  value: 'FR',
  flag: 'fr',
  text: 'France'
}, {
  key: 'GF',
  value: 'GF',
  flag: 'gf',
  text: 'French Guiana'
}, {
  key: 'PF',
  value: 'PF',
  flag: 'pf',
  text: 'French Polynesia'
}, {
  key: 'TF',
  value: 'TF',
  flag: 'tf',
  text: 'French Territories'
}, {
  key: 'GA',
  value: 'GA',
  flag: 'ga',
  text: 'Gabon'
}, {
  key: 'GM',
  value: 'GM',
  flag: 'gm',
  text: 'Gambia'
}, {
  key: 'GE',
  value: 'GE',
  flag: 'ge',
  text: 'Georgia'
}, {
  key: 'DE',
  value: 'DE',
  flag: 'de',
  text: 'Germany'
}, {
  key: 'GH',
  value: 'GH',
  flag: 'gh',
  text: 'Ghana'
}, {
  key: 'GI',
  value: 'GI',
  flag: 'gi',
  text: 'Gibraltar'
}, {
  key: 'GR',
  value: 'GR',
  flag: 'gr',
  text: 'Greece'
}, {
  key: 'GL',
  value: 'GL',
  flag: 'gl',
  text: 'Greenland'
}, {
  key: 'GD',
  value: 'GD',
  flag: 'gd',
  text: 'Grenada'
}, {
  key: 'GP',
  value: 'GP',
  flag: 'gp',
  text: 'Guadeloupe'
}, {
  key: 'GU',
  value: 'GU',
  flag: 'gu',
  text: 'Guam'
}, {
  key: 'GT',
  value: 'GT',
  flag: 'gt',
  text: 'Guatemala'
}, {
  key: 'GW',
  value: 'GW',
  flag: 'gw',
  text: 'Guinea-Bissau'
}, {
  key: 'GN',
  value: 'GN',
  flag: 'gn',
  text: 'Guinea'
}, {
  key: 'GY',
  value: 'GY',
  flag: 'gy',
  text: 'Guyana'
}, {
  key: 'HT',
  value: 'HT',
  flag: 'ht',
  text: 'Haiti'
}, {
  key: 'HM',
  value: 'HM',
  flag: 'hm',
  text: 'Heard Island'
}, {
  key: 'HN',
  value: 'HN',
  flag: 'hn',
  text: 'Honduras'
}, {
  key: 'HK',
  value: 'HK',
  flag: 'hk',
  text: 'Hong Kong'
}, {
  key: 'HU',
  value: 'HU',
  flag: 'hu',
  text: 'Hungary'
}, {
  key: 'IS',
  value: 'IS',
  flag: 'is',
  text: 'Iceland'
}, {
  key: 'IN',
  value: 'IN',
  flag: 'in',
  text: 'India'
}, {
  key: 'IO',
  value: 'IO',
  flag: 'io',
  text: 'Indian Ocean Territory'
}, {
  key: 'ID',
  value: 'ID',
  flag: 'id',
  text: 'Indonesia'
}, {
  key: 'IR',
  value: 'IR',
  flag: 'ir',
  text: 'Iran'
}, {
  key: 'IQ',
  value: 'IQ',
  flag: 'iq',
  text: 'Iraq'
}, {
  key: 'IE',
  value: 'IE',
  flag: 'ie',
  text: 'Ireland'
}, {
  key: 'IL',
  value: 'IL',
  flag: 'il',
  text: 'Israel'
}, {
  key: 'IT',
  value: 'IT',
  flag: 'it',
  text: 'Italy'
}, {
  key: 'JM',
  value: 'JM',
  flag: 'jm',
  text: 'Jamaica'
}, {
  key: 'JP',
  value: 'JP',
  flag: 'jp',
  text: 'Japan'
}, {
  key: 'JO',
  value: 'JO',
  flag: 'jo',
  text: 'Jordan'
}, {
  key: 'KZ',
  value: 'KZ',
  flag: 'kz',
  text: 'Kazakhstan'
}, {
  key: 'KE',
  value: 'KE',
  flag: 'ke',
  text: 'Kenya'
}, {
  key: 'KI',
  value: 'KI',
  flag: 'ki',
  text: 'Kiribati'
}, {
  key: 'KW',
  value: 'KW',
  flag: 'kw',
  text: 'Kuwait'
}, {
  key: 'KG',
  value: 'KG',
  flag: 'kg',
  text: 'Kyrgyzstan'
}, {
  key: 'LA',
  value: 'LA',
  flag: 'la',
  text: 'Laos'
}, {
  key: 'LV',
  value: 'LV',
  flag: 'lv',
  text: 'Latvia'
}, {
  key: 'LB',
  value: 'LB',
  flag: 'lb',
  text: 'Lebanon'
}, {
  key: 'LS',
  value: 'LS',
  flag: 'ls',
  text: 'Lesotho'
}, {
  key: 'LR',
  value: 'LR',
  flag: 'lr',
  text: 'Liberia'
}, {
  key: 'LY',
  value: 'LY',
  flag: 'ly',
  text: 'Libya'
}, {
  key: 'LI',
  value: 'LI',
  flag: 'li',
  text: 'Liechtenstein'
}, {
  key: 'LT',
  value: 'LT',
  flag: 'lt',
  text: 'Lithuania'
}, {
  key: 'LU',
  value: 'LU',
  flag: 'lu',
  text: 'Luxembourg'
}, {
  key: 'MO',
  value: 'MO',
  flag: 'mo',
  text: 'Macau'
}, {
  key: 'MK',
  value: 'MK',
  flag: 'mk',
  text: 'Macedonia'
}, {
  key: 'MG',
  value: 'MG',
  flag: 'mg',
  text: 'Madagascar'
}, {
  key: 'MW',
  value: 'MW',
  flag: 'mw',
  text: 'Malawi'
}, {
  key: 'MY',
  value: 'MY',
  flag: 'my',
  text: 'Malaysia'
}, {
  key: 'MV',
  value: 'MV',
  flag: 'mv',
  text: 'Maldives'
}, {
  key: 'ML',
  value: 'ML',
  flag: 'ml',
  text: 'Mali'
}, {
  key: 'MT',
  value: 'MT',
  flag: 'mt',
  text: 'Malta'
}, {
  key: 'MH',
  value: 'MH',
  flag: 'mh',
  text: 'Marshall Islands'
}, {
  key: 'MQ',
  value: 'MQ',
  flag: 'mq',
  text: 'Martinique'
}, {
  key: 'MR',
  value: 'MR',
  flag: 'mr',
  text: 'Mauritania'
}, {
  key: 'MU',
  value: 'MU',
  flag: 'mu',
  text: 'Mauritius'
}, {
  key: 'YT',
  value: 'YT',
  flag: 'yt',
  text: 'Mayotte'
}, {
  key: 'MX',
  value: 'MX',
  flag: 'mx',
  text: 'Mexico'
}, {
  key: 'FM',
  value: 'FM',
  flag: 'fm',
  text: 'Micronesia'
}, {
  key: 'MD',
  value: 'MD',
  flag: 'md',
  text: 'Moldova'
}, {
  key: 'MC',
  value: 'MC',
  flag: 'mc',
  text: 'Monaco'
}, {
  key: 'MN',
  value: 'MN',
  flag: 'mn',
  text: 'Mongolia'
}, {
  key: 'ME',
  value: 'ME',
  flag: 'me',
  text: 'Montenegro'
}, {
  key: 'MS',
  value: 'MS',
  flag: 'ms',
  text: 'Montserrat'
}, {
  key: 'MA',
  value: 'MA',
  flag: 'ma',
  text: 'Morocco'
}, {
  key: 'MZ',
  value: 'MZ',
  flag: 'mz',
  text: 'Mozambique'
}, {
  key: 'NA',
  value: 'NA',
  flag: 'na',
  text: 'Namibia'
}, {
  key: 'NR',
  value: 'NR',
  flag: 'nr',
  text: 'Nauru'
}, {
  key: 'NP',
  value: 'NP',
  flag: 'np',
  text: 'Nepal'
}, {
  key: 'AN',
  value: 'AN',
  flag: 'an',
  text: 'Netherlands Antilles'
}, {
  key: 'NL',
  value: 'NL',
  flag: 'nl',
  text: 'Netherlands'
}, {
  key: 'NC',
  value: 'NC',
  flag: 'nc',
  text: 'New Caledonia'
}, {
  key: 'PG',
  value: 'PG',
  flag: 'pg',
  text: 'New Guinea'
}, {
  key: 'NZ',
  value: 'NZ',
  flag: 'nz',
  text: 'New Zealand'
}, {
  key: 'NI',
  value: 'NI',
  flag: 'ni',
  text: 'Nicaragua'
}, {
  key: 'NE',
  value: 'NE',
  flag: 'ne',
  text: 'Niger'
}, {
  key: 'NG',
  value: 'NG',
  flag: 'ng',
  text: 'Nigeria'
}, {
  key: 'NU',
  value: 'NU',
  flag: 'nu',
  text: 'Niue'
}, {
  key: 'NF',
  value: 'NF',
  flag: 'nf',
  text: 'Norfolk Island'
}, {
  key: 'KP',
  value: 'KP',
  flag: 'kp',
  text: 'North Korea'
}, {
  key: 'MP',
  value: 'MP',
  flag: 'mp',
  text: 'Northern Mariana Islands'
}, {
  key: 'NO',
  value: 'NO',
  flag: 'no',
  text: 'Norway'
}, {
  key: 'OM',
  value: 'OM',
  flag: 'om',
  text: 'Oman'
}, {
  key: 'PK',
  value: 'PK',
  flag: 'pk',
  text: 'Pakistan'
}, {
  key: 'PW',
  value: 'PW',
  flag: 'pw',
  text: 'Palau'
}, {
  key: 'PS',
  value: 'PS',
  flag: 'ps',
  text: 'Palestine'
}, {
  key: 'PA',
  value: 'PA',
  flag: 'pa',
  text: 'Panama'
}, {
  key: 'PY',
  value: 'PY',
  flag: 'py',
  text: 'Paraguay'
}, {
  key: 'PE',
  value: 'PE',
  flag: 'pe',
  text: 'Peru'
}, {
  key: 'PH',
  value: 'PH',
  flag: 'ph',
  text: 'Philippines'
}, {
  key: 'PN',
  value: 'PN',
  flag: 'pn',
  text: 'Pitcairn Islands'
}, {
  key: 'PL',
  value: 'PL',
  flag: 'pl',
  text: 'Poland'
}, {
  key: 'PT',
  value: 'PT',
  flag: 'pt',
  text: 'Portugal'
}, {
  key: 'PR',
  value: 'PR',
  flag: 'pr',
  text: 'Puerto Rico'
}, {
  key: 'QA',
  value: 'QA',
  flag: 'qa',
  text: 'Qatar'
}, {
  key: 'RE',
  value: 'RE',
  flag: 're',
  text: 'Reunion'
}, {
  key: 'RO',
  value: 'RO',
  flag: 'ro',
  text: 'Romania'
}, {
  key: 'RU',
  value: 'RU',
  flag: 'ru',
  text: 'Russia'
}, {
  key: 'RW',
  value: 'RW',
  flag: 'rw',
  text: 'Rwanda'
}, {
  key: 'SH',
  value: 'SH',
  flag: 'sh',
  text: 'Saint Helena'
}, {
  key: 'KN',
  value: 'KN',
  flag: 'kn',
  text: 'Saint Kitts and Nevis'
}, {
  key: 'LC',
  value: 'LC',
  flag: 'lc',
  text: 'Saint Lucia'
}, {
  key: 'PM',
  value: 'PM',
  flag: 'pm',
  text: 'Saint Pierre'
}, {
  key: 'VC',
  value: 'VC',
  flag: 'vc',
  text: 'Saint Vincent'
}, {
  key: 'WS',
  value: 'WS',
  flag: 'ws',
  text: 'Samoa'
}, {
  key: 'SM',
  value: 'SM',
  flag: 'sm',
  text: 'San Marino'
}, {
  key: 'GS',
  value: 'GS',
  flag: 'gs',
  text: 'Sandwich Islands'
}, {
  key: 'ST',
  value: 'ST',
  flag: 'st',
  text: 'Sao Tome'
}, {
  key: 'SA',
  value: 'SA',
  flag: 'sa',
  text: 'Saudi Arabia'
}, {
  key: 'SN',
  value: 'SN',
  flag: 'sn',
  text: 'Senegal'
}, {
  key: 'CS',
  value: 'CS',
  flag: 'cs',
  text: 'Serbia'
}, {
  key: 'RS',
  value: 'RS',
  flag: 'rs',
  text: 'Serbia'
}, {
  key: 'SC',
  value: 'SC',
  flag: 'sc',
  text: 'Seychelles'
}, {
  key: 'SL',
  value: 'SL',
  flag: 'sl',
  text: 'Sierra Leone'
}, {
  key: 'SG',
  value: 'SG',
  flag: 'sg',
  text: 'Singapore'
}, {
  key: 'SK',
  value: 'SK',
  flag: 'sk',
  text: 'Slovakia'
}, {
  key: 'SI',
  value: 'SI',
  flag: 'si',
  text: 'Slovenia'
}, {
  key: 'SB',
  value: 'SB',
  flag: 'sb',
  text: 'Solomon Islands'
}, {
  key: 'SO',
  value: 'SO',
  flag: 'so',
  text: 'Somalia'
}, {
  key: 'ZA',
  value: 'ZA',
  flag: 'za',
  text: 'South Africa'
}, {
  key: 'KR',
  value: 'KR',
  flag: 'kr',
  text: 'South Korea'
}, {
  key: 'ES',
  value: 'ES',
  flag: 'es',
  text: 'Spain'
}, {
  key: 'LK',
  value: 'LK',
  flag: 'lk',
  text: 'Sri Lanka'
}, {
  key: 'SD',
  value: 'SD',
  flag: 'sd',
  text: 'Sudan'
}, {
  key: 'SR',
  value: 'SR',
  flag: 'sr',
  text: 'Suriname'
}, {
  key: 'SJ',
  value: 'SJ',
  flag: 'sj',
  text: 'Svalbard'
}, {
  key: 'SZ',
  value: 'SZ',
  flag: 'sz',
  text: 'Swaziland'
}, {
  key: 'SE',
  value: 'SE',
  flag: 'se',
  text: 'Sweden'
}, {
  key: 'CH',
  value: 'CH',
  flag: 'ch',
  text: 'Switzerland'
}, {
  key: 'SY',
  value: 'SY',
  flag: 'sy',
  text: 'Syria'
}, {
  key: 'TW',
  value: 'TW',
  flag: 'tw',
  text: 'Taiwan'
}, {
  key: 'TJ',
  value: 'TJ',
  flag: 'tj',
  text: 'Tajikistan'
}, {
  key: 'TZ',
  value: 'TZ',
  flag: 'tz',
  text: 'Tanzania'
}, {
  key: 'TH',
  value: 'TH',
  flag: 'th',
  text: 'Thailand'
}, {
  key: 'TL',
  value: 'TL',
  flag: 'tl',
  text: 'Timorleste'
}, {
  key: 'TG',
  value: 'TG',
  flag: 'tg',
  text: 'Togo'
}, {
  key: 'TK',
  value: 'TK',
  flag: 'tk',
  text: 'Tokelau'
}, {
  key: 'TO',
  value: 'TO',
  flag: 'to',
  text: 'Tonga'
}, {
  key: 'TT',
  value: 'TT',
  flag: 'tt',
  text: 'Trinidad'
}, {
  key: 'TN',
  value: 'TN',
  flag: 'tn',
  text: 'Tunisia'
}, {
  key: 'TR',
  value: 'TR',
  flag: 'tr',
  text: 'Turkey'
}, {
  key: 'TM',
  value: 'TM',
  flag: 'tm',
  text: 'Turkmenistan'
}, {
  key: 'TV',
  value: 'TV',
  flag: 'tv',
  text: 'Tuvalu'
}, {
  key: 'UG',
  value: 'UG',
  flag: 'ug',
  text: 'Uganda'
}, {
  key: 'UA',
  value: 'UA',
  flag: 'ua',
  text: 'Ukraine'
}, {
  key: 'AE',
  value: 'AE',
  flag: 'ae',
  text: 'United Arab Emirates'
}, {
  key: 'US',
  value: 'US',
  flag: 'us',
  text: 'United States'
}, {
  key: 'UY',
  value: 'UY',
  flag: 'uy',
  text: 'Uruguay'
}, {
  key: 'UM',
  value: 'UM',
  flag: 'um',
  text: 'Us Minor Islands'
}, {
  key: 'VI',
  value: 'VI',
  flag: 'vi',
  text: 'Us Virgin Islands'
}, {
  key: 'UZ',
  value: 'UZ',
  flag: 'uz',
  text: 'Uzbekistan'
}, {
  key: 'VU',
  value: 'VU',
  flag: 'vu',
  text: 'Vanuatu'
}, {
  key: 'VA',
  value: 'VA',
  flag: 'va',
  text: 'Vatican City'
}, {
  key: 'VE',
  value: 'VE',
  flag: 've',
  text: 'Venezuela'
}, {
  key: 'VN',
  value: 'VN',
  flag: 'vn',
  text: 'Vietnam'
}, {
  key: 'WF',
  value: 'WF',
  flag: 'wf',
  text: 'Wallis and Futuna'
}, {
  key: 'EH',
  value: 'EH',
  flag: 'eh',
  text: 'Western Sahara'
}, {
  key: 'YE',
  value: 'YE',
  flag: 'ye',
  text: 'Yemen'
}, {
  key: 'ZM',
  value: 'ZM',
  flag: 'zm',
  text: 'Zambia'
}, {
  key: 'ZW',
  value: 'ZW',
  flag: 'zw',
  text: 'Zimbabwe'
}];

function fetchKycCountries(_x) {
  return _fetchKycCountries.apply(this, arguments);
}
/**
 * Checks blockchain for a list of kycproviders, and sorts through the ones that are blacklisted.
 * @returns An array of strings with valid kyc provider names.
 */

function _fetchKycCountries() {
  _fetchKycCountries = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(_ref) {
    var chain, url, _yield$this$get, countries, countriesById;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            chain = _ref.chain;
            url = constants.BLOKS_API + "/" + chain + "/kyc?type=countries&chain=" + chain;
            _context.next = 4;
            return this.get(url);

          case 4:
            _yield$this$get = _context.sent;
            countries = _yield$this$get.content;
            countriesById = countries.reduce(function (acc, country) {
              acc[country.id] = country;
              return acc;
            }, {});
            return _context.abrupt("return", countryOptions.filter(function (countryOption) {
              return countriesById[countryOption.key];
            }));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _fetchKycCountries.apply(this, arguments);
}

function getValidKycProviders() {
  return _getValidKycProviders.apply(this, arguments);
}
/**
 * Takes an account or a list of accounts and checks to make sure that they are light-verified
 * @param account This could be an array of user rows from the usersinfo table on the blockchain, or a singular string for an account name
 * @returns An object of the user data as pulled from the usersinfo table on the blockchain with an additional key, isLightKYCVerified (boolean)
 */

function _getValidKycProviders() {
  _getValidKycProviders = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
    var _yield$this$get_table, rows;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.get_table_rows({
              code: 'eosio.proton',
              table: 'kycproviders',
              scope: 'eosio.proton'
            });

          case 3:
            _yield$this$get_table = _context2.sent;
            rows = _yield$this$get_table.rows;
            this.validKycProviders = rows.map(function (provider) {
              return !provider.blisted && provider.kyc_provider;
            });
            _context2.next = 11;
            break;

          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](0);
            throw new Error('Unable to get KYC Providers.');

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 8]]);
  }));
  return _getValidKycProviders.apply(this, arguments);
}

function isLightKYCVerified(_x2) {
  return _isLightKYCVerified.apply(this, arguments);
}

function _isLightKYCVerified() {
  _isLightKYCVerified = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(account) {
    var _this = this;

    var lightKyc, users, _yield$this$get_table2, rows, resultsWithKycStatus;

    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            lightKyc = ["firstname", "lastname", "birthdate", "address"];

            if (!(account.length === 0)) {
              _context3.next = 3;
              break;
            }

            throw new Error('Please enter an account.');

          case 3:
            if (!(this.validKycProviders.length === 0)) {
              _context3.next = 6;
              break;
            }

            _context3.next = 6;
            return this.getValidKycProviders();

          case 6:
            users = [];

            if (!Array.isArray(account)) {
              _context3.next = 11;
              break;
            }

            users = account;
            _context3.next = 23;
            break;

          case 11:
            if (!(typeof account === 'string')) {
              _context3.next = 23;
              break;
            }

            _context3.prev = 12;
            _context3.next = 15;
            return this.get_table_rows({
              code: 'eosio.proton',
              table: 'usersinfo',
              scope: 'eosio.proton',
              lower_bound: account,
              upper_bound: account
            });

          case 15:
            _yield$this$get_table2 = _context3.sent;
            rows = _yield$this$get_table2.rows;
            users = rows;
            _context3.next = 23;
            break;

          case 20:
            _context3.prev = 20;
            _context3.t0 = _context3["catch"](12);
            throw new Error('Account not found!');

          case 23:
            resultsWithKycStatus = users.map(function (user) {
              var levelsResult = user.kyc.reduce(function (acc, kyc) {
                if (_this.validKycProviders.indexOf(kyc.kyc_provider) >= 0) {
                  var result = kyc.kyc_level.split(',').map(function (kycItem) {
                    return kycItem.split(':')[1];
                  });
                  acc = result.concat(acc);
                }

                return acc;
              }, []);
              user.isLightKYCVerified = lightKyc.every(function (lightKycField) {
                return levelsResult.includes(lightKycField);
              });
              return user;
            });
            return _context3.abrupt("return", resultsWithKycStatus);

          case 25:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this, [[12, 20]]);
  }));
  return _isLightKYCVerified.apply(this, arguments);
}
/**
 * FAILED
 * UNSUBMITTED
 * PENDING
 * PASSED
 */

function checkUserKycStatus(_x3) {
  return _checkUserKycStatus.apply(this, arguments);
}

function _checkUserKycStatus() {
  _checkUserKycStatus = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(_ref2) {
    var _this2 = this;

    var chain, actor, expectedTier;
    return runtime_1.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            chain = _ref2.chain, actor = _ref2.actor, expectedTier = _ref2.expectedTier;

            if (!(!chain || !actor || !expectedTier)) {
              _context6.next = 3;
              break;
            }

            throw new Error('Invalid parameters');

          case 3:
            return _context6.abrupt("return", new Promise( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(resolve, reject) {
                var getStatus;
                return runtime_1.wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        // Get all KYC records for user
                        getStatus = /*#__PURE__*/function () {
                          var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
                            var _yield$_this2$isLight, userInfo, url, kyc, matchedTier, status;

                            return runtime_1.wrap(function _callee4$(_context4) {
                              while (1) {
                                switch (_context4.prev = _context4.next) {
                                  case 0:
                                    _context4.next = 2;
                                    return _this2.isLightKYCVerified(actor);

                                  case 2:
                                    _yield$_this2$isLight = _context4.sent;
                                    userInfo = _yield$_this2$isLight[0];

                                    if (!(userInfo && userInfo.isLightKYCVerified)) {
                                      _context4.next = 6;
                                      break;
                                    }

                                    return _context4.abrupt("return", resolve(KycStatus.PASSED));

                                  case 6:
                                    url = constants.BLOKS_API + "/" + chain + "/kyc?type=status&chain=" + chain + "&actor=" + actor;
                                    _context4.next = 9;
                                    return _this2.get(url);

                                  case 9:
                                    kyc = _context4.sent;

                                    if (!(!kyc || !kyc.length)) {
                                      _context4.next = 12;
                                      break;
                                    }

                                    return _context4.abrupt("return", reject(new Error('Could not fetch KYC record')));

                                  case 12:
                                    // Find relevant KYC record
                                    matchedTier = kyc.find(function (_ref5) {
                                      var tier = _ref5.tier;
                                      return tier === String(expectedTier);
                                    });

                                    if (matchedTier) {
                                      _context4.next = 15;
                                      break;
                                    }

                                    return _context4.abrupt("return", reject(new Error('No kyc data matching tier found')));

                                  case 15:
                                    // Unwrap kyc data
                                    status = matchedTier.status;

                                    if (matchedTier.status) {
                                      _context4.next = 18;
                                      break;
                                    }

                                    return _context4.abrupt("return", reject(new Error('KYC Status not found')));

                                  case 18:
                                    if (!(status === KycStatus.PENDING)) {
                                      _context4.next = 22;
                                      break;
                                    }

                                    setTimeout(function () {
                                      return getStatus();
                                    }, 1000 * 2);
                                    _context4.next = 23;
                                    break;

                                  case 22:
                                    return _context4.abrupt("return", resolve(status));

                                  case 23:
                                  case "end":
                                    return _context4.stop();
                                }
                              }
                            }, _callee4);
                          }));

                          return function getStatus() {
                            return _ref4.apply(this, arguments);
                          };
                        }();

                        getStatus();

                      case 2:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5);
              }));

              return function (_x5, _x6) {
                return _ref3.apply(this, arguments);
              };
            }()));

          case 4:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _checkUserKycStatus.apply(this, arguments);
}

function applyForKyc(_x4) {
  return _applyForKyc.apply(this, arguments);
}

function _applyForKyc() {
  _applyForKyc = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(params) {
    var url, data;
    return runtime_1.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            url = constants.BLOKS_API + "/" + params.chain + "/kyc";
            _context7.next = 3;
            return this.post(url, Object.assign({
              type: 'apply'
            }, params));

          case 3:
            data = _context7.sent;

            if (!data) {
              _context7.next = 8;
              break;
            }

            return _context7.abrupt("return", data);

          case 8:
            throw new Error('Could not apply for KYC');

          case 9:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, this);
  }));
  return _applyForKyc.apply(this, arguments);
}

function currentLocation() {
  return _currentLocation.apply(this, arguments);
}

function _currentLocation() {
  _currentLocation = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8() {
    var url;
    return runtime_1.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            url = constants.PROTON_API + "/v1/kyc/ip-info";
            _context8.next = 3;
            return this.get(url);

          case 3:
            return _context8.abrupt("return", _context8.sent);

          case 4:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8, this);
  }));
  return _currentLocation.apply(this, arguments);
}

var Status;

(function (Status) {
  Status["PENDING"] = "pending";
  Status["SUCCESS"] = "success";
  Status["FAIL"] = "fail";
  Status["PROCESSING"] = "processing";
})(Status || (Status = {}));
var rateParser = /*#__PURE__*/object({
  counterCurrency: /*#__PURE__*/string(),
  price: /*#__PURE__*/number(),
  priceChangePercent: /*#__PURE__*/number(),
  marketCap: /*#__PURE__*/number(),
  volume: /*#__PURE__*/number(),
  timestamp: /*#__PURE__*/number()
});
var exchangeRateParser = /*#__PURE__*/object({
  contract: /*#__PURE__*/string(),
  symbol: /*#__PURE__*/string(),
  rank: /*#__PURE__*/number(),
  rates: /*#__PURE__*/array(rateParser)
});
var exchangeRatesParser = /*#__PURE__*/array(exchangeRateParser);
var withdrawalFeeQuoteParser = /*#__PURE__*/object({
  quoteId: /*#__PURE__*/string(),
  estimatedFee: /*#__PURE__*/string(),
  currency: /*#__PURE__*/string(),
  network: /*#__PURE__*/string()
});

function getTokenPrices() {
  return _getTokenPrices.apply(this, arguments);
}

function _getTokenPrices() {
  _getTokenPrices = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
    var url, _yield$this$get, data;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = constants.METAL_PROTON_ENDPOINT + "/v1/chain/exchange-rates/info";
            _context.prev = 1;
            _context.next = 4;
            return this.get(url);

          case 4:
            _yield$this$get = _context.sent;
            data = _yield$this$get.data;
            return _context.abrupt("return", exchangeRatesParser.parse(data));

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](1);
            throw new Error("Could not fetch exchange rates");

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 9]]);
  }));
  return _getTokenPrices.apply(this, arguments);
}

function getWithdrawalFee(_x) {
  return _getWithdrawalFee.apply(this, arguments);
}

function _getWithdrawalFee() {
  _getWithdrawalFee = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref) {
    var currency, network, url, _yield$this$post, data;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            currency = _ref.currency, network = _ref.network;
            url = constants.METAL_PROTON_ENDPOINT + "/v1/swaps/calculate-estimated-fee";
            _context2.prev = 2;
            _context2.next = 5;
            return this.post(url, {
              currency: currency,
              network: network
            });

          case 5:
            _yield$this$post = _context2.sent;
            data = _yield$this$post.data;
            return _context2.abrupt("return", withdrawalFeeQuoteParser.parse(data));

          case 10:
            _context2.prev = 10;
            _context2.t0 = _context2["catch"](2);
            console.log(_context2.t0);
            return _context2.abrupt("return", undefined);

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[2, 10]]);
  }));
  return _getWithdrawalFee.apply(this, arguments);
}

function otcQuote(_x) {
  return _otcQuote.apply(this, arguments);
}

function _otcQuote() {
  _otcQuote = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(body) {
    var url, _yield$this$get, data;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = constants.SWAP_URL + ("/v1/quote/" + body.baseSymbol + "/" + body.baseAmount + "/" + body.quoteSymbol);
            _context.next = 3;
            return this.get(url);

          case 3:
            _yield$this$get = _context.sent;
            data = _yield$this$get.data;
            return _context.abrupt("return", data);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _otcQuote.apply(this, arguments);
}

function otcOrder(_x2) {
  return _otcOrder.apply(this, arguments);
}

function _otcOrder() {
  _otcOrder = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(id) {
    var url, _yield$this$get2, data;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = constants.SWAP_URL + ("/v1/order/" + id);
            _context2.next = 3;
            return this.get(url);

          case 3:
            _yield$this$get2 = _context2.sent;
            data = _yield$this$get2.data;
            return _context2.abrupt("return", data);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _otcOrder.apply(this, arguments);
}

function generateAddress(_x) {
  return _generateAddress.apply(this, arguments);
}

function _generateAddress() {
  _generateAddress = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(body) {
    var url, _yield$this$post, data;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = constants.WRAP_SERVER_URL + '/address/generate';
            _context.next = 3;
            return this.post(url, body);

          case 3:
            _yield$this$post = _context.sent;
            data = _yield$this$post.data;
            return _context.abrupt("return", data);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _generateAddress.apply(this, arguments);
}

function withdrawMetal(_x2) {
  return _withdrawMetal.apply(this, arguments);
}

function _withdrawMetal() {
  _withdrawMetal = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(body) {
    var url, _yield$this$post2, data;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = constants.WRAP_SERVER_URL + '/withdraw';
            _context2.next = 3;
            return this.post(url, body);

          case 3:
            _yield$this$post2 = _context2.sent;
            data = _yield$this$post2.data;
            return _context2.abrupt("return", data);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _withdrawMetal.apply(this, arguments);
}

function withdrawalHistoryMetal(_x3) {
  return _withdrawalHistoryMetal.apply(this, arguments);
}

function _withdrawalHistoryMetal() {
  _withdrawalHistoryMetal = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(account) {
    var url, _yield$this$get, data;

    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            url = constants.WRAP_SERVER_URL + ("/withdrawals/" + account);
            _context3.next = 3;
            return this.get(url);

          case 3:
            _yield$this$get = _context3.sent;
            data = _yield$this$get.data;
            return _context3.abrupt("return", data);

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _withdrawalHistoryMetal.apply(this, arguments);
}

/** Raw call to `/v1/chain/get_table_rows` */
function get_table_rows(_x) {
  return _get_table_rows.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_kv_table_rows` */

function _get_table_rows() {
  _get_table_rows = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(_ref) {
    var _ref$json, json, code, scope, table, _ref$table_key, table_key, _ref$lower_bound, lower_bound, _ref$upper_bound, upper_bound, _ref$index_position, index_position, _ref$key_type, key_type, _ref$limit, limit, _ref$reverse, reverse, _ref$show_payer, show_payer;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref$json = _ref.json, json = _ref$json === void 0 ? true : _ref$json, code = _ref.code, scope = _ref.scope, table = _ref.table, _ref$table_key = _ref.table_key, table_key = _ref$table_key === void 0 ? '' : _ref$table_key, _ref$lower_bound = _ref.lower_bound, lower_bound = _ref$lower_bound === void 0 ? '' : _ref$lower_bound, _ref$upper_bound = _ref.upper_bound, upper_bound = _ref$upper_bound === void 0 ? '' : _ref$upper_bound, _ref$index_position = _ref.index_position, index_position = _ref$index_position === void 0 ? 1 : _ref$index_position, _ref$key_type = _ref.key_type, key_type = _ref$key_type === void 0 ? '' : _ref$key_type, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 10 : _ref$limit, _ref$reverse = _ref.reverse, reverse = _ref$reverse === void 0 ? false : _ref$reverse, _ref$show_payer = _ref.show_payer, show_payer = _ref$show_payer === void 0 ? false : _ref$show_payer;
            _context.next = 3;
            return this.post('/v1/chain/get_table_rows', {
              json: json,
              code: code,
              scope: scope,
              table: table,
              table_key: table_key,
              lower_bound: lower_bound,
              upper_bound: upper_bound,
              index_position: index_position,
              key_type: key_type,
              limit: limit,
              reverse: reverse,
              show_payer: show_payer
            });

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _get_table_rows.apply(this, arguments);
}

function get_kv_table_rows(_x2) {
  return _get_kv_table_rows.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_table_by_scope` */

function _get_kv_table_rows() {
  _get_kv_table_rows = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref2) {
    var _ref2$json, json, code, table, index_name, _ref2$encode_type, encode_type, _ref2$index_value, index_value, _ref2$lower_bound, lower_bound, _ref2$upper_bound, upper_bound, _ref2$limit, limit, _ref2$reverse, reverse, _ref2$show_payer, show_payer;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref2$json = _ref2.json, json = _ref2$json === void 0 ? true : _ref2$json, code = _ref2.code, table = _ref2.table, index_name = _ref2.index_name, _ref2$encode_type = _ref2.encode_type, encode_type = _ref2$encode_type === void 0 ? 'bytes' : _ref2$encode_type, _ref2$index_value = _ref2.index_value, index_value = _ref2$index_value === void 0 ? '' : _ref2$index_value, _ref2$lower_bound = _ref2.lower_bound, lower_bound = _ref2$lower_bound === void 0 ? '' : _ref2$lower_bound, _ref2$upper_bound = _ref2.upper_bound, upper_bound = _ref2$upper_bound === void 0 ? '' : _ref2$upper_bound, _ref2$limit = _ref2.limit, limit = _ref2$limit === void 0 ? 10 : _ref2$limit, _ref2$reverse = _ref2.reverse, reverse = _ref2$reverse === void 0 ? false : _ref2$reverse, _ref2$show_payer = _ref2.show_payer, show_payer = _ref2$show_payer === void 0 ? false : _ref2$show_payer;
            _context2.next = 3;
            return this.post('/v1/chain/get_kv_table_rows', {
              json: json,
              code: code,
              table: table,
              index_name: index_name,
              encode_type: encode_type,
              index_value: index_value,
              lower_bound: lower_bound,
              upper_bound: upper_bound,
              limit: limit,
              reverse: reverse,
              show_payer: show_payer
            });

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _get_kv_table_rows.apply(this, arguments);
}

function get_table_by_scope(_x3) {
  return _get_table_by_scope.apply(this, arguments);
}

function _get_table_by_scope() {
  _get_table_by_scope = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(_ref3) {
    var code, table, _ref3$lower_bound, lower_bound, _ref3$upper_bound, upper_bound, _ref3$limit, limit;

    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            code = _ref3.code, table = _ref3.table, _ref3$lower_bound = _ref3.lower_bound, lower_bound = _ref3$lower_bound === void 0 ? '' : _ref3$lower_bound, _ref3$upper_bound = _ref3.upper_bound, upper_bound = _ref3$upper_bound === void 0 ? '' : _ref3$upper_bound, _ref3$limit = _ref3.limit, limit = _ref3$limit === void 0 ? 10 : _ref3$limit;
            _context3.next = 3;
            return this.post('/v1/chain/get_table_by_scope', {
              code: code,
              table: table,
              lower_bound: lower_bound,
              upper_bound: upper_bound,
              limit: limit
            });

          case 3:
            return _context3.abrupt("return", _context3.sent);

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _get_table_by_scope.apply(this, arguments);
}

var arrayToHex$1 = function arrayToHex(data) {
  var result = '';

  for (var _iterator = _createForOfIteratorHelperLoose(data), _step; !(_step = _iterator()).done;) {
    var x = _step.value;
    result += ('00' + x.toString(16)).slice(-2);
  }

  return result;
};

/** Push a serialized transaction (replaced by send_transaction, but returned format has changed) */

function push_transaction(_x) {
  return _push_transaction.apply(this, arguments);
}
/** Send a serialized transaction */

function _push_transaction() {
  _push_transaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(_ref) {
    var signatures, _ref$compression, compression, serializedTransaction, serializedContextFreeData, expired;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            signatures = _ref.signatures, _ref$compression = _ref.compression, compression = _ref$compression === void 0 ? 0 : _ref$compression, serializedTransaction = _ref.serializedTransaction, serializedContextFreeData = _ref.serializedContextFreeData;
            _context.prev = 1;
            _context.next = 4;
            return this.post('/v1/chain/push_transaction', {
              signatures: signatures,
              compression: compression,
              packed_context_free_data: arrayToHex$1(serializedContextFreeData || new Uint8Array(0)),
              packed_trx: arrayToHex$1(serializedTransaction)
            });

          case 4:
            return _context.abrupt("return", _context.sent);

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](1);

            if (_context.t0 && _context.t0.json && _context.t0.json.error) {
              expired = _context.t0.json.error.name === 'expired_tx_exception';

              if (expired) {
                _context.t0.json.error.message = 'Transaction Expired: Try Again';
                this.nextEndpoint();
              }
            }

            throw _context.t0;

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 7]]);
  }));
  return _push_transaction.apply(this, arguments);
}

function send_transaction(_x2) {
  return _send_transaction.apply(this, arguments);
}

function _send_transaction() {
  _send_transaction = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_ref2) {
    var signatures, _ref2$compression, compression, serializedTransaction, serializedContextFreeData;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            signatures = _ref2.signatures, _ref2$compression = _ref2.compression, compression = _ref2$compression === void 0 ? 0 : _ref2$compression, serializedTransaction = _ref2.serializedTransaction, serializedContextFreeData = _ref2.serializedContextFreeData;
            _context2.next = 3;
            return this.post('/v1/chain/send_transaction', {
              signatures: signatures,
              compression: compression,
              packed_context_free_data: arrayToHex$1(serializedContextFreeData || new Uint8Array(0)),
              packed_trx: arrayToHex$1(serializedTransaction)
            });

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _send_transaction.apply(this, arguments);
}

/** Raw call to `/v1/chain/get_abi` */

function get_abi(_x) {
  return _get_abi.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_raw_code_and_abi` */

function _get_abi() {
  _get_abi = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(accountName) {
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return this.post('/v1/chain/get_abi', {
              account_name: accountName
            });

          case 2:
            return _context.abrupt("return", _context.sent);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _get_abi.apply(this, arguments);
}

function get_raw_code_and_abi(_x2) {
  return _get_raw_code_and_abi.apply(this, arguments);
}
/** calls `/v1/chain/get_raw_abi` and pulls out unneeded raw wasm code */

function _get_raw_code_and_abi() {
  _get_raw_code_and_abi = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(accountName) {
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.post('/v1/chain/get_raw_code_and_abi', {
              account_name: accountName
            });

          case 2:
            return _context2.abrupt("return", _context2.sent);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));
  return _get_raw_code_and_abi.apply(this, arguments);
}

function getRawAbi(_x3) {
  return _getRawAbi.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_raw_abi` */

function _getRawAbi() {
  _getRawAbi = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(accountName) {
    var rawCodeAndAbi, abi;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return this.get_raw_abi(accountName);

          case 2:
            rawCodeAndAbi = _context3.sent;
            abi = base64ToBinary(rawCodeAndAbi.abi);
            return _context3.abrupt("return", {
              accountName: rawCodeAndAbi.account_name,
              abi: abi
            });

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));
  return _getRawAbi.apply(this, arguments);
}

function get_raw_abi(_x4) {
  return _get_raw_abi.apply(this, arguments);
}
/** Raw call to `/v1/chain/get_code` */

function _get_raw_abi() {
  _get_raw_abi = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(accountName) {
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.post('/v1/chain/get_raw_abi', {
              account_name: accountName
            });

          case 2:
            return _context4.abrupt("return", _context4.sent);

          case 3:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));
  return _get_raw_abi.apply(this, arguments);
}

function get_code(_x5) {
  return _get_code.apply(this, arguments);
}

function _get_code() {
  _get_code = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(accountName) {
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.post('/v1/chain/get_code', {
              account_name: accountName,
              code_as_wasm: true
            });

          case 2:
            return _context5.abrupt("return", _context5.sent);

          case 3:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));
  return _get_code.apply(this, arguments);
}

/**
 * @module RPC-Error
 */

/** Holds detailed error information */
var RpcError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RpcError, _Error);

  function RpcError(json) {
    var _this;

    if (json && json.error && json.error.details && json.error.details.length && json.error.details[0].message) {
      _this = _Error.call(this, json.error.details[0].message) || this;
    } else if (json && json.processed && json.processed.except && json.processed.except.message) {
      _this = _Error.call(this, json.processed.except.message) || this;
    } else if (json) {
      _this = _Error.call(this, json.message) || this;
    } else {
      _this = _Error.call(this, json) || this;
    }

    Object.setPrototypeOf(_assertThisInitialized(_this), RpcError.prototype);
    _this.json = json;
    return _assertThisInitialized(_this);
  }

  return RpcError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

/** Make RPC calls */

var JsonRpc = /*#__PURE__*/function () {
  /**
   * @param args
   *`fetch`:
   * browsers: leave `null` or `undefined`
   * node: provide an implementation
   */
  function JsonRpc(endpoints) {
    this.maxRetries = 3;
    this.validKycProviders = [];
    this.get_account = get_account;
    this.get_block_header_state = get_block_header_state;
    this.get_block_info = get_block_info;
    this.get_block = get_block;
    this.get_currency_balance = get_currency_balance;
    this.get_currency_stats = get_currency_stats;
    this.get_info = get_info;
    this.get_producer_schedule = get_producer_schedule;
    this.get_producers = get_producers;
    this.get_scheduled_transactions = get_scheduled_transactions;
    this.get_activated_protocol_features = get_activated_protocol_features;
    this.getRequiredKeys = getRequiredKeys;
    this.get_abi = get_abi;
    this.get_raw_code_and_abi = get_raw_code_and_abi;
    this.getRawAbi = getRawAbi;
    this.get_raw_abi = get_raw_abi;
    this.get_code = get_code;
    this.push_transaction = push_transaction;
    this.send_transaction = send_transaction;
    this.get_table_rows = get_table_rows;
    this.get_kv_table_rows = get_kv_table_rows;
    this.get_table_by_scope = get_table_by_scope;
    this.history_get_actions = history_get_actions;
    this.history_get_transaction = history_get_transaction;
    this.history_get_key_accounts = history_get_key_accounts;
    this.history_get_controlled_accounts = history_get_controlled_accounts;
    this.db_size_get = db_size_get; // Proton

    this.fetchKycCountries = fetchKycCountries;
    this.getValidKycProviders = getValidKycProviders;
    this.isLightKYCVerified = isLightKYCVerified;
    this.checkUserKycStatus = checkUserKycStatus;
    this.applyForKyc = applyForKyc;
    this.currentLocation = currentLocation;
    this.otcQuote = otcQuote;
    this.otcOrder = otcOrder;
    this.generateAddress = generateAddress;
    this.withdrawMetal = withdrawMetal;
    this.withdrawalHistoryMetal = withdrawalHistoryMetal;
    this.getTokenPrices = getTokenPrices;
    this.getWithdrawalFee = getWithdrawalFee;
    endpoints = Array.isArray(endpoints) ? endpoints : [endpoints];
    this.endpoints = endpoints.map(function (endpoint) {
      return endpoint.replace(/\/$/, '');
    });
    this.currentEndpoint = '';
    this.nextEndpoint();
  }

  var _proto = JsonRpc.prototype;

  _proto.nextEndpoint = function nextEndpoint() {
    if (this.endpoints.length) {
      if (this.currentEndpoint) {
        var removed = this.endpoints.shift();
        this.endpoints = this.endpoints.concat(removed || []);
      }

      this.currentEndpoint = this.endpoints[0];
    }
  }
  /** Post `body` to `endpoint + path`. Throws detailed error information in `RpcError` when available. */
  ;

  _proto.post =
  /*#__PURE__*/
  function () {
    var _post = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(path, body, currentRetries) {
      var response, json, headTime, ct, secondsBehind;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (currentRetries === void 0) {
                currentRetries = 0;
              }

              _context.prev = 1;
              _context.next = 4;
              return fetch(this.currentEndpoint + path, {
                body: JSON.stringify(body),
                method: 'POST'
              });

            case 4:
              response = _context.sent;
              _context.next = 7;
              return response.json();

            case 7:
              json = _context.sent;

              if (!(json.processed && json.processed.except)) {
                _context.next = 10;
                break;
              }

              throw new RpcError(json);

            case 10:
              _context.next = 22;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](1);

              if (!(this.endpoints.length > 1)) {
                _context.next = 22;
                break;
              }

              this.nextEndpoint();

              if (!(currentRetries < this.maxRetries)) {
                _context.next = 20;
                break;
              }

              return _context.abrupt("return", this.post(path, body, ++currentRetries));

            case 20:
              _context.t0.isFetchError = true;
              throw new RpcError(_context.t0);

            case 22:
              if (response && response.ok) {
                _context.next = 24;
                break;
              }

              throw new RpcError(json);

            case 24:
              if (!(json && json.head_block_time)) {
                _context.next = 32;
                break;
              }

              headTime = new Date(json.head_block_time + 'Z').getTime();
              ct = new Date().getTime();
              secondsBehind = (ct - headTime) / 1000;

              if (!(secondsBehind > constants.MAX_SECONDS_BEHIND && this.endpoints.length > 1)) {
                _context.next = 32;
                break;
              }

              this.nextEndpoint();

              if (!(currentRetries < this.maxRetries)) {
                _context.next = 32;
                break;
              }

              return _context.abrupt("return", this.post(path, body, ++currentRetries));

            case 32:
              return _context.abrupt("return", json);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 12]]);
    }));

    function post(_x, _x2, _x3) {
      return _post.apply(this, arguments);
    }

    return post;
  }()
  /** Get from endpoint  */
  ;

  _proto.get =
  /*#__PURE__*/
  function () {
    var _get = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(path) {
      var res;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return fetch(path);

            case 2:
              res = _context2.sent;

              if (!(res.status >= 400)) {
                _context2.next = 5;
                break;
              }

              throw new Error("Bad response from server " + res.status);

            case 5:
              _context2.next = 7;
              return res.json();

            case 7:
              return _context2.abrupt("return", _context2.sent);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function get(_x4) {
      return _get.apply(this, arguments);
    }

    return get;
  }();

  return JsonRpc;
}(); // JsonRpc

var index = {
  Api: Api,
  ApiInterfaces: ApiInterfaces,
  JsonRpc: JsonRpc,
  Numeric: Numeric,
  RpcInterfaces: RpcInterfaces,
  RpcError: RpcError,
  Serialize: Serialize,
  JsSignatureProvider: JsSignatureProvider,
  Key: Key,
  sha256: sha256
};

export default index;
export { Api, ApiInterfaces, JsSignatureProvider, JsonRpc, Key, Numeric, RpcError, RpcInterfaces, Serialize, sha256 };
//# sourceMappingURL=js.esm.js.map
